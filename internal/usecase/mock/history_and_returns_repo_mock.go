// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i pvz-cli/internal/usecase.HistoryAndReturnsRepository -o history_and_returns_repo_mock.go -n HistoryAndReturnsRepositoryMock -p mock

import (
	"context"
	"pvz-cli/internal/domain/models"
	"pvz-cli/internal/domain/vo"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// HistoryAndReturnsRepositoryMock implements mm_usecase.HistoryAndReturnsRepository
type HistoryAndReturnsRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddHistory          func(ctx context.Context, e *models.HistoryEvent) (err error)
	funcAddHistoryOrigin    string
	inspectFuncAddHistory   func(ctx context.Context, e *models.HistoryEvent)
	afterAddHistoryCounter  uint64
	beforeAddHistoryCounter uint64
	AddHistoryMock          mHistoryAndReturnsRepositoryMockAddHistory

	funcAddReturn          func(ctx context.Context, rec *models.ReturnRecord) (err error)
	funcAddReturnOrigin    string
	inspectFuncAddReturn   func(ctx context.Context, rec *models.ReturnRecord)
	afterAddReturnCounter  uint64
	beforeAddReturnCounter uint64
	AddReturnMock          mHistoryAndReturnsRepositoryMockAddReturn

	funcHistory          func(ctx context.Context, pg vo.Pagination) (hpa1 []*models.HistoryEvent, err error)
	funcHistoryOrigin    string
	inspectFuncHistory   func(ctx context.Context, pg vo.Pagination)
	afterHistoryCounter  uint64
	beforeHistoryCounter uint64
	HistoryMock          mHistoryAndReturnsRepositoryMockHistory

	funcListReturns          func(ctx context.Context, pg vo.Pagination) (rpa1 []*models.ReturnRecord, err error)
	funcListReturnsOrigin    string
	inspectFuncListReturns   func(ctx context.Context, pg vo.Pagination)
	afterListReturnsCounter  uint64
	beforeListReturnsCounter uint64
	ListReturnsMock          mHistoryAndReturnsRepositoryMockListReturns

	funcListReturnsByUser          func(ctx context.Context, userID string) (rpa1 []*models.ReturnRecord, err error)
	funcListReturnsByUserOrigin    string
	inspectFuncListReturnsByUser   func(ctx context.Context, userID string)
	afterListReturnsByUserCounter  uint64
	beforeListReturnsByUserCounter uint64
	ListReturnsByUserMock          mHistoryAndReturnsRepositoryMockListReturnsByUser
}

// NewHistoryAndReturnsRepositoryMock returns a mock for mm_usecase.HistoryAndReturnsRepository
func NewHistoryAndReturnsRepositoryMock(t minimock.Tester) *HistoryAndReturnsRepositoryMock {
	m := &HistoryAndReturnsRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddHistoryMock = mHistoryAndReturnsRepositoryMockAddHistory{mock: m}
	m.AddHistoryMock.callArgs = []*HistoryAndReturnsRepositoryMockAddHistoryParams{}

	m.AddReturnMock = mHistoryAndReturnsRepositoryMockAddReturn{mock: m}
	m.AddReturnMock.callArgs = []*HistoryAndReturnsRepositoryMockAddReturnParams{}

	m.HistoryMock = mHistoryAndReturnsRepositoryMockHistory{mock: m}
	m.HistoryMock.callArgs = []*HistoryAndReturnsRepositoryMockHistoryParams{}

	m.ListReturnsMock = mHistoryAndReturnsRepositoryMockListReturns{mock: m}
	m.ListReturnsMock.callArgs = []*HistoryAndReturnsRepositoryMockListReturnsParams{}

	m.ListReturnsByUserMock = mHistoryAndReturnsRepositoryMockListReturnsByUser{mock: m}
	m.ListReturnsByUserMock.callArgs = []*HistoryAndReturnsRepositoryMockListReturnsByUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mHistoryAndReturnsRepositoryMockAddHistory struct {
	optional           bool
	mock               *HistoryAndReturnsRepositoryMock
	defaultExpectation *HistoryAndReturnsRepositoryMockAddHistoryExpectation
	expectations       []*HistoryAndReturnsRepositoryMockAddHistoryExpectation

	callArgs []*HistoryAndReturnsRepositoryMockAddHistoryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// HistoryAndReturnsRepositoryMockAddHistoryExpectation specifies expectation struct of the HistoryAndReturnsRepository.AddHistory
type HistoryAndReturnsRepositoryMockAddHistoryExpectation struct {
	mock               *HistoryAndReturnsRepositoryMock
	params             *HistoryAndReturnsRepositoryMockAddHistoryParams
	paramPtrs          *HistoryAndReturnsRepositoryMockAddHistoryParamPtrs
	expectationOrigins HistoryAndReturnsRepositoryMockAddHistoryExpectationOrigins
	results            *HistoryAndReturnsRepositoryMockAddHistoryResults
	returnOrigin       string
	Counter            uint64
}

// HistoryAndReturnsRepositoryMockAddHistoryParams contains parameters of the HistoryAndReturnsRepository.AddHistory
type HistoryAndReturnsRepositoryMockAddHistoryParams struct {
	ctx context.Context
	e   *models.HistoryEvent
}

// HistoryAndReturnsRepositoryMockAddHistoryParamPtrs contains pointers to parameters of the HistoryAndReturnsRepository.AddHistory
type HistoryAndReturnsRepositoryMockAddHistoryParamPtrs struct {
	ctx *context.Context
	e   **models.HistoryEvent
}

// HistoryAndReturnsRepositoryMockAddHistoryResults contains results of the HistoryAndReturnsRepository.AddHistory
type HistoryAndReturnsRepositoryMockAddHistoryResults struct {
	err error
}

// HistoryAndReturnsRepositoryMockAddHistoryOrigins contains origins of expectations of the HistoryAndReturnsRepository.AddHistory
type HistoryAndReturnsRepositoryMockAddHistoryExpectationOrigins struct {
	origin    string
	originCtx string
	originE   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) Optional() *mHistoryAndReturnsRepositoryMockAddHistory {
	mmAddHistory.optional = true
	return mmAddHistory
}

// Expect sets up expected params for HistoryAndReturnsRepository.AddHistory
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) Expect(ctx context.Context, e *models.HistoryEvent) *mHistoryAndReturnsRepositoryMockAddHistory {
	if mmAddHistory.mock.funcAddHistory != nil {
		mmAddHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddHistory mock is already set by Set")
	}

	if mmAddHistory.defaultExpectation == nil {
		mmAddHistory.defaultExpectation = &HistoryAndReturnsRepositoryMockAddHistoryExpectation{}
	}

	if mmAddHistory.defaultExpectation.paramPtrs != nil {
		mmAddHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddHistory mock is already set by ExpectParams functions")
	}

	mmAddHistory.defaultExpectation.params = &HistoryAndReturnsRepositoryMockAddHistoryParams{ctx, e}
	mmAddHistory.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddHistory.expectations {
		if minimock.Equal(e.params, mmAddHistory.defaultExpectation.params) {
			mmAddHistory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddHistory.defaultExpectation.params)
		}
	}

	return mmAddHistory
}

// ExpectCtxParam1 sets up expected param ctx for HistoryAndReturnsRepository.AddHistory
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) ExpectCtxParam1(ctx context.Context) *mHistoryAndReturnsRepositoryMockAddHistory {
	if mmAddHistory.mock.funcAddHistory != nil {
		mmAddHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddHistory mock is already set by Set")
	}

	if mmAddHistory.defaultExpectation == nil {
		mmAddHistory.defaultExpectation = &HistoryAndReturnsRepositoryMockAddHistoryExpectation{}
	}

	if mmAddHistory.defaultExpectation.params != nil {
		mmAddHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddHistory mock is already set by Expect")
	}

	if mmAddHistory.defaultExpectation.paramPtrs == nil {
		mmAddHistory.defaultExpectation.paramPtrs = &HistoryAndReturnsRepositoryMockAddHistoryParamPtrs{}
	}
	mmAddHistory.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddHistory.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddHistory
}

// ExpectEParam2 sets up expected param e for HistoryAndReturnsRepository.AddHistory
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) ExpectEParam2(e *models.HistoryEvent) *mHistoryAndReturnsRepositoryMockAddHistory {
	if mmAddHistory.mock.funcAddHistory != nil {
		mmAddHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddHistory mock is already set by Set")
	}

	if mmAddHistory.defaultExpectation == nil {
		mmAddHistory.defaultExpectation = &HistoryAndReturnsRepositoryMockAddHistoryExpectation{}
	}

	if mmAddHistory.defaultExpectation.params != nil {
		mmAddHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddHistory mock is already set by Expect")
	}

	if mmAddHistory.defaultExpectation.paramPtrs == nil {
		mmAddHistory.defaultExpectation.paramPtrs = &HistoryAndReturnsRepositoryMockAddHistoryParamPtrs{}
	}
	mmAddHistory.defaultExpectation.paramPtrs.e = &e
	mmAddHistory.defaultExpectation.expectationOrigins.originE = minimock.CallerInfo(1)

	return mmAddHistory
}

// Inspect accepts an inspector function that has same arguments as the HistoryAndReturnsRepository.AddHistory
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) Inspect(f func(ctx context.Context, e *models.HistoryEvent)) *mHistoryAndReturnsRepositoryMockAddHistory {
	if mmAddHistory.mock.inspectFuncAddHistory != nil {
		mmAddHistory.mock.t.Fatalf("Inspect function is already set for HistoryAndReturnsRepositoryMock.AddHistory")
	}

	mmAddHistory.mock.inspectFuncAddHistory = f

	return mmAddHistory
}

// Return sets up results that will be returned by HistoryAndReturnsRepository.AddHistory
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) Return(err error) *HistoryAndReturnsRepositoryMock {
	if mmAddHistory.mock.funcAddHistory != nil {
		mmAddHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddHistory mock is already set by Set")
	}

	if mmAddHistory.defaultExpectation == nil {
		mmAddHistory.defaultExpectation = &HistoryAndReturnsRepositoryMockAddHistoryExpectation{mock: mmAddHistory.mock}
	}
	mmAddHistory.defaultExpectation.results = &HistoryAndReturnsRepositoryMockAddHistoryResults{err}
	mmAddHistory.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddHistory.mock
}

// Set uses given function f to mock the HistoryAndReturnsRepository.AddHistory method
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) Set(f func(ctx context.Context, e *models.HistoryEvent) (err error)) *HistoryAndReturnsRepositoryMock {
	if mmAddHistory.defaultExpectation != nil {
		mmAddHistory.mock.t.Fatalf("Default expectation is already set for the HistoryAndReturnsRepository.AddHistory method")
	}

	if len(mmAddHistory.expectations) > 0 {
		mmAddHistory.mock.t.Fatalf("Some expectations are already set for the HistoryAndReturnsRepository.AddHistory method")
	}

	mmAddHistory.mock.funcAddHistory = f
	mmAddHistory.mock.funcAddHistoryOrigin = minimock.CallerInfo(1)
	return mmAddHistory.mock
}

// When sets expectation for the HistoryAndReturnsRepository.AddHistory which will trigger the result defined by the following
// Then helper
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) When(ctx context.Context, e *models.HistoryEvent) *HistoryAndReturnsRepositoryMockAddHistoryExpectation {
	if mmAddHistory.mock.funcAddHistory != nil {
		mmAddHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddHistory mock is already set by Set")
	}

	expectation := &HistoryAndReturnsRepositoryMockAddHistoryExpectation{
		mock:               mmAddHistory.mock,
		params:             &HistoryAndReturnsRepositoryMockAddHistoryParams{ctx, e},
		expectationOrigins: HistoryAndReturnsRepositoryMockAddHistoryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddHistory.expectations = append(mmAddHistory.expectations, expectation)
	return expectation
}

// Then sets up HistoryAndReturnsRepository.AddHistory return parameters for the expectation previously defined by the When method
func (e *HistoryAndReturnsRepositoryMockAddHistoryExpectation) Then(err error) *HistoryAndReturnsRepositoryMock {
	e.results = &HistoryAndReturnsRepositoryMockAddHistoryResults{err}
	return e.mock
}

// Times sets number of times HistoryAndReturnsRepository.AddHistory should be invoked
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) Times(n uint64) *mHistoryAndReturnsRepositoryMockAddHistory {
	if n == 0 {
		mmAddHistory.mock.t.Fatalf("Times of HistoryAndReturnsRepositoryMock.AddHistory mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddHistory.expectedInvocations, n)
	mmAddHistory.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddHistory
}

func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) invocationsDone() bool {
	if len(mmAddHistory.expectations) == 0 && mmAddHistory.defaultExpectation == nil && mmAddHistory.mock.funcAddHistory == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddHistory.mock.afterAddHistoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddHistory.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddHistory implements mm_usecase.HistoryAndReturnsRepository
func (mmAddHistory *HistoryAndReturnsRepositoryMock) AddHistory(ctx context.Context, e *models.HistoryEvent) (err error) {
	mm_atomic.AddUint64(&mmAddHistory.beforeAddHistoryCounter, 1)
	defer mm_atomic.AddUint64(&mmAddHistory.afterAddHistoryCounter, 1)

	mmAddHistory.t.Helper()

	if mmAddHistory.inspectFuncAddHistory != nil {
		mmAddHistory.inspectFuncAddHistory(ctx, e)
	}

	mm_params := HistoryAndReturnsRepositoryMockAddHistoryParams{ctx, e}

	// Record call args
	mmAddHistory.AddHistoryMock.mutex.Lock()
	mmAddHistory.AddHistoryMock.callArgs = append(mmAddHistory.AddHistoryMock.callArgs, &mm_params)
	mmAddHistory.AddHistoryMock.mutex.Unlock()

	for _, e := range mmAddHistory.AddHistoryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddHistory.AddHistoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddHistory.AddHistoryMock.defaultExpectation.Counter, 1)
		mm_want := mmAddHistory.AddHistoryMock.defaultExpectation.params
		mm_want_ptrs := mmAddHistory.AddHistoryMock.defaultExpectation.paramPtrs

		mm_got := HistoryAndReturnsRepositoryMockAddHistoryParams{ctx, e}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddHistory.t.Errorf("HistoryAndReturnsRepositoryMock.AddHistory got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddHistory.AddHistoryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.e != nil && !minimock.Equal(*mm_want_ptrs.e, mm_got.e) {
				mmAddHistory.t.Errorf("HistoryAndReturnsRepositoryMock.AddHistory got unexpected parameter e, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddHistory.AddHistoryMock.defaultExpectation.expectationOrigins.originE, *mm_want_ptrs.e, mm_got.e, minimock.Diff(*mm_want_ptrs.e, mm_got.e))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddHistory.t.Errorf("HistoryAndReturnsRepositoryMock.AddHistory got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddHistory.AddHistoryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddHistory.AddHistoryMock.defaultExpectation.results
		if mm_results == nil {
			mmAddHistory.t.Fatal("No results are set for the HistoryAndReturnsRepositoryMock.AddHistory")
		}
		return (*mm_results).err
	}
	if mmAddHistory.funcAddHistory != nil {
		return mmAddHistory.funcAddHistory(ctx, e)
	}
	mmAddHistory.t.Fatalf("Unexpected call to HistoryAndReturnsRepositoryMock.AddHistory. %v %v", ctx, e)
	return
}

// AddHistoryAfterCounter returns a count of finished HistoryAndReturnsRepositoryMock.AddHistory invocations
func (mmAddHistory *HistoryAndReturnsRepositoryMock) AddHistoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddHistory.afterAddHistoryCounter)
}

// AddHistoryBeforeCounter returns a count of HistoryAndReturnsRepositoryMock.AddHistory invocations
func (mmAddHistory *HistoryAndReturnsRepositoryMock) AddHistoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddHistory.beforeAddHistoryCounter)
}

// Calls returns a list of arguments used in each call to HistoryAndReturnsRepositoryMock.AddHistory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) Calls() []*HistoryAndReturnsRepositoryMockAddHistoryParams {
	mmAddHistory.mutex.RLock()

	argCopy := make([]*HistoryAndReturnsRepositoryMockAddHistoryParams, len(mmAddHistory.callArgs))
	copy(argCopy, mmAddHistory.callArgs)

	mmAddHistory.mutex.RUnlock()

	return argCopy
}

// MinimockAddHistoryDone returns true if the count of the AddHistory invocations corresponds
// the number of defined expectations
func (m *HistoryAndReturnsRepositoryMock) MinimockAddHistoryDone() bool {
	if m.AddHistoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddHistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddHistoryMock.invocationsDone()
}

// MinimockAddHistoryInspect logs each unmet expectation
func (m *HistoryAndReturnsRepositoryMock) MinimockAddHistoryInspect() {
	for _, e := range m.AddHistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.AddHistory at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddHistoryCounter := mm_atomic.LoadUint64(&m.afterAddHistoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddHistoryMock.defaultExpectation != nil && afterAddHistoryCounter < 1 {
		if m.AddHistoryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.AddHistory at\n%s", m.AddHistoryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.AddHistory at\n%s with params: %#v", m.AddHistoryMock.defaultExpectation.expectationOrigins.origin, *m.AddHistoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddHistory != nil && afterAddHistoryCounter < 1 {
		m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.AddHistory at\n%s", m.funcAddHistoryOrigin)
	}

	if !m.AddHistoryMock.invocationsDone() && afterAddHistoryCounter > 0 {
		m.t.Errorf("Expected %d calls to HistoryAndReturnsRepositoryMock.AddHistory at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddHistoryMock.expectedInvocations), m.AddHistoryMock.expectedInvocationsOrigin, afterAddHistoryCounter)
	}
}

type mHistoryAndReturnsRepositoryMockAddReturn struct {
	optional           bool
	mock               *HistoryAndReturnsRepositoryMock
	defaultExpectation *HistoryAndReturnsRepositoryMockAddReturnExpectation
	expectations       []*HistoryAndReturnsRepositoryMockAddReturnExpectation

	callArgs []*HistoryAndReturnsRepositoryMockAddReturnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// HistoryAndReturnsRepositoryMockAddReturnExpectation specifies expectation struct of the HistoryAndReturnsRepository.AddReturn
type HistoryAndReturnsRepositoryMockAddReturnExpectation struct {
	mock               *HistoryAndReturnsRepositoryMock
	params             *HistoryAndReturnsRepositoryMockAddReturnParams
	paramPtrs          *HistoryAndReturnsRepositoryMockAddReturnParamPtrs
	expectationOrigins HistoryAndReturnsRepositoryMockAddReturnExpectationOrigins
	results            *HistoryAndReturnsRepositoryMockAddReturnResults
	returnOrigin       string
	Counter            uint64
}

// HistoryAndReturnsRepositoryMockAddReturnParams contains parameters of the HistoryAndReturnsRepository.AddReturn
type HistoryAndReturnsRepositoryMockAddReturnParams struct {
	ctx context.Context
	rec *models.ReturnRecord
}

// HistoryAndReturnsRepositoryMockAddReturnParamPtrs contains pointers to parameters of the HistoryAndReturnsRepository.AddReturn
type HistoryAndReturnsRepositoryMockAddReturnParamPtrs struct {
	ctx *context.Context
	rec **models.ReturnRecord
}

// HistoryAndReturnsRepositoryMockAddReturnResults contains results of the HistoryAndReturnsRepository.AddReturn
type HistoryAndReturnsRepositoryMockAddReturnResults struct {
	err error
}

// HistoryAndReturnsRepositoryMockAddReturnOrigins contains origins of expectations of the HistoryAndReturnsRepository.AddReturn
type HistoryAndReturnsRepositoryMockAddReturnExpectationOrigins struct {
	origin    string
	originCtx string
	originRec string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) Optional() *mHistoryAndReturnsRepositoryMockAddReturn {
	mmAddReturn.optional = true
	return mmAddReturn
}

// Expect sets up expected params for HistoryAndReturnsRepository.AddReturn
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) Expect(ctx context.Context, rec *models.ReturnRecord) *mHistoryAndReturnsRepositoryMockAddReturn {
	if mmAddReturn.mock.funcAddReturn != nil {
		mmAddReturn.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddReturn mock is already set by Set")
	}

	if mmAddReturn.defaultExpectation == nil {
		mmAddReturn.defaultExpectation = &HistoryAndReturnsRepositoryMockAddReturnExpectation{}
	}

	if mmAddReturn.defaultExpectation.paramPtrs != nil {
		mmAddReturn.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddReturn mock is already set by ExpectParams functions")
	}

	mmAddReturn.defaultExpectation.params = &HistoryAndReturnsRepositoryMockAddReturnParams{ctx, rec}
	mmAddReturn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddReturn.expectations {
		if minimock.Equal(e.params, mmAddReturn.defaultExpectation.params) {
			mmAddReturn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddReturn.defaultExpectation.params)
		}
	}

	return mmAddReturn
}

// ExpectCtxParam1 sets up expected param ctx for HistoryAndReturnsRepository.AddReturn
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) ExpectCtxParam1(ctx context.Context) *mHistoryAndReturnsRepositoryMockAddReturn {
	if mmAddReturn.mock.funcAddReturn != nil {
		mmAddReturn.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddReturn mock is already set by Set")
	}

	if mmAddReturn.defaultExpectation == nil {
		mmAddReturn.defaultExpectation = &HistoryAndReturnsRepositoryMockAddReturnExpectation{}
	}

	if mmAddReturn.defaultExpectation.params != nil {
		mmAddReturn.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddReturn mock is already set by Expect")
	}

	if mmAddReturn.defaultExpectation.paramPtrs == nil {
		mmAddReturn.defaultExpectation.paramPtrs = &HistoryAndReturnsRepositoryMockAddReturnParamPtrs{}
	}
	mmAddReturn.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddReturn.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddReturn
}

// ExpectRecParam2 sets up expected param rec for HistoryAndReturnsRepository.AddReturn
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) ExpectRecParam2(rec *models.ReturnRecord) *mHistoryAndReturnsRepositoryMockAddReturn {
	if mmAddReturn.mock.funcAddReturn != nil {
		mmAddReturn.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddReturn mock is already set by Set")
	}

	if mmAddReturn.defaultExpectation == nil {
		mmAddReturn.defaultExpectation = &HistoryAndReturnsRepositoryMockAddReturnExpectation{}
	}

	if mmAddReturn.defaultExpectation.params != nil {
		mmAddReturn.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddReturn mock is already set by Expect")
	}

	if mmAddReturn.defaultExpectation.paramPtrs == nil {
		mmAddReturn.defaultExpectation.paramPtrs = &HistoryAndReturnsRepositoryMockAddReturnParamPtrs{}
	}
	mmAddReturn.defaultExpectation.paramPtrs.rec = &rec
	mmAddReturn.defaultExpectation.expectationOrigins.originRec = minimock.CallerInfo(1)

	return mmAddReturn
}

// Inspect accepts an inspector function that has same arguments as the HistoryAndReturnsRepository.AddReturn
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) Inspect(f func(ctx context.Context, rec *models.ReturnRecord)) *mHistoryAndReturnsRepositoryMockAddReturn {
	if mmAddReturn.mock.inspectFuncAddReturn != nil {
		mmAddReturn.mock.t.Fatalf("Inspect function is already set for HistoryAndReturnsRepositoryMock.AddReturn")
	}

	mmAddReturn.mock.inspectFuncAddReturn = f

	return mmAddReturn
}

// Return sets up results that will be returned by HistoryAndReturnsRepository.AddReturn
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) Return(err error) *HistoryAndReturnsRepositoryMock {
	if mmAddReturn.mock.funcAddReturn != nil {
		mmAddReturn.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddReturn mock is already set by Set")
	}

	if mmAddReturn.defaultExpectation == nil {
		mmAddReturn.defaultExpectation = &HistoryAndReturnsRepositoryMockAddReturnExpectation{mock: mmAddReturn.mock}
	}
	mmAddReturn.defaultExpectation.results = &HistoryAndReturnsRepositoryMockAddReturnResults{err}
	mmAddReturn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddReturn.mock
}

// Set uses given function f to mock the HistoryAndReturnsRepository.AddReturn method
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) Set(f func(ctx context.Context, rec *models.ReturnRecord) (err error)) *HistoryAndReturnsRepositoryMock {
	if mmAddReturn.defaultExpectation != nil {
		mmAddReturn.mock.t.Fatalf("Default expectation is already set for the HistoryAndReturnsRepository.AddReturn method")
	}

	if len(mmAddReturn.expectations) > 0 {
		mmAddReturn.mock.t.Fatalf("Some expectations are already set for the HistoryAndReturnsRepository.AddReturn method")
	}

	mmAddReturn.mock.funcAddReturn = f
	mmAddReturn.mock.funcAddReturnOrigin = minimock.CallerInfo(1)
	return mmAddReturn.mock
}

// When sets expectation for the HistoryAndReturnsRepository.AddReturn which will trigger the result defined by the following
// Then helper
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) When(ctx context.Context, rec *models.ReturnRecord) *HistoryAndReturnsRepositoryMockAddReturnExpectation {
	if mmAddReturn.mock.funcAddReturn != nil {
		mmAddReturn.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddReturn mock is already set by Set")
	}

	expectation := &HistoryAndReturnsRepositoryMockAddReturnExpectation{
		mock:               mmAddReturn.mock,
		params:             &HistoryAndReturnsRepositoryMockAddReturnParams{ctx, rec},
		expectationOrigins: HistoryAndReturnsRepositoryMockAddReturnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddReturn.expectations = append(mmAddReturn.expectations, expectation)
	return expectation
}

// Then sets up HistoryAndReturnsRepository.AddReturn return parameters for the expectation previously defined by the When method
func (e *HistoryAndReturnsRepositoryMockAddReturnExpectation) Then(err error) *HistoryAndReturnsRepositoryMock {
	e.results = &HistoryAndReturnsRepositoryMockAddReturnResults{err}
	return e.mock
}

// Times sets number of times HistoryAndReturnsRepository.AddReturn should be invoked
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) Times(n uint64) *mHistoryAndReturnsRepositoryMockAddReturn {
	if n == 0 {
		mmAddReturn.mock.t.Fatalf("Times of HistoryAndReturnsRepositoryMock.AddReturn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddReturn.expectedInvocations, n)
	mmAddReturn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddReturn
}

func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) invocationsDone() bool {
	if len(mmAddReturn.expectations) == 0 && mmAddReturn.defaultExpectation == nil && mmAddReturn.mock.funcAddReturn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddReturn.mock.afterAddReturnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddReturn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddReturn implements mm_usecase.HistoryAndReturnsRepository
func (mmAddReturn *HistoryAndReturnsRepositoryMock) AddReturn(ctx context.Context, rec *models.ReturnRecord) (err error) {
	mm_atomic.AddUint64(&mmAddReturn.beforeAddReturnCounter, 1)
	defer mm_atomic.AddUint64(&mmAddReturn.afterAddReturnCounter, 1)

	mmAddReturn.t.Helper()

	if mmAddReturn.inspectFuncAddReturn != nil {
		mmAddReturn.inspectFuncAddReturn(ctx, rec)
	}

	mm_params := HistoryAndReturnsRepositoryMockAddReturnParams{ctx, rec}

	// Record call args
	mmAddReturn.AddReturnMock.mutex.Lock()
	mmAddReturn.AddReturnMock.callArgs = append(mmAddReturn.AddReturnMock.callArgs, &mm_params)
	mmAddReturn.AddReturnMock.mutex.Unlock()

	for _, e := range mmAddReturn.AddReturnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddReturn.AddReturnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddReturn.AddReturnMock.defaultExpectation.Counter, 1)
		mm_want := mmAddReturn.AddReturnMock.defaultExpectation.params
		mm_want_ptrs := mmAddReturn.AddReturnMock.defaultExpectation.paramPtrs

		mm_got := HistoryAndReturnsRepositoryMockAddReturnParams{ctx, rec}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddReturn.t.Errorf("HistoryAndReturnsRepositoryMock.AddReturn got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddReturn.AddReturnMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.rec != nil && !minimock.Equal(*mm_want_ptrs.rec, mm_got.rec) {
				mmAddReturn.t.Errorf("HistoryAndReturnsRepositoryMock.AddReturn got unexpected parameter rec, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddReturn.AddReturnMock.defaultExpectation.expectationOrigins.originRec, *mm_want_ptrs.rec, mm_got.rec, minimock.Diff(*mm_want_ptrs.rec, mm_got.rec))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddReturn.t.Errorf("HistoryAndReturnsRepositoryMock.AddReturn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddReturn.AddReturnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddReturn.AddReturnMock.defaultExpectation.results
		if mm_results == nil {
			mmAddReturn.t.Fatal("No results are set for the HistoryAndReturnsRepositoryMock.AddReturn")
		}
		return (*mm_results).err
	}
	if mmAddReturn.funcAddReturn != nil {
		return mmAddReturn.funcAddReturn(ctx, rec)
	}
	mmAddReturn.t.Fatalf("Unexpected call to HistoryAndReturnsRepositoryMock.AddReturn. %v %v", ctx, rec)
	return
}

// AddReturnAfterCounter returns a count of finished HistoryAndReturnsRepositoryMock.AddReturn invocations
func (mmAddReturn *HistoryAndReturnsRepositoryMock) AddReturnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddReturn.afterAddReturnCounter)
}

// AddReturnBeforeCounter returns a count of HistoryAndReturnsRepositoryMock.AddReturn invocations
func (mmAddReturn *HistoryAndReturnsRepositoryMock) AddReturnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddReturn.beforeAddReturnCounter)
}

// Calls returns a list of arguments used in each call to HistoryAndReturnsRepositoryMock.AddReturn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) Calls() []*HistoryAndReturnsRepositoryMockAddReturnParams {
	mmAddReturn.mutex.RLock()

	argCopy := make([]*HistoryAndReturnsRepositoryMockAddReturnParams, len(mmAddReturn.callArgs))
	copy(argCopy, mmAddReturn.callArgs)

	mmAddReturn.mutex.RUnlock()

	return argCopy
}

// MinimockAddReturnDone returns true if the count of the AddReturn invocations corresponds
// the number of defined expectations
func (m *HistoryAndReturnsRepositoryMock) MinimockAddReturnDone() bool {
	if m.AddReturnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddReturnMock.invocationsDone()
}

// MinimockAddReturnInspect logs each unmet expectation
func (m *HistoryAndReturnsRepositoryMock) MinimockAddReturnInspect() {
	for _, e := range m.AddReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.AddReturn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddReturnCounter := mm_atomic.LoadUint64(&m.afterAddReturnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddReturnMock.defaultExpectation != nil && afterAddReturnCounter < 1 {
		if m.AddReturnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.AddReturn at\n%s", m.AddReturnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.AddReturn at\n%s with params: %#v", m.AddReturnMock.defaultExpectation.expectationOrigins.origin, *m.AddReturnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddReturn != nil && afterAddReturnCounter < 1 {
		m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.AddReturn at\n%s", m.funcAddReturnOrigin)
	}

	if !m.AddReturnMock.invocationsDone() && afterAddReturnCounter > 0 {
		m.t.Errorf("Expected %d calls to HistoryAndReturnsRepositoryMock.AddReturn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddReturnMock.expectedInvocations), m.AddReturnMock.expectedInvocationsOrigin, afterAddReturnCounter)
	}
}

type mHistoryAndReturnsRepositoryMockHistory struct {
	optional           bool
	mock               *HistoryAndReturnsRepositoryMock
	defaultExpectation *HistoryAndReturnsRepositoryMockHistoryExpectation
	expectations       []*HistoryAndReturnsRepositoryMockHistoryExpectation

	callArgs []*HistoryAndReturnsRepositoryMockHistoryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// HistoryAndReturnsRepositoryMockHistoryExpectation specifies expectation struct of the HistoryAndReturnsRepository.History
type HistoryAndReturnsRepositoryMockHistoryExpectation struct {
	mock               *HistoryAndReturnsRepositoryMock
	params             *HistoryAndReturnsRepositoryMockHistoryParams
	paramPtrs          *HistoryAndReturnsRepositoryMockHistoryParamPtrs
	expectationOrigins HistoryAndReturnsRepositoryMockHistoryExpectationOrigins
	results            *HistoryAndReturnsRepositoryMockHistoryResults
	returnOrigin       string
	Counter            uint64
}

// HistoryAndReturnsRepositoryMockHistoryParams contains parameters of the HistoryAndReturnsRepository.History
type HistoryAndReturnsRepositoryMockHistoryParams struct {
	ctx context.Context
	pg  vo.Pagination
}

// HistoryAndReturnsRepositoryMockHistoryParamPtrs contains pointers to parameters of the HistoryAndReturnsRepository.History
type HistoryAndReturnsRepositoryMockHistoryParamPtrs struct {
	ctx *context.Context
	pg  *vo.Pagination
}

// HistoryAndReturnsRepositoryMockHistoryResults contains results of the HistoryAndReturnsRepository.History
type HistoryAndReturnsRepositoryMockHistoryResults struct {
	hpa1 []*models.HistoryEvent
	err  error
}

// HistoryAndReturnsRepositoryMockHistoryOrigins contains origins of expectations of the HistoryAndReturnsRepository.History
type HistoryAndReturnsRepositoryMockHistoryExpectationOrigins struct {
	origin    string
	originCtx string
	originPg  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) Optional() *mHistoryAndReturnsRepositoryMockHistory {
	mmHistory.optional = true
	return mmHistory
}

// Expect sets up expected params for HistoryAndReturnsRepository.History
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) Expect(ctx context.Context, pg vo.Pagination) *mHistoryAndReturnsRepositoryMockHistory {
	if mmHistory.mock.funcHistory != nil {
		mmHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.History mock is already set by Set")
	}

	if mmHistory.defaultExpectation == nil {
		mmHistory.defaultExpectation = &HistoryAndReturnsRepositoryMockHistoryExpectation{}
	}

	if mmHistory.defaultExpectation.paramPtrs != nil {
		mmHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.History mock is already set by ExpectParams functions")
	}

	mmHistory.defaultExpectation.params = &HistoryAndReturnsRepositoryMockHistoryParams{ctx, pg}
	mmHistory.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHistory.expectations {
		if minimock.Equal(e.params, mmHistory.defaultExpectation.params) {
			mmHistory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHistory.defaultExpectation.params)
		}
	}

	return mmHistory
}

// ExpectCtxParam1 sets up expected param ctx for HistoryAndReturnsRepository.History
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) ExpectCtxParam1(ctx context.Context) *mHistoryAndReturnsRepositoryMockHistory {
	if mmHistory.mock.funcHistory != nil {
		mmHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.History mock is already set by Set")
	}

	if mmHistory.defaultExpectation == nil {
		mmHistory.defaultExpectation = &HistoryAndReturnsRepositoryMockHistoryExpectation{}
	}

	if mmHistory.defaultExpectation.params != nil {
		mmHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.History mock is already set by Expect")
	}

	if mmHistory.defaultExpectation.paramPtrs == nil {
		mmHistory.defaultExpectation.paramPtrs = &HistoryAndReturnsRepositoryMockHistoryParamPtrs{}
	}
	mmHistory.defaultExpectation.paramPtrs.ctx = &ctx
	mmHistory.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHistory
}

// ExpectPgParam2 sets up expected param pg for HistoryAndReturnsRepository.History
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) ExpectPgParam2(pg vo.Pagination) *mHistoryAndReturnsRepositoryMockHistory {
	if mmHistory.mock.funcHistory != nil {
		mmHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.History mock is already set by Set")
	}

	if mmHistory.defaultExpectation == nil {
		mmHistory.defaultExpectation = &HistoryAndReturnsRepositoryMockHistoryExpectation{}
	}

	if mmHistory.defaultExpectation.params != nil {
		mmHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.History mock is already set by Expect")
	}

	if mmHistory.defaultExpectation.paramPtrs == nil {
		mmHistory.defaultExpectation.paramPtrs = &HistoryAndReturnsRepositoryMockHistoryParamPtrs{}
	}
	mmHistory.defaultExpectation.paramPtrs.pg = &pg
	mmHistory.defaultExpectation.expectationOrigins.originPg = minimock.CallerInfo(1)

	return mmHistory
}

// Inspect accepts an inspector function that has same arguments as the HistoryAndReturnsRepository.History
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) Inspect(f func(ctx context.Context, pg vo.Pagination)) *mHistoryAndReturnsRepositoryMockHistory {
	if mmHistory.mock.inspectFuncHistory != nil {
		mmHistory.mock.t.Fatalf("Inspect function is already set for HistoryAndReturnsRepositoryMock.History")
	}

	mmHistory.mock.inspectFuncHistory = f

	return mmHistory
}

// Return sets up results that will be returned by HistoryAndReturnsRepository.History
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) Return(hpa1 []*models.HistoryEvent, err error) *HistoryAndReturnsRepositoryMock {
	if mmHistory.mock.funcHistory != nil {
		mmHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.History mock is already set by Set")
	}

	if mmHistory.defaultExpectation == nil {
		mmHistory.defaultExpectation = &HistoryAndReturnsRepositoryMockHistoryExpectation{mock: mmHistory.mock}
	}
	mmHistory.defaultExpectation.results = &HistoryAndReturnsRepositoryMockHistoryResults{hpa1, err}
	mmHistory.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHistory.mock
}

// Set uses given function f to mock the HistoryAndReturnsRepository.History method
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) Set(f func(ctx context.Context, pg vo.Pagination) (hpa1 []*models.HistoryEvent, err error)) *HistoryAndReturnsRepositoryMock {
	if mmHistory.defaultExpectation != nil {
		mmHistory.mock.t.Fatalf("Default expectation is already set for the HistoryAndReturnsRepository.History method")
	}

	if len(mmHistory.expectations) > 0 {
		mmHistory.mock.t.Fatalf("Some expectations are already set for the HistoryAndReturnsRepository.History method")
	}

	mmHistory.mock.funcHistory = f
	mmHistory.mock.funcHistoryOrigin = minimock.CallerInfo(1)
	return mmHistory.mock
}

// When sets expectation for the HistoryAndReturnsRepository.History which will trigger the result defined by the following
// Then helper
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) When(ctx context.Context, pg vo.Pagination) *HistoryAndReturnsRepositoryMockHistoryExpectation {
	if mmHistory.mock.funcHistory != nil {
		mmHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.History mock is already set by Set")
	}

	expectation := &HistoryAndReturnsRepositoryMockHistoryExpectation{
		mock:               mmHistory.mock,
		params:             &HistoryAndReturnsRepositoryMockHistoryParams{ctx, pg},
		expectationOrigins: HistoryAndReturnsRepositoryMockHistoryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHistory.expectations = append(mmHistory.expectations, expectation)
	return expectation
}

// Then sets up HistoryAndReturnsRepository.History return parameters for the expectation previously defined by the When method
func (e *HistoryAndReturnsRepositoryMockHistoryExpectation) Then(hpa1 []*models.HistoryEvent, err error) *HistoryAndReturnsRepositoryMock {
	e.results = &HistoryAndReturnsRepositoryMockHistoryResults{hpa1, err}
	return e.mock
}

// Times sets number of times HistoryAndReturnsRepository.History should be invoked
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) Times(n uint64) *mHistoryAndReturnsRepositoryMockHistory {
	if n == 0 {
		mmHistory.mock.t.Fatalf("Times of HistoryAndReturnsRepositoryMock.History mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHistory.expectedInvocations, n)
	mmHistory.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHistory
}

func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) invocationsDone() bool {
	if len(mmHistory.expectations) == 0 && mmHistory.defaultExpectation == nil && mmHistory.mock.funcHistory == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHistory.mock.afterHistoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHistory.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// History implements mm_usecase.HistoryAndReturnsRepository
func (mmHistory *HistoryAndReturnsRepositoryMock) History(ctx context.Context, pg vo.Pagination) (hpa1 []*models.HistoryEvent, err error) {
	mm_atomic.AddUint64(&mmHistory.beforeHistoryCounter, 1)
	defer mm_atomic.AddUint64(&mmHistory.afterHistoryCounter, 1)

	mmHistory.t.Helper()

	if mmHistory.inspectFuncHistory != nil {
		mmHistory.inspectFuncHistory(ctx, pg)
	}

	mm_params := HistoryAndReturnsRepositoryMockHistoryParams{ctx, pg}

	// Record call args
	mmHistory.HistoryMock.mutex.Lock()
	mmHistory.HistoryMock.callArgs = append(mmHistory.HistoryMock.callArgs, &mm_params)
	mmHistory.HistoryMock.mutex.Unlock()

	for _, e := range mmHistory.HistoryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hpa1, e.results.err
		}
	}

	if mmHistory.HistoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHistory.HistoryMock.defaultExpectation.Counter, 1)
		mm_want := mmHistory.HistoryMock.defaultExpectation.params
		mm_want_ptrs := mmHistory.HistoryMock.defaultExpectation.paramPtrs

		mm_got := HistoryAndReturnsRepositoryMockHistoryParams{ctx, pg}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHistory.t.Errorf("HistoryAndReturnsRepositoryMock.History got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistory.HistoryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pg != nil && !minimock.Equal(*mm_want_ptrs.pg, mm_got.pg) {
				mmHistory.t.Errorf("HistoryAndReturnsRepositoryMock.History got unexpected parameter pg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistory.HistoryMock.defaultExpectation.expectationOrigins.originPg, *mm_want_ptrs.pg, mm_got.pg, minimock.Diff(*mm_want_ptrs.pg, mm_got.pg))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHistory.t.Errorf("HistoryAndReturnsRepositoryMock.History got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHistory.HistoryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHistory.HistoryMock.defaultExpectation.results
		if mm_results == nil {
			mmHistory.t.Fatal("No results are set for the HistoryAndReturnsRepositoryMock.History")
		}
		return (*mm_results).hpa1, (*mm_results).err
	}
	if mmHistory.funcHistory != nil {
		return mmHistory.funcHistory(ctx, pg)
	}
	mmHistory.t.Fatalf("Unexpected call to HistoryAndReturnsRepositoryMock.History. %v %v", ctx, pg)
	return
}

// HistoryAfterCounter returns a count of finished HistoryAndReturnsRepositoryMock.History invocations
func (mmHistory *HistoryAndReturnsRepositoryMock) HistoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistory.afterHistoryCounter)
}

// HistoryBeforeCounter returns a count of HistoryAndReturnsRepositoryMock.History invocations
func (mmHistory *HistoryAndReturnsRepositoryMock) HistoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistory.beforeHistoryCounter)
}

// Calls returns a list of arguments used in each call to HistoryAndReturnsRepositoryMock.History.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) Calls() []*HistoryAndReturnsRepositoryMockHistoryParams {
	mmHistory.mutex.RLock()

	argCopy := make([]*HistoryAndReturnsRepositoryMockHistoryParams, len(mmHistory.callArgs))
	copy(argCopy, mmHistory.callArgs)

	mmHistory.mutex.RUnlock()

	return argCopy
}

// MinimockHistoryDone returns true if the count of the History invocations corresponds
// the number of defined expectations
func (m *HistoryAndReturnsRepositoryMock) MinimockHistoryDone() bool {
	if m.HistoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HistoryMock.invocationsDone()
}

// MinimockHistoryInspect logs each unmet expectation
func (m *HistoryAndReturnsRepositoryMock) MinimockHistoryInspect() {
	for _, e := range m.HistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.History at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHistoryCounter := mm_atomic.LoadUint64(&m.afterHistoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HistoryMock.defaultExpectation != nil && afterHistoryCounter < 1 {
		if m.HistoryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.History at\n%s", m.HistoryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.History at\n%s with params: %#v", m.HistoryMock.defaultExpectation.expectationOrigins.origin, *m.HistoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHistory != nil && afterHistoryCounter < 1 {
		m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.History at\n%s", m.funcHistoryOrigin)
	}

	if !m.HistoryMock.invocationsDone() && afterHistoryCounter > 0 {
		m.t.Errorf("Expected %d calls to HistoryAndReturnsRepositoryMock.History at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HistoryMock.expectedInvocations), m.HistoryMock.expectedInvocationsOrigin, afterHistoryCounter)
	}
}

type mHistoryAndReturnsRepositoryMockListReturns struct {
	optional           bool
	mock               *HistoryAndReturnsRepositoryMock
	defaultExpectation *HistoryAndReturnsRepositoryMockListReturnsExpectation
	expectations       []*HistoryAndReturnsRepositoryMockListReturnsExpectation

	callArgs []*HistoryAndReturnsRepositoryMockListReturnsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// HistoryAndReturnsRepositoryMockListReturnsExpectation specifies expectation struct of the HistoryAndReturnsRepository.ListReturns
type HistoryAndReturnsRepositoryMockListReturnsExpectation struct {
	mock               *HistoryAndReturnsRepositoryMock
	params             *HistoryAndReturnsRepositoryMockListReturnsParams
	paramPtrs          *HistoryAndReturnsRepositoryMockListReturnsParamPtrs
	expectationOrigins HistoryAndReturnsRepositoryMockListReturnsExpectationOrigins
	results            *HistoryAndReturnsRepositoryMockListReturnsResults
	returnOrigin       string
	Counter            uint64
}

// HistoryAndReturnsRepositoryMockListReturnsParams contains parameters of the HistoryAndReturnsRepository.ListReturns
type HistoryAndReturnsRepositoryMockListReturnsParams struct {
	ctx context.Context
	pg  vo.Pagination
}

// HistoryAndReturnsRepositoryMockListReturnsParamPtrs contains pointers to parameters of the HistoryAndReturnsRepository.ListReturns
type HistoryAndReturnsRepositoryMockListReturnsParamPtrs struct {
	ctx *context.Context
	pg  *vo.Pagination
}

// HistoryAndReturnsRepositoryMockListReturnsResults contains results of the HistoryAndReturnsRepository.ListReturns
type HistoryAndReturnsRepositoryMockListReturnsResults struct {
	rpa1 []*models.ReturnRecord
	err  error
}

// HistoryAndReturnsRepositoryMockListReturnsOrigins contains origins of expectations of the HistoryAndReturnsRepository.ListReturns
type HistoryAndReturnsRepositoryMockListReturnsExpectationOrigins struct {
	origin    string
	originCtx string
	originPg  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) Optional() *mHistoryAndReturnsRepositoryMockListReturns {
	mmListReturns.optional = true
	return mmListReturns
}

// Expect sets up expected params for HistoryAndReturnsRepository.ListReturns
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) Expect(ctx context.Context, pg vo.Pagination) *mHistoryAndReturnsRepositoryMockListReturns {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &HistoryAndReturnsRepositoryMockListReturnsExpectation{}
	}

	if mmListReturns.defaultExpectation.paramPtrs != nil {
		mmListReturns.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturns mock is already set by ExpectParams functions")
	}

	mmListReturns.defaultExpectation.params = &HistoryAndReturnsRepositoryMockListReturnsParams{ctx, pg}
	mmListReturns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListReturns.expectations {
		if minimock.Equal(e.params, mmListReturns.defaultExpectation.params) {
			mmListReturns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListReturns.defaultExpectation.params)
		}
	}

	return mmListReturns
}

// ExpectCtxParam1 sets up expected param ctx for HistoryAndReturnsRepository.ListReturns
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) ExpectCtxParam1(ctx context.Context) *mHistoryAndReturnsRepositoryMockListReturns {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &HistoryAndReturnsRepositoryMockListReturnsExpectation{}
	}

	if mmListReturns.defaultExpectation.params != nil {
		mmListReturns.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturns mock is already set by Expect")
	}

	if mmListReturns.defaultExpectation.paramPtrs == nil {
		mmListReturns.defaultExpectation.paramPtrs = &HistoryAndReturnsRepositoryMockListReturnsParamPtrs{}
	}
	mmListReturns.defaultExpectation.paramPtrs.ctx = &ctx
	mmListReturns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListReturns
}

// ExpectPgParam2 sets up expected param pg for HistoryAndReturnsRepository.ListReturns
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) ExpectPgParam2(pg vo.Pagination) *mHistoryAndReturnsRepositoryMockListReturns {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &HistoryAndReturnsRepositoryMockListReturnsExpectation{}
	}

	if mmListReturns.defaultExpectation.params != nil {
		mmListReturns.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturns mock is already set by Expect")
	}

	if mmListReturns.defaultExpectation.paramPtrs == nil {
		mmListReturns.defaultExpectation.paramPtrs = &HistoryAndReturnsRepositoryMockListReturnsParamPtrs{}
	}
	mmListReturns.defaultExpectation.paramPtrs.pg = &pg
	mmListReturns.defaultExpectation.expectationOrigins.originPg = minimock.CallerInfo(1)

	return mmListReturns
}

// Inspect accepts an inspector function that has same arguments as the HistoryAndReturnsRepository.ListReturns
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) Inspect(f func(ctx context.Context, pg vo.Pagination)) *mHistoryAndReturnsRepositoryMockListReturns {
	if mmListReturns.mock.inspectFuncListReturns != nil {
		mmListReturns.mock.t.Fatalf("Inspect function is already set for HistoryAndReturnsRepositoryMock.ListReturns")
	}

	mmListReturns.mock.inspectFuncListReturns = f

	return mmListReturns
}

// Return sets up results that will be returned by HistoryAndReturnsRepository.ListReturns
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) Return(rpa1 []*models.ReturnRecord, err error) *HistoryAndReturnsRepositoryMock {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &HistoryAndReturnsRepositoryMockListReturnsExpectation{mock: mmListReturns.mock}
	}
	mmListReturns.defaultExpectation.results = &HistoryAndReturnsRepositoryMockListReturnsResults{rpa1, err}
	mmListReturns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListReturns.mock
}

// Set uses given function f to mock the HistoryAndReturnsRepository.ListReturns method
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) Set(f func(ctx context.Context, pg vo.Pagination) (rpa1 []*models.ReturnRecord, err error)) *HistoryAndReturnsRepositoryMock {
	if mmListReturns.defaultExpectation != nil {
		mmListReturns.mock.t.Fatalf("Default expectation is already set for the HistoryAndReturnsRepository.ListReturns method")
	}

	if len(mmListReturns.expectations) > 0 {
		mmListReturns.mock.t.Fatalf("Some expectations are already set for the HistoryAndReturnsRepository.ListReturns method")
	}

	mmListReturns.mock.funcListReturns = f
	mmListReturns.mock.funcListReturnsOrigin = minimock.CallerInfo(1)
	return mmListReturns.mock
}

// When sets expectation for the HistoryAndReturnsRepository.ListReturns which will trigger the result defined by the following
// Then helper
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) When(ctx context.Context, pg vo.Pagination) *HistoryAndReturnsRepositoryMockListReturnsExpectation {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturns mock is already set by Set")
	}

	expectation := &HistoryAndReturnsRepositoryMockListReturnsExpectation{
		mock:               mmListReturns.mock,
		params:             &HistoryAndReturnsRepositoryMockListReturnsParams{ctx, pg},
		expectationOrigins: HistoryAndReturnsRepositoryMockListReturnsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListReturns.expectations = append(mmListReturns.expectations, expectation)
	return expectation
}

// Then sets up HistoryAndReturnsRepository.ListReturns return parameters for the expectation previously defined by the When method
func (e *HistoryAndReturnsRepositoryMockListReturnsExpectation) Then(rpa1 []*models.ReturnRecord, err error) *HistoryAndReturnsRepositoryMock {
	e.results = &HistoryAndReturnsRepositoryMockListReturnsResults{rpa1, err}
	return e.mock
}

// Times sets number of times HistoryAndReturnsRepository.ListReturns should be invoked
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) Times(n uint64) *mHistoryAndReturnsRepositoryMockListReturns {
	if n == 0 {
		mmListReturns.mock.t.Fatalf("Times of HistoryAndReturnsRepositoryMock.ListReturns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListReturns.expectedInvocations, n)
	mmListReturns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListReturns
}

func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) invocationsDone() bool {
	if len(mmListReturns.expectations) == 0 && mmListReturns.defaultExpectation == nil && mmListReturns.mock.funcListReturns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListReturns.mock.afterListReturnsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListReturns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListReturns implements mm_usecase.HistoryAndReturnsRepository
func (mmListReturns *HistoryAndReturnsRepositoryMock) ListReturns(ctx context.Context, pg vo.Pagination) (rpa1 []*models.ReturnRecord, err error) {
	mm_atomic.AddUint64(&mmListReturns.beforeListReturnsCounter, 1)
	defer mm_atomic.AddUint64(&mmListReturns.afterListReturnsCounter, 1)

	mmListReturns.t.Helper()

	if mmListReturns.inspectFuncListReturns != nil {
		mmListReturns.inspectFuncListReturns(ctx, pg)
	}

	mm_params := HistoryAndReturnsRepositoryMockListReturnsParams{ctx, pg}

	// Record call args
	mmListReturns.ListReturnsMock.mutex.Lock()
	mmListReturns.ListReturnsMock.callArgs = append(mmListReturns.ListReturnsMock.callArgs, &mm_params)
	mmListReturns.ListReturnsMock.mutex.Unlock()

	for _, e := range mmListReturns.ListReturnsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rpa1, e.results.err
		}
	}

	if mmListReturns.ListReturnsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListReturns.ListReturnsMock.defaultExpectation.Counter, 1)
		mm_want := mmListReturns.ListReturnsMock.defaultExpectation.params
		mm_want_ptrs := mmListReturns.ListReturnsMock.defaultExpectation.paramPtrs

		mm_got := HistoryAndReturnsRepositoryMockListReturnsParams{ctx, pg}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListReturns.t.Errorf("HistoryAndReturnsRepositoryMock.ListReturns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListReturns.ListReturnsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pg != nil && !minimock.Equal(*mm_want_ptrs.pg, mm_got.pg) {
				mmListReturns.t.Errorf("HistoryAndReturnsRepositoryMock.ListReturns got unexpected parameter pg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListReturns.ListReturnsMock.defaultExpectation.expectationOrigins.originPg, *mm_want_ptrs.pg, mm_got.pg, minimock.Diff(*mm_want_ptrs.pg, mm_got.pg))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListReturns.t.Errorf("HistoryAndReturnsRepositoryMock.ListReturns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListReturns.ListReturnsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListReturns.ListReturnsMock.defaultExpectation.results
		if mm_results == nil {
			mmListReturns.t.Fatal("No results are set for the HistoryAndReturnsRepositoryMock.ListReturns")
		}
		return (*mm_results).rpa1, (*mm_results).err
	}
	if mmListReturns.funcListReturns != nil {
		return mmListReturns.funcListReturns(ctx, pg)
	}
	mmListReturns.t.Fatalf("Unexpected call to HistoryAndReturnsRepositoryMock.ListReturns. %v %v", ctx, pg)
	return
}

// ListReturnsAfterCounter returns a count of finished HistoryAndReturnsRepositoryMock.ListReturns invocations
func (mmListReturns *HistoryAndReturnsRepositoryMock) ListReturnsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReturns.afterListReturnsCounter)
}

// ListReturnsBeforeCounter returns a count of HistoryAndReturnsRepositoryMock.ListReturns invocations
func (mmListReturns *HistoryAndReturnsRepositoryMock) ListReturnsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReturns.beforeListReturnsCounter)
}

// Calls returns a list of arguments used in each call to HistoryAndReturnsRepositoryMock.ListReturns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) Calls() []*HistoryAndReturnsRepositoryMockListReturnsParams {
	mmListReturns.mutex.RLock()

	argCopy := make([]*HistoryAndReturnsRepositoryMockListReturnsParams, len(mmListReturns.callArgs))
	copy(argCopy, mmListReturns.callArgs)

	mmListReturns.mutex.RUnlock()

	return argCopy
}

// MinimockListReturnsDone returns true if the count of the ListReturns invocations corresponds
// the number of defined expectations
func (m *HistoryAndReturnsRepositoryMock) MinimockListReturnsDone() bool {
	if m.ListReturnsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListReturnsMock.invocationsDone()
}

// MinimockListReturnsInspect logs each unmet expectation
func (m *HistoryAndReturnsRepositoryMock) MinimockListReturnsInspect() {
	for _, e := range m.ListReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.ListReturns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListReturnsCounter := mm_atomic.LoadUint64(&m.afterListReturnsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListReturnsMock.defaultExpectation != nil && afterListReturnsCounter < 1 {
		if m.ListReturnsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.ListReturns at\n%s", m.ListReturnsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.ListReturns at\n%s with params: %#v", m.ListReturnsMock.defaultExpectation.expectationOrigins.origin, *m.ListReturnsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListReturns != nil && afterListReturnsCounter < 1 {
		m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.ListReturns at\n%s", m.funcListReturnsOrigin)
	}

	if !m.ListReturnsMock.invocationsDone() && afterListReturnsCounter > 0 {
		m.t.Errorf("Expected %d calls to HistoryAndReturnsRepositoryMock.ListReturns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListReturnsMock.expectedInvocations), m.ListReturnsMock.expectedInvocationsOrigin, afterListReturnsCounter)
	}
}

type mHistoryAndReturnsRepositoryMockListReturnsByUser struct {
	optional           bool
	mock               *HistoryAndReturnsRepositoryMock
	defaultExpectation *HistoryAndReturnsRepositoryMockListReturnsByUserExpectation
	expectations       []*HistoryAndReturnsRepositoryMockListReturnsByUserExpectation

	callArgs []*HistoryAndReturnsRepositoryMockListReturnsByUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// HistoryAndReturnsRepositoryMockListReturnsByUserExpectation specifies expectation struct of the HistoryAndReturnsRepository.ListReturnsByUser
type HistoryAndReturnsRepositoryMockListReturnsByUserExpectation struct {
	mock               *HistoryAndReturnsRepositoryMock
	params             *HistoryAndReturnsRepositoryMockListReturnsByUserParams
	paramPtrs          *HistoryAndReturnsRepositoryMockListReturnsByUserParamPtrs
	expectationOrigins HistoryAndReturnsRepositoryMockListReturnsByUserExpectationOrigins
	results            *HistoryAndReturnsRepositoryMockListReturnsByUserResults
	returnOrigin       string
	Counter            uint64
}

// HistoryAndReturnsRepositoryMockListReturnsByUserParams contains parameters of the HistoryAndReturnsRepository.ListReturnsByUser
type HistoryAndReturnsRepositoryMockListReturnsByUserParams struct {
	ctx    context.Context
	userID string
}

// HistoryAndReturnsRepositoryMockListReturnsByUserParamPtrs contains pointers to parameters of the HistoryAndReturnsRepository.ListReturnsByUser
type HistoryAndReturnsRepositoryMockListReturnsByUserParamPtrs struct {
	ctx    *context.Context
	userID *string
}

// HistoryAndReturnsRepositoryMockListReturnsByUserResults contains results of the HistoryAndReturnsRepository.ListReturnsByUser
type HistoryAndReturnsRepositoryMockListReturnsByUserResults struct {
	rpa1 []*models.ReturnRecord
	err  error
}

// HistoryAndReturnsRepositoryMockListReturnsByUserOrigins contains origins of expectations of the HistoryAndReturnsRepository.ListReturnsByUser
type HistoryAndReturnsRepositoryMockListReturnsByUserExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) Optional() *mHistoryAndReturnsRepositoryMockListReturnsByUser {
	mmListReturnsByUser.optional = true
	return mmListReturnsByUser
}

// Expect sets up expected params for HistoryAndReturnsRepository.ListReturnsByUser
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) Expect(ctx context.Context, userID string) *mHistoryAndReturnsRepositoryMockListReturnsByUser {
	if mmListReturnsByUser.mock.funcListReturnsByUser != nil {
		mmListReturnsByUser.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturnsByUser mock is already set by Set")
	}

	if mmListReturnsByUser.defaultExpectation == nil {
		mmListReturnsByUser.defaultExpectation = &HistoryAndReturnsRepositoryMockListReturnsByUserExpectation{}
	}

	if mmListReturnsByUser.defaultExpectation.paramPtrs != nil {
		mmListReturnsByUser.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturnsByUser mock is already set by ExpectParams functions")
	}

	mmListReturnsByUser.defaultExpectation.params = &HistoryAndReturnsRepositoryMockListReturnsByUserParams{ctx, userID}
	mmListReturnsByUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListReturnsByUser.expectations {
		if minimock.Equal(e.params, mmListReturnsByUser.defaultExpectation.params) {
			mmListReturnsByUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListReturnsByUser.defaultExpectation.params)
		}
	}

	return mmListReturnsByUser
}

// ExpectCtxParam1 sets up expected param ctx for HistoryAndReturnsRepository.ListReturnsByUser
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) ExpectCtxParam1(ctx context.Context) *mHistoryAndReturnsRepositoryMockListReturnsByUser {
	if mmListReturnsByUser.mock.funcListReturnsByUser != nil {
		mmListReturnsByUser.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturnsByUser mock is already set by Set")
	}

	if mmListReturnsByUser.defaultExpectation == nil {
		mmListReturnsByUser.defaultExpectation = &HistoryAndReturnsRepositoryMockListReturnsByUserExpectation{}
	}

	if mmListReturnsByUser.defaultExpectation.params != nil {
		mmListReturnsByUser.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturnsByUser mock is already set by Expect")
	}

	if mmListReturnsByUser.defaultExpectation.paramPtrs == nil {
		mmListReturnsByUser.defaultExpectation.paramPtrs = &HistoryAndReturnsRepositoryMockListReturnsByUserParamPtrs{}
	}
	mmListReturnsByUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmListReturnsByUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListReturnsByUser
}

// ExpectUserIDParam2 sets up expected param userID for HistoryAndReturnsRepository.ListReturnsByUser
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) ExpectUserIDParam2(userID string) *mHistoryAndReturnsRepositoryMockListReturnsByUser {
	if mmListReturnsByUser.mock.funcListReturnsByUser != nil {
		mmListReturnsByUser.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturnsByUser mock is already set by Set")
	}

	if mmListReturnsByUser.defaultExpectation == nil {
		mmListReturnsByUser.defaultExpectation = &HistoryAndReturnsRepositoryMockListReturnsByUserExpectation{}
	}

	if mmListReturnsByUser.defaultExpectation.params != nil {
		mmListReturnsByUser.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturnsByUser mock is already set by Expect")
	}

	if mmListReturnsByUser.defaultExpectation.paramPtrs == nil {
		mmListReturnsByUser.defaultExpectation.paramPtrs = &HistoryAndReturnsRepositoryMockListReturnsByUserParamPtrs{}
	}
	mmListReturnsByUser.defaultExpectation.paramPtrs.userID = &userID
	mmListReturnsByUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmListReturnsByUser
}

// Inspect accepts an inspector function that has same arguments as the HistoryAndReturnsRepository.ListReturnsByUser
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) Inspect(f func(ctx context.Context, userID string)) *mHistoryAndReturnsRepositoryMockListReturnsByUser {
	if mmListReturnsByUser.mock.inspectFuncListReturnsByUser != nil {
		mmListReturnsByUser.mock.t.Fatalf("Inspect function is already set for HistoryAndReturnsRepositoryMock.ListReturnsByUser")
	}

	mmListReturnsByUser.mock.inspectFuncListReturnsByUser = f

	return mmListReturnsByUser
}

// Return sets up results that will be returned by HistoryAndReturnsRepository.ListReturnsByUser
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) Return(rpa1 []*models.ReturnRecord, err error) *HistoryAndReturnsRepositoryMock {
	if mmListReturnsByUser.mock.funcListReturnsByUser != nil {
		mmListReturnsByUser.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturnsByUser mock is already set by Set")
	}

	if mmListReturnsByUser.defaultExpectation == nil {
		mmListReturnsByUser.defaultExpectation = &HistoryAndReturnsRepositoryMockListReturnsByUserExpectation{mock: mmListReturnsByUser.mock}
	}
	mmListReturnsByUser.defaultExpectation.results = &HistoryAndReturnsRepositoryMockListReturnsByUserResults{rpa1, err}
	mmListReturnsByUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListReturnsByUser.mock
}

// Set uses given function f to mock the HistoryAndReturnsRepository.ListReturnsByUser method
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) Set(f func(ctx context.Context, userID string) (rpa1 []*models.ReturnRecord, err error)) *HistoryAndReturnsRepositoryMock {
	if mmListReturnsByUser.defaultExpectation != nil {
		mmListReturnsByUser.mock.t.Fatalf("Default expectation is already set for the HistoryAndReturnsRepository.ListReturnsByUser method")
	}

	if len(mmListReturnsByUser.expectations) > 0 {
		mmListReturnsByUser.mock.t.Fatalf("Some expectations are already set for the HistoryAndReturnsRepository.ListReturnsByUser method")
	}

	mmListReturnsByUser.mock.funcListReturnsByUser = f
	mmListReturnsByUser.mock.funcListReturnsByUserOrigin = minimock.CallerInfo(1)
	return mmListReturnsByUser.mock
}

// When sets expectation for the HistoryAndReturnsRepository.ListReturnsByUser which will trigger the result defined by the following
// Then helper
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) When(ctx context.Context, userID string) *HistoryAndReturnsRepositoryMockListReturnsByUserExpectation {
	if mmListReturnsByUser.mock.funcListReturnsByUser != nil {
		mmListReturnsByUser.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturnsByUser mock is already set by Set")
	}

	expectation := &HistoryAndReturnsRepositoryMockListReturnsByUserExpectation{
		mock:               mmListReturnsByUser.mock,
		params:             &HistoryAndReturnsRepositoryMockListReturnsByUserParams{ctx, userID},
		expectationOrigins: HistoryAndReturnsRepositoryMockListReturnsByUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListReturnsByUser.expectations = append(mmListReturnsByUser.expectations, expectation)
	return expectation
}

// Then sets up HistoryAndReturnsRepository.ListReturnsByUser return parameters for the expectation previously defined by the When method
func (e *HistoryAndReturnsRepositoryMockListReturnsByUserExpectation) Then(rpa1 []*models.ReturnRecord, err error) *HistoryAndReturnsRepositoryMock {
	e.results = &HistoryAndReturnsRepositoryMockListReturnsByUserResults{rpa1, err}
	return e.mock
}

// Times sets number of times HistoryAndReturnsRepository.ListReturnsByUser should be invoked
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) Times(n uint64) *mHistoryAndReturnsRepositoryMockListReturnsByUser {
	if n == 0 {
		mmListReturnsByUser.mock.t.Fatalf("Times of HistoryAndReturnsRepositoryMock.ListReturnsByUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListReturnsByUser.expectedInvocations, n)
	mmListReturnsByUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListReturnsByUser
}

func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) invocationsDone() bool {
	if len(mmListReturnsByUser.expectations) == 0 && mmListReturnsByUser.defaultExpectation == nil && mmListReturnsByUser.mock.funcListReturnsByUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListReturnsByUser.mock.afterListReturnsByUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListReturnsByUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListReturnsByUser implements mm_usecase.HistoryAndReturnsRepository
func (mmListReturnsByUser *HistoryAndReturnsRepositoryMock) ListReturnsByUser(ctx context.Context, userID string) (rpa1 []*models.ReturnRecord, err error) {
	mm_atomic.AddUint64(&mmListReturnsByUser.beforeListReturnsByUserCounter, 1)
	defer mm_atomic.AddUint64(&mmListReturnsByUser.afterListReturnsByUserCounter, 1)

	mmListReturnsByUser.t.Helper()

	if mmListReturnsByUser.inspectFuncListReturnsByUser != nil {
		mmListReturnsByUser.inspectFuncListReturnsByUser(ctx, userID)
	}

	mm_params := HistoryAndReturnsRepositoryMockListReturnsByUserParams{ctx, userID}

	// Record call args
	mmListReturnsByUser.ListReturnsByUserMock.mutex.Lock()
	mmListReturnsByUser.ListReturnsByUserMock.callArgs = append(mmListReturnsByUser.ListReturnsByUserMock.callArgs, &mm_params)
	mmListReturnsByUser.ListReturnsByUserMock.mutex.Unlock()

	for _, e := range mmListReturnsByUser.ListReturnsByUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rpa1, e.results.err
		}
	}

	if mmListReturnsByUser.ListReturnsByUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListReturnsByUser.ListReturnsByUserMock.defaultExpectation.Counter, 1)
		mm_want := mmListReturnsByUser.ListReturnsByUserMock.defaultExpectation.params
		mm_want_ptrs := mmListReturnsByUser.ListReturnsByUserMock.defaultExpectation.paramPtrs

		mm_got := HistoryAndReturnsRepositoryMockListReturnsByUserParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListReturnsByUser.t.Errorf("HistoryAndReturnsRepositoryMock.ListReturnsByUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListReturnsByUser.ListReturnsByUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmListReturnsByUser.t.Errorf("HistoryAndReturnsRepositoryMock.ListReturnsByUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListReturnsByUser.ListReturnsByUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListReturnsByUser.t.Errorf("HistoryAndReturnsRepositoryMock.ListReturnsByUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListReturnsByUser.ListReturnsByUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListReturnsByUser.ListReturnsByUserMock.defaultExpectation.results
		if mm_results == nil {
			mmListReturnsByUser.t.Fatal("No results are set for the HistoryAndReturnsRepositoryMock.ListReturnsByUser")
		}
		return (*mm_results).rpa1, (*mm_results).err
	}
	if mmListReturnsByUser.funcListReturnsByUser != nil {
		return mmListReturnsByUser.funcListReturnsByUser(ctx, userID)
	}
	mmListReturnsByUser.t.Fatalf("Unexpected call to HistoryAndReturnsRepositoryMock.ListReturnsByUser. %v %v", ctx, userID)
	return
}

// ListReturnsByUserAfterCounter returns a count of finished HistoryAndReturnsRepositoryMock.ListReturnsByUser invocations
func (mmListReturnsByUser *HistoryAndReturnsRepositoryMock) ListReturnsByUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReturnsByUser.afterListReturnsByUserCounter)
}

// ListReturnsByUserBeforeCounter returns a count of HistoryAndReturnsRepositoryMock.ListReturnsByUser invocations
func (mmListReturnsByUser *HistoryAndReturnsRepositoryMock) ListReturnsByUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReturnsByUser.beforeListReturnsByUserCounter)
}

// Calls returns a list of arguments used in each call to HistoryAndReturnsRepositoryMock.ListReturnsByUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) Calls() []*HistoryAndReturnsRepositoryMockListReturnsByUserParams {
	mmListReturnsByUser.mutex.RLock()

	argCopy := make([]*HistoryAndReturnsRepositoryMockListReturnsByUserParams, len(mmListReturnsByUser.callArgs))
	copy(argCopy, mmListReturnsByUser.callArgs)

	mmListReturnsByUser.mutex.RUnlock()

	return argCopy
}

// MinimockListReturnsByUserDone returns true if the count of the ListReturnsByUser invocations corresponds
// the number of defined expectations
func (m *HistoryAndReturnsRepositoryMock) MinimockListReturnsByUserDone() bool {
	if m.ListReturnsByUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListReturnsByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListReturnsByUserMock.invocationsDone()
}

// MinimockListReturnsByUserInspect logs each unmet expectation
func (m *HistoryAndReturnsRepositoryMock) MinimockListReturnsByUserInspect() {
	for _, e := range m.ListReturnsByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.ListReturnsByUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListReturnsByUserCounter := mm_atomic.LoadUint64(&m.afterListReturnsByUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListReturnsByUserMock.defaultExpectation != nil && afterListReturnsByUserCounter < 1 {
		if m.ListReturnsByUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.ListReturnsByUser at\n%s", m.ListReturnsByUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.ListReturnsByUser at\n%s with params: %#v", m.ListReturnsByUserMock.defaultExpectation.expectationOrigins.origin, *m.ListReturnsByUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListReturnsByUser != nil && afterListReturnsByUserCounter < 1 {
		m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.ListReturnsByUser at\n%s", m.funcListReturnsByUserOrigin)
	}

	if !m.ListReturnsByUserMock.invocationsDone() && afterListReturnsByUserCounter > 0 {
		m.t.Errorf("Expected %d calls to HistoryAndReturnsRepositoryMock.ListReturnsByUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListReturnsByUserMock.expectedInvocations), m.ListReturnsByUserMock.expectedInvocationsOrigin, afterListReturnsByUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *HistoryAndReturnsRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddHistoryInspect()

			m.MinimockAddReturnInspect()

			m.MinimockHistoryInspect()

			m.MinimockListReturnsInspect()

			m.MinimockListReturnsByUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *HistoryAndReturnsRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *HistoryAndReturnsRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddHistoryDone() &&
		m.MinimockAddReturnDone() &&
		m.MinimockHistoryDone() &&
		m.MinimockListReturnsDone() &&
		m.MinimockListReturnsByUserDone()
}
