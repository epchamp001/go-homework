// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i pvz-cli/internal/usecase.OrdersRepository -o orders_repo_mock.go -n OrdersRepositoryMock -p mock

import (
	"context"
	"pvz-cli/internal/domain/models"
	"pvz-cli/internal/domain/vo"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrdersRepositoryMock implements mm_usecase.OrdersRepository
type OrdersRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, o *models.Order) (err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, o *models.Order)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mOrdersRepositoryMockCreate

	funcDelete          func(ctx context.Context, id string) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mOrdersRepositoryMockDelete

	funcGet          func(ctx context.Context, id string) (op1 *models.Order, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mOrdersRepositoryMockGet

	funcImportMany          func(ctx context.Context, list []*models.Order) (err error)
	funcImportManyOrigin    string
	inspectFuncImportMany   func(ctx context.Context, list []*models.Order)
	afterImportManyCounter  uint64
	beforeImportManyCounter uint64
	ImportManyMock          mOrdersRepositoryMockImportMany

	funcListAllOrders          func(ctx context.Context) (opa1 []*models.Order, err error)
	funcListAllOrdersOrigin    string
	inspectFuncListAllOrders   func(ctx context.Context)
	afterListAllOrdersCounter  uint64
	beforeListAllOrdersCounter uint64
	ListAllOrdersMock          mOrdersRepositoryMockListAllOrders

	funcListByUser          func(ctx context.Context, userID string, onlyInPVZ bool, lastN int, pg *vo.Pagination) (opa1 []*models.Order, err error)
	funcListByUserOrigin    string
	inspectFuncListByUser   func(ctx context.Context, userID string, onlyInPVZ bool, lastN int, pg *vo.Pagination)
	afterListByUserCounter  uint64
	beforeListByUserCounter uint64
	ListByUserMock          mOrdersRepositoryMockListByUser

	funcUpdate          func(ctx context.Context, o *models.Order) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, o *models.Order)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mOrdersRepositoryMockUpdate
}

// NewOrdersRepositoryMock returns a mock for mm_usecase.OrdersRepository
func NewOrdersRepositoryMock(t minimock.Tester) *OrdersRepositoryMock {
	m := &OrdersRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mOrdersRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*OrdersRepositoryMockCreateParams{}

	m.DeleteMock = mOrdersRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*OrdersRepositoryMockDeleteParams{}

	m.GetMock = mOrdersRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*OrdersRepositoryMockGetParams{}

	m.ImportManyMock = mOrdersRepositoryMockImportMany{mock: m}
	m.ImportManyMock.callArgs = []*OrdersRepositoryMockImportManyParams{}

	m.ListAllOrdersMock = mOrdersRepositoryMockListAllOrders{mock: m}
	m.ListAllOrdersMock.callArgs = []*OrdersRepositoryMockListAllOrdersParams{}

	m.ListByUserMock = mOrdersRepositoryMockListByUser{mock: m}
	m.ListByUserMock.callArgs = []*OrdersRepositoryMockListByUserParams{}

	m.UpdateMock = mOrdersRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*OrdersRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrdersRepositoryMockCreate struct {
	optional           bool
	mock               *OrdersRepositoryMock
	defaultExpectation *OrdersRepositoryMockCreateExpectation
	expectations       []*OrdersRepositoryMockCreateExpectation

	callArgs []*OrdersRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrdersRepositoryMockCreateExpectation specifies expectation struct of the OrdersRepository.Create
type OrdersRepositoryMockCreateExpectation struct {
	mock               *OrdersRepositoryMock
	params             *OrdersRepositoryMockCreateParams
	paramPtrs          *OrdersRepositoryMockCreateParamPtrs
	expectationOrigins OrdersRepositoryMockCreateExpectationOrigins
	results            *OrdersRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// OrdersRepositoryMockCreateParams contains parameters of the OrdersRepository.Create
type OrdersRepositoryMockCreateParams struct {
	ctx context.Context
	o   *models.Order
}

// OrdersRepositoryMockCreateParamPtrs contains pointers to parameters of the OrdersRepository.Create
type OrdersRepositoryMockCreateParamPtrs struct {
	ctx *context.Context
	o   **models.Order
}

// OrdersRepositoryMockCreateResults contains results of the OrdersRepository.Create
type OrdersRepositoryMockCreateResults struct {
	err error
}

// OrdersRepositoryMockCreateOrigins contains origins of expectations of the OrdersRepository.Create
type OrdersRepositoryMockCreateExpectationOrigins struct {
	origin    string
	originCtx string
	originO   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mOrdersRepositoryMockCreate) Optional() *mOrdersRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for OrdersRepository.Create
func (mmCreate *mOrdersRepositoryMockCreate) Expect(ctx context.Context, o *models.Order) *mOrdersRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrdersRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &OrdersRepositoryMockCreateParams{ctx, o}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for OrdersRepository.Create
func (mmCreate *mOrdersRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mOrdersRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrdersRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrdersRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectOParam2 sets up expected param o for OrdersRepository.Create
func (mmCreate *mOrdersRepositoryMockCreate) ExpectOParam2(o *models.Order) *mOrdersRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrdersRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrdersRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.o = &o
	mmCreate.defaultExpectation.expectationOrigins.originO = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.Create
func (mmCreate *mOrdersRepositoryMockCreate) Inspect(f func(ctx context.Context, o *models.Order)) *mOrdersRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by OrdersRepository.Create
func (mmCreate *mOrdersRepositoryMockCreate) Return(err error) *OrdersRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrdersRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &OrdersRepositoryMockCreateResults{err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the OrdersRepository.Create method
func (mmCreate *mOrdersRepositoryMockCreate) Set(f func(ctx context.Context, o *models.Order) (err error)) *OrdersRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the OrdersRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mOrdersRepositoryMockCreate) When(ctx context.Context, o *models.Order) *OrdersRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Set")
	}

	expectation := &OrdersRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &OrdersRepositoryMockCreateParams{ctx, o},
		expectationOrigins: OrdersRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up OrdersRepository.Create return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockCreateExpectation) Then(err error) *OrdersRepositoryMock {
	e.results = &OrdersRepositoryMockCreateResults{err}
	return e.mock
}

// Times sets number of times OrdersRepository.Create should be invoked
func (mmCreate *mOrdersRepositoryMockCreate) Times(n uint64) *mOrdersRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of OrdersRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mOrdersRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_usecase.OrdersRepository
func (mmCreate *OrdersRepositoryMock) Create(ctx context.Context, o *models.Order) (err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, o)
	}

	mm_params := OrdersRepositoryMockCreateParams{ctx, o}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := OrdersRepositoryMockCreateParams{ctx, o}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("OrdersRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o != nil && !minimock.Equal(*mm_want_ptrs.o, mm_got.o) {
				mmCreate.t.Errorf("OrdersRepositoryMock.Create got unexpected parameter o, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originO, *mm_want_ptrs.o, mm_got.o, minimock.Diff(*mm_want_ptrs.o, mm_got.o))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("OrdersRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the OrdersRepositoryMock.Create")
		}
		return (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, o)
	}
	mmCreate.t.Fatalf("Unexpected call to OrdersRepositoryMock.Create. %v %v", ctx, o)
	return
}

// CreateAfterCounter returns a count of finished OrdersRepositoryMock.Create invocations
func (mmCreate *OrdersRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of OrdersRepositoryMock.Create invocations
func (mmCreate *OrdersRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mOrdersRepositoryMockCreate) Calls() []*OrdersRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*OrdersRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrdersRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrdersRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to OrdersRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mOrdersRepositoryMockDelete struct {
	optional           bool
	mock               *OrdersRepositoryMock
	defaultExpectation *OrdersRepositoryMockDeleteExpectation
	expectations       []*OrdersRepositoryMockDeleteExpectation

	callArgs []*OrdersRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrdersRepositoryMockDeleteExpectation specifies expectation struct of the OrdersRepository.Delete
type OrdersRepositoryMockDeleteExpectation struct {
	mock               *OrdersRepositoryMock
	params             *OrdersRepositoryMockDeleteParams
	paramPtrs          *OrdersRepositoryMockDeleteParamPtrs
	expectationOrigins OrdersRepositoryMockDeleteExpectationOrigins
	results            *OrdersRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// OrdersRepositoryMockDeleteParams contains parameters of the OrdersRepository.Delete
type OrdersRepositoryMockDeleteParams struct {
	ctx context.Context
	id  string
}

// OrdersRepositoryMockDeleteParamPtrs contains pointers to parameters of the OrdersRepository.Delete
type OrdersRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *string
}

// OrdersRepositoryMockDeleteResults contains results of the OrdersRepository.Delete
type OrdersRepositoryMockDeleteResults struct {
	err error
}

// OrdersRepositoryMockDeleteOrigins contains origins of expectations of the OrdersRepository.Delete
type OrdersRepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mOrdersRepositoryMockDelete) Optional() *mOrdersRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for OrdersRepository.Delete
func (mmDelete *mOrdersRepositoryMockDelete) Expect(ctx context.Context, id string) *mOrdersRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("OrdersRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &OrdersRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("OrdersRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &OrdersRepositoryMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for OrdersRepository.Delete
func (mmDelete *mOrdersRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mOrdersRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("OrdersRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &OrdersRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("OrdersRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &OrdersRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for OrdersRepository.Delete
func (mmDelete *mOrdersRepositoryMockDelete) ExpectIdParam2(id string) *mOrdersRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("OrdersRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &OrdersRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("OrdersRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &OrdersRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.Delete
func (mmDelete *mOrdersRepositoryMockDelete) Inspect(f func(ctx context.Context, id string)) *mOrdersRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by OrdersRepository.Delete
func (mmDelete *mOrdersRepositoryMockDelete) Return(err error) *OrdersRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("OrdersRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &OrdersRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &OrdersRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the OrdersRepository.Delete method
func (mmDelete *mOrdersRepositoryMockDelete) Set(f func(ctx context.Context, id string) (err error)) *OrdersRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the OrdersRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mOrdersRepositoryMockDelete) When(ctx context.Context, id string) *OrdersRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("OrdersRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &OrdersRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &OrdersRepositoryMockDeleteParams{ctx, id},
		expectationOrigins: OrdersRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up OrdersRepository.Delete return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockDeleteExpectation) Then(err error) *OrdersRepositoryMock {
	e.results = &OrdersRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times OrdersRepository.Delete should be invoked
func (mmDelete *mOrdersRepositoryMockDelete) Times(n uint64) *mOrdersRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of OrdersRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mOrdersRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_usecase.OrdersRepository
func (mmDelete *OrdersRepositoryMock) Delete(ctx context.Context, id string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := OrdersRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := OrdersRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("OrdersRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("OrdersRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("OrdersRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the OrdersRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to OrdersRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished OrdersRepositoryMock.Delete invocations
func (mmDelete *OrdersRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of OrdersRepositoryMock.Delete invocations
func (mmDelete *OrdersRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mOrdersRepositoryMockDelete) Calls() []*OrdersRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*OrdersRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrdersRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrdersRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to OrdersRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mOrdersRepositoryMockGet struct {
	optional           bool
	mock               *OrdersRepositoryMock
	defaultExpectation *OrdersRepositoryMockGetExpectation
	expectations       []*OrdersRepositoryMockGetExpectation

	callArgs []*OrdersRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrdersRepositoryMockGetExpectation specifies expectation struct of the OrdersRepository.Get
type OrdersRepositoryMockGetExpectation struct {
	mock               *OrdersRepositoryMock
	params             *OrdersRepositoryMockGetParams
	paramPtrs          *OrdersRepositoryMockGetParamPtrs
	expectationOrigins OrdersRepositoryMockGetExpectationOrigins
	results            *OrdersRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// OrdersRepositoryMockGetParams contains parameters of the OrdersRepository.Get
type OrdersRepositoryMockGetParams struct {
	ctx context.Context
	id  string
}

// OrdersRepositoryMockGetParamPtrs contains pointers to parameters of the OrdersRepository.Get
type OrdersRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	id  *string
}

// OrdersRepositoryMockGetResults contains results of the OrdersRepository.Get
type OrdersRepositoryMockGetResults struct {
	op1 *models.Order
	err error
}

// OrdersRepositoryMockGetOrigins contains origins of expectations of the OrdersRepository.Get
type OrdersRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mOrdersRepositoryMockGet) Optional() *mOrdersRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for OrdersRepository.Get
func (mmGet *mOrdersRepositoryMockGet) Expect(ctx context.Context, id string) *mOrdersRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OrdersRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &OrdersRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("OrdersRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &OrdersRepositoryMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for OrdersRepository.Get
func (mmGet *mOrdersRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mOrdersRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OrdersRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &OrdersRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("OrdersRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &OrdersRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for OrdersRepository.Get
func (mmGet *mOrdersRepositoryMockGet) ExpectIdParam2(id string) *mOrdersRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OrdersRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &OrdersRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("OrdersRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &OrdersRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.Get
func (mmGet *mOrdersRepositoryMockGet) Inspect(f func(ctx context.Context, id string)) *mOrdersRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by OrdersRepository.Get
func (mmGet *mOrdersRepositoryMockGet) Return(op1 *models.Order, err error) *OrdersRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OrdersRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &OrdersRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &OrdersRepositoryMockGetResults{op1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the OrdersRepository.Get method
func (mmGet *mOrdersRepositoryMockGet) Set(f func(ctx context.Context, id string) (op1 *models.Order, err error)) *OrdersRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the OrdersRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mOrdersRepositoryMockGet) When(ctx context.Context, id string) *OrdersRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OrdersRepositoryMock.Get mock is already set by Set")
	}

	expectation := &OrdersRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &OrdersRepositoryMockGetParams{ctx, id},
		expectationOrigins: OrdersRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up OrdersRepository.Get return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockGetExpectation) Then(op1 *models.Order, err error) *OrdersRepositoryMock {
	e.results = &OrdersRepositoryMockGetResults{op1, err}
	return e.mock
}

// Times sets number of times OrdersRepository.Get should be invoked
func (mmGet *mOrdersRepositoryMockGet) Times(n uint64) *mOrdersRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of OrdersRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mOrdersRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_usecase.OrdersRepository
func (mmGet *OrdersRepositoryMock) Get(ctx context.Context, id string) (op1 *models.Order, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := OrdersRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := OrdersRepositoryMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("OrdersRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("OrdersRepositoryMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("OrdersRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the OrdersRepositoryMock.Get")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to OrdersRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished OrdersRepositoryMock.Get invocations
func (mmGet *OrdersRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of OrdersRepositoryMock.Get invocations
func (mmGet *OrdersRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mOrdersRepositoryMockGet) Calls() []*OrdersRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*OrdersRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrdersRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrdersRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to OrdersRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mOrdersRepositoryMockImportMany struct {
	optional           bool
	mock               *OrdersRepositoryMock
	defaultExpectation *OrdersRepositoryMockImportManyExpectation
	expectations       []*OrdersRepositoryMockImportManyExpectation

	callArgs []*OrdersRepositoryMockImportManyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrdersRepositoryMockImportManyExpectation specifies expectation struct of the OrdersRepository.ImportMany
type OrdersRepositoryMockImportManyExpectation struct {
	mock               *OrdersRepositoryMock
	params             *OrdersRepositoryMockImportManyParams
	paramPtrs          *OrdersRepositoryMockImportManyParamPtrs
	expectationOrigins OrdersRepositoryMockImportManyExpectationOrigins
	results            *OrdersRepositoryMockImportManyResults
	returnOrigin       string
	Counter            uint64
}

// OrdersRepositoryMockImportManyParams contains parameters of the OrdersRepository.ImportMany
type OrdersRepositoryMockImportManyParams struct {
	ctx  context.Context
	list []*models.Order
}

// OrdersRepositoryMockImportManyParamPtrs contains pointers to parameters of the OrdersRepository.ImportMany
type OrdersRepositoryMockImportManyParamPtrs struct {
	ctx  *context.Context
	list *[]*models.Order
}

// OrdersRepositoryMockImportManyResults contains results of the OrdersRepository.ImportMany
type OrdersRepositoryMockImportManyResults struct {
	err error
}

// OrdersRepositoryMockImportManyOrigins contains origins of expectations of the OrdersRepository.ImportMany
type OrdersRepositoryMockImportManyExpectationOrigins struct {
	origin     string
	originCtx  string
	originList string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmImportMany *mOrdersRepositoryMockImportMany) Optional() *mOrdersRepositoryMockImportMany {
	mmImportMany.optional = true
	return mmImportMany
}

// Expect sets up expected params for OrdersRepository.ImportMany
func (mmImportMany *mOrdersRepositoryMockImportMany) Expect(ctx context.Context, list []*models.Order) *mOrdersRepositoryMockImportMany {
	if mmImportMany.mock.funcImportMany != nil {
		mmImportMany.mock.t.Fatalf("OrdersRepositoryMock.ImportMany mock is already set by Set")
	}

	if mmImportMany.defaultExpectation == nil {
		mmImportMany.defaultExpectation = &OrdersRepositoryMockImportManyExpectation{}
	}

	if mmImportMany.defaultExpectation.paramPtrs != nil {
		mmImportMany.mock.t.Fatalf("OrdersRepositoryMock.ImportMany mock is already set by ExpectParams functions")
	}

	mmImportMany.defaultExpectation.params = &OrdersRepositoryMockImportManyParams{ctx, list}
	mmImportMany.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmImportMany.expectations {
		if minimock.Equal(e.params, mmImportMany.defaultExpectation.params) {
			mmImportMany.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmImportMany.defaultExpectation.params)
		}
	}

	return mmImportMany
}

// ExpectCtxParam1 sets up expected param ctx for OrdersRepository.ImportMany
func (mmImportMany *mOrdersRepositoryMockImportMany) ExpectCtxParam1(ctx context.Context) *mOrdersRepositoryMockImportMany {
	if mmImportMany.mock.funcImportMany != nil {
		mmImportMany.mock.t.Fatalf("OrdersRepositoryMock.ImportMany mock is already set by Set")
	}

	if mmImportMany.defaultExpectation == nil {
		mmImportMany.defaultExpectation = &OrdersRepositoryMockImportManyExpectation{}
	}

	if mmImportMany.defaultExpectation.params != nil {
		mmImportMany.mock.t.Fatalf("OrdersRepositoryMock.ImportMany mock is already set by Expect")
	}

	if mmImportMany.defaultExpectation.paramPtrs == nil {
		mmImportMany.defaultExpectation.paramPtrs = &OrdersRepositoryMockImportManyParamPtrs{}
	}
	mmImportMany.defaultExpectation.paramPtrs.ctx = &ctx
	mmImportMany.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmImportMany
}

// ExpectListParam2 sets up expected param list for OrdersRepository.ImportMany
func (mmImportMany *mOrdersRepositoryMockImportMany) ExpectListParam2(list []*models.Order) *mOrdersRepositoryMockImportMany {
	if mmImportMany.mock.funcImportMany != nil {
		mmImportMany.mock.t.Fatalf("OrdersRepositoryMock.ImportMany mock is already set by Set")
	}

	if mmImportMany.defaultExpectation == nil {
		mmImportMany.defaultExpectation = &OrdersRepositoryMockImportManyExpectation{}
	}

	if mmImportMany.defaultExpectation.params != nil {
		mmImportMany.mock.t.Fatalf("OrdersRepositoryMock.ImportMany mock is already set by Expect")
	}

	if mmImportMany.defaultExpectation.paramPtrs == nil {
		mmImportMany.defaultExpectation.paramPtrs = &OrdersRepositoryMockImportManyParamPtrs{}
	}
	mmImportMany.defaultExpectation.paramPtrs.list = &list
	mmImportMany.defaultExpectation.expectationOrigins.originList = minimock.CallerInfo(1)

	return mmImportMany
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.ImportMany
func (mmImportMany *mOrdersRepositoryMockImportMany) Inspect(f func(ctx context.Context, list []*models.Order)) *mOrdersRepositoryMockImportMany {
	if mmImportMany.mock.inspectFuncImportMany != nil {
		mmImportMany.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.ImportMany")
	}

	mmImportMany.mock.inspectFuncImportMany = f

	return mmImportMany
}

// Return sets up results that will be returned by OrdersRepository.ImportMany
func (mmImportMany *mOrdersRepositoryMockImportMany) Return(err error) *OrdersRepositoryMock {
	if mmImportMany.mock.funcImportMany != nil {
		mmImportMany.mock.t.Fatalf("OrdersRepositoryMock.ImportMany mock is already set by Set")
	}

	if mmImportMany.defaultExpectation == nil {
		mmImportMany.defaultExpectation = &OrdersRepositoryMockImportManyExpectation{mock: mmImportMany.mock}
	}
	mmImportMany.defaultExpectation.results = &OrdersRepositoryMockImportManyResults{err}
	mmImportMany.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmImportMany.mock
}

// Set uses given function f to mock the OrdersRepository.ImportMany method
func (mmImportMany *mOrdersRepositoryMockImportMany) Set(f func(ctx context.Context, list []*models.Order) (err error)) *OrdersRepositoryMock {
	if mmImportMany.defaultExpectation != nil {
		mmImportMany.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.ImportMany method")
	}

	if len(mmImportMany.expectations) > 0 {
		mmImportMany.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.ImportMany method")
	}

	mmImportMany.mock.funcImportMany = f
	mmImportMany.mock.funcImportManyOrigin = minimock.CallerInfo(1)
	return mmImportMany.mock
}

// When sets expectation for the OrdersRepository.ImportMany which will trigger the result defined by the following
// Then helper
func (mmImportMany *mOrdersRepositoryMockImportMany) When(ctx context.Context, list []*models.Order) *OrdersRepositoryMockImportManyExpectation {
	if mmImportMany.mock.funcImportMany != nil {
		mmImportMany.mock.t.Fatalf("OrdersRepositoryMock.ImportMany mock is already set by Set")
	}

	expectation := &OrdersRepositoryMockImportManyExpectation{
		mock:               mmImportMany.mock,
		params:             &OrdersRepositoryMockImportManyParams{ctx, list},
		expectationOrigins: OrdersRepositoryMockImportManyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmImportMany.expectations = append(mmImportMany.expectations, expectation)
	return expectation
}

// Then sets up OrdersRepository.ImportMany return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockImportManyExpectation) Then(err error) *OrdersRepositoryMock {
	e.results = &OrdersRepositoryMockImportManyResults{err}
	return e.mock
}

// Times sets number of times OrdersRepository.ImportMany should be invoked
func (mmImportMany *mOrdersRepositoryMockImportMany) Times(n uint64) *mOrdersRepositoryMockImportMany {
	if n == 0 {
		mmImportMany.mock.t.Fatalf("Times of OrdersRepositoryMock.ImportMany mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmImportMany.expectedInvocations, n)
	mmImportMany.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmImportMany
}

func (mmImportMany *mOrdersRepositoryMockImportMany) invocationsDone() bool {
	if len(mmImportMany.expectations) == 0 && mmImportMany.defaultExpectation == nil && mmImportMany.mock.funcImportMany == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmImportMany.mock.afterImportManyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmImportMany.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ImportMany implements mm_usecase.OrdersRepository
func (mmImportMany *OrdersRepositoryMock) ImportMany(ctx context.Context, list []*models.Order) (err error) {
	mm_atomic.AddUint64(&mmImportMany.beforeImportManyCounter, 1)
	defer mm_atomic.AddUint64(&mmImportMany.afterImportManyCounter, 1)

	mmImportMany.t.Helper()

	if mmImportMany.inspectFuncImportMany != nil {
		mmImportMany.inspectFuncImportMany(ctx, list)
	}

	mm_params := OrdersRepositoryMockImportManyParams{ctx, list}

	// Record call args
	mmImportMany.ImportManyMock.mutex.Lock()
	mmImportMany.ImportManyMock.callArgs = append(mmImportMany.ImportManyMock.callArgs, &mm_params)
	mmImportMany.ImportManyMock.mutex.Unlock()

	for _, e := range mmImportMany.ImportManyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmImportMany.ImportManyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmImportMany.ImportManyMock.defaultExpectation.Counter, 1)
		mm_want := mmImportMany.ImportManyMock.defaultExpectation.params
		mm_want_ptrs := mmImportMany.ImportManyMock.defaultExpectation.paramPtrs

		mm_got := OrdersRepositoryMockImportManyParams{ctx, list}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmImportMany.t.Errorf("OrdersRepositoryMock.ImportMany got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImportMany.ImportManyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.list != nil && !minimock.Equal(*mm_want_ptrs.list, mm_got.list) {
				mmImportMany.t.Errorf("OrdersRepositoryMock.ImportMany got unexpected parameter list, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImportMany.ImportManyMock.defaultExpectation.expectationOrigins.originList, *mm_want_ptrs.list, mm_got.list, minimock.Diff(*mm_want_ptrs.list, mm_got.list))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmImportMany.t.Errorf("OrdersRepositoryMock.ImportMany got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmImportMany.ImportManyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmImportMany.ImportManyMock.defaultExpectation.results
		if mm_results == nil {
			mmImportMany.t.Fatal("No results are set for the OrdersRepositoryMock.ImportMany")
		}
		return (*mm_results).err
	}
	if mmImportMany.funcImportMany != nil {
		return mmImportMany.funcImportMany(ctx, list)
	}
	mmImportMany.t.Fatalf("Unexpected call to OrdersRepositoryMock.ImportMany. %v %v", ctx, list)
	return
}

// ImportManyAfterCounter returns a count of finished OrdersRepositoryMock.ImportMany invocations
func (mmImportMany *OrdersRepositoryMock) ImportManyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImportMany.afterImportManyCounter)
}

// ImportManyBeforeCounter returns a count of OrdersRepositoryMock.ImportMany invocations
func (mmImportMany *OrdersRepositoryMock) ImportManyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImportMany.beforeImportManyCounter)
}

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.ImportMany.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmImportMany *mOrdersRepositoryMockImportMany) Calls() []*OrdersRepositoryMockImportManyParams {
	mmImportMany.mutex.RLock()

	argCopy := make([]*OrdersRepositoryMockImportManyParams, len(mmImportMany.callArgs))
	copy(argCopy, mmImportMany.callArgs)

	mmImportMany.mutex.RUnlock()

	return argCopy
}

// MinimockImportManyDone returns true if the count of the ImportMany invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockImportManyDone() bool {
	if m.ImportManyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ImportManyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ImportManyMock.invocationsDone()
}

// MinimockImportManyInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockImportManyInspect() {
	for _, e := range m.ImportManyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersRepositoryMock.ImportMany at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterImportManyCounter := mm_atomic.LoadUint64(&m.afterImportManyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ImportManyMock.defaultExpectation != nil && afterImportManyCounter < 1 {
		if m.ImportManyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrdersRepositoryMock.ImportMany at\n%s", m.ImportManyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrdersRepositoryMock.ImportMany at\n%s with params: %#v", m.ImportManyMock.defaultExpectation.expectationOrigins.origin, *m.ImportManyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcImportMany != nil && afterImportManyCounter < 1 {
		m.t.Errorf("Expected call to OrdersRepositoryMock.ImportMany at\n%s", m.funcImportManyOrigin)
	}

	if !m.ImportManyMock.invocationsDone() && afterImportManyCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersRepositoryMock.ImportMany at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ImportManyMock.expectedInvocations), m.ImportManyMock.expectedInvocationsOrigin, afterImportManyCounter)
	}
}

type mOrdersRepositoryMockListAllOrders struct {
	optional           bool
	mock               *OrdersRepositoryMock
	defaultExpectation *OrdersRepositoryMockListAllOrdersExpectation
	expectations       []*OrdersRepositoryMockListAllOrdersExpectation

	callArgs []*OrdersRepositoryMockListAllOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrdersRepositoryMockListAllOrdersExpectation specifies expectation struct of the OrdersRepository.ListAllOrders
type OrdersRepositoryMockListAllOrdersExpectation struct {
	mock               *OrdersRepositoryMock
	params             *OrdersRepositoryMockListAllOrdersParams
	paramPtrs          *OrdersRepositoryMockListAllOrdersParamPtrs
	expectationOrigins OrdersRepositoryMockListAllOrdersExpectationOrigins
	results            *OrdersRepositoryMockListAllOrdersResults
	returnOrigin       string
	Counter            uint64
}

// OrdersRepositoryMockListAllOrdersParams contains parameters of the OrdersRepository.ListAllOrders
type OrdersRepositoryMockListAllOrdersParams struct {
	ctx context.Context
}

// OrdersRepositoryMockListAllOrdersParamPtrs contains pointers to parameters of the OrdersRepository.ListAllOrders
type OrdersRepositoryMockListAllOrdersParamPtrs struct {
	ctx *context.Context
}

// OrdersRepositoryMockListAllOrdersResults contains results of the OrdersRepository.ListAllOrders
type OrdersRepositoryMockListAllOrdersResults struct {
	opa1 []*models.Order
	err  error
}

// OrdersRepositoryMockListAllOrdersOrigins contains origins of expectations of the OrdersRepository.ListAllOrders
type OrdersRepositoryMockListAllOrdersExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) Optional() *mOrdersRepositoryMockListAllOrders {
	mmListAllOrders.optional = true
	return mmListAllOrders
}

// Expect sets up expected params for OrdersRepository.ListAllOrders
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) Expect(ctx context.Context) *mOrdersRepositoryMockListAllOrders {
	if mmListAllOrders.mock.funcListAllOrders != nil {
		mmListAllOrders.mock.t.Fatalf("OrdersRepositoryMock.ListAllOrders mock is already set by Set")
	}

	if mmListAllOrders.defaultExpectation == nil {
		mmListAllOrders.defaultExpectation = &OrdersRepositoryMockListAllOrdersExpectation{}
	}

	if mmListAllOrders.defaultExpectation.paramPtrs != nil {
		mmListAllOrders.mock.t.Fatalf("OrdersRepositoryMock.ListAllOrders mock is already set by ExpectParams functions")
	}

	mmListAllOrders.defaultExpectation.params = &OrdersRepositoryMockListAllOrdersParams{ctx}
	mmListAllOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListAllOrders.expectations {
		if minimock.Equal(e.params, mmListAllOrders.defaultExpectation.params) {
			mmListAllOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListAllOrders.defaultExpectation.params)
		}
	}

	return mmListAllOrders
}

// ExpectCtxParam1 sets up expected param ctx for OrdersRepository.ListAllOrders
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) ExpectCtxParam1(ctx context.Context) *mOrdersRepositoryMockListAllOrders {
	if mmListAllOrders.mock.funcListAllOrders != nil {
		mmListAllOrders.mock.t.Fatalf("OrdersRepositoryMock.ListAllOrders mock is already set by Set")
	}

	if mmListAllOrders.defaultExpectation == nil {
		mmListAllOrders.defaultExpectation = &OrdersRepositoryMockListAllOrdersExpectation{}
	}

	if mmListAllOrders.defaultExpectation.params != nil {
		mmListAllOrders.mock.t.Fatalf("OrdersRepositoryMock.ListAllOrders mock is already set by Expect")
	}

	if mmListAllOrders.defaultExpectation.paramPtrs == nil {
		mmListAllOrders.defaultExpectation.paramPtrs = &OrdersRepositoryMockListAllOrdersParamPtrs{}
	}
	mmListAllOrders.defaultExpectation.paramPtrs.ctx = &ctx
	mmListAllOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListAllOrders
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.ListAllOrders
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) Inspect(f func(ctx context.Context)) *mOrdersRepositoryMockListAllOrders {
	if mmListAllOrders.mock.inspectFuncListAllOrders != nil {
		mmListAllOrders.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.ListAllOrders")
	}

	mmListAllOrders.mock.inspectFuncListAllOrders = f

	return mmListAllOrders
}

// Return sets up results that will be returned by OrdersRepository.ListAllOrders
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) Return(opa1 []*models.Order, err error) *OrdersRepositoryMock {
	if mmListAllOrders.mock.funcListAllOrders != nil {
		mmListAllOrders.mock.t.Fatalf("OrdersRepositoryMock.ListAllOrders mock is already set by Set")
	}

	if mmListAllOrders.defaultExpectation == nil {
		mmListAllOrders.defaultExpectation = &OrdersRepositoryMockListAllOrdersExpectation{mock: mmListAllOrders.mock}
	}
	mmListAllOrders.defaultExpectation.results = &OrdersRepositoryMockListAllOrdersResults{opa1, err}
	mmListAllOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListAllOrders.mock
}

// Set uses given function f to mock the OrdersRepository.ListAllOrders method
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) Set(f func(ctx context.Context) (opa1 []*models.Order, err error)) *OrdersRepositoryMock {
	if mmListAllOrders.defaultExpectation != nil {
		mmListAllOrders.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.ListAllOrders method")
	}

	if len(mmListAllOrders.expectations) > 0 {
		mmListAllOrders.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.ListAllOrders method")
	}

	mmListAllOrders.mock.funcListAllOrders = f
	mmListAllOrders.mock.funcListAllOrdersOrigin = minimock.CallerInfo(1)
	return mmListAllOrders.mock
}

// When sets expectation for the OrdersRepository.ListAllOrders which will trigger the result defined by the following
// Then helper
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) When(ctx context.Context) *OrdersRepositoryMockListAllOrdersExpectation {
	if mmListAllOrders.mock.funcListAllOrders != nil {
		mmListAllOrders.mock.t.Fatalf("OrdersRepositoryMock.ListAllOrders mock is already set by Set")
	}

	expectation := &OrdersRepositoryMockListAllOrdersExpectation{
		mock:               mmListAllOrders.mock,
		params:             &OrdersRepositoryMockListAllOrdersParams{ctx},
		expectationOrigins: OrdersRepositoryMockListAllOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListAllOrders.expectations = append(mmListAllOrders.expectations, expectation)
	return expectation
}

// Then sets up OrdersRepository.ListAllOrders return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockListAllOrdersExpectation) Then(opa1 []*models.Order, err error) *OrdersRepositoryMock {
	e.results = &OrdersRepositoryMockListAllOrdersResults{opa1, err}
	return e.mock
}

// Times sets number of times OrdersRepository.ListAllOrders should be invoked
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) Times(n uint64) *mOrdersRepositoryMockListAllOrders {
	if n == 0 {
		mmListAllOrders.mock.t.Fatalf("Times of OrdersRepositoryMock.ListAllOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListAllOrders.expectedInvocations, n)
	mmListAllOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListAllOrders
}

func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) invocationsDone() bool {
	if len(mmListAllOrders.expectations) == 0 && mmListAllOrders.defaultExpectation == nil && mmListAllOrders.mock.funcListAllOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListAllOrders.mock.afterListAllOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListAllOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListAllOrders implements mm_usecase.OrdersRepository
func (mmListAllOrders *OrdersRepositoryMock) ListAllOrders(ctx context.Context) (opa1 []*models.Order, err error) {
	mm_atomic.AddUint64(&mmListAllOrders.beforeListAllOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmListAllOrders.afterListAllOrdersCounter, 1)

	mmListAllOrders.t.Helper()

	if mmListAllOrders.inspectFuncListAllOrders != nil {
		mmListAllOrders.inspectFuncListAllOrders(ctx)
	}

	mm_params := OrdersRepositoryMockListAllOrdersParams{ctx}

	// Record call args
	mmListAllOrders.ListAllOrdersMock.mutex.Lock()
	mmListAllOrders.ListAllOrdersMock.callArgs = append(mmListAllOrders.ListAllOrdersMock.callArgs, &mm_params)
	mmListAllOrders.ListAllOrdersMock.mutex.Unlock()

	for _, e := range mmListAllOrders.ListAllOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.opa1, e.results.err
		}
	}

	if mmListAllOrders.ListAllOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListAllOrders.ListAllOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmListAllOrders.ListAllOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmListAllOrders.ListAllOrdersMock.defaultExpectation.paramPtrs

		mm_got := OrdersRepositoryMockListAllOrdersParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListAllOrders.t.Errorf("OrdersRepositoryMock.ListAllOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAllOrders.ListAllOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListAllOrders.t.Errorf("OrdersRepositoryMock.ListAllOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListAllOrders.ListAllOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListAllOrders.ListAllOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmListAllOrders.t.Fatal("No results are set for the OrdersRepositoryMock.ListAllOrders")
		}
		return (*mm_results).opa1, (*mm_results).err
	}
	if mmListAllOrders.funcListAllOrders != nil {
		return mmListAllOrders.funcListAllOrders(ctx)
	}
	mmListAllOrders.t.Fatalf("Unexpected call to OrdersRepositoryMock.ListAllOrders. %v", ctx)
	return
}

// ListAllOrdersAfterCounter returns a count of finished OrdersRepositoryMock.ListAllOrders invocations
func (mmListAllOrders *OrdersRepositoryMock) ListAllOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAllOrders.afterListAllOrdersCounter)
}

// ListAllOrdersBeforeCounter returns a count of OrdersRepositoryMock.ListAllOrders invocations
func (mmListAllOrders *OrdersRepositoryMock) ListAllOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAllOrders.beforeListAllOrdersCounter)
}

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.ListAllOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) Calls() []*OrdersRepositoryMockListAllOrdersParams {
	mmListAllOrders.mutex.RLock()

	argCopy := make([]*OrdersRepositoryMockListAllOrdersParams, len(mmListAllOrders.callArgs))
	copy(argCopy, mmListAllOrders.callArgs)

	mmListAllOrders.mutex.RUnlock()

	return argCopy
}

// MinimockListAllOrdersDone returns true if the count of the ListAllOrders invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockListAllOrdersDone() bool {
	if m.ListAllOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListAllOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListAllOrdersMock.invocationsDone()
}

// MinimockListAllOrdersInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockListAllOrdersInspect() {
	for _, e := range m.ListAllOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersRepositoryMock.ListAllOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListAllOrdersCounter := mm_atomic.LoadUint64(&m.afterListAllOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListAllOrdersMock.defaultExpectation != nil && afterListAllOrdersCounter < 1 {
		if m.ListAllOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrdersRepositoryMock.ListAllOrders at\n%s", m.ListAllOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrdersRepositoryMock.ListAllOrders at\n%s with params: %#v", m.ListAllOrdersMock.defaultExpectation.expectationOrigins.origin, *m.ListAllOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAllOrders != nil && afterListAllOrdersCounter < 1 {
		m.t.Errorf("Expected call to OrdersRepositoryMock.ListAllOrders at\n%s", m.funcListAllOrdersOrigin)
	}

	if !m.ListAllOrdersMock.invocationsDone() && afterListAllOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersRepositoryMock.ListAllOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListAllOrdersMock.expectedInvocations), m.ListAllOrdersMock.expectedInvocationsOrigin, afterListAllOrdersCounter)
	}
}

type mOrdersRepositoryMockListByUser struct {
	optional           bool
	mock               *OrdersRepositoryMock
	defaultExpectation *OrdersRepositoryMockListByUserExpectation
	expectations       []*OrdersRepositoryMockListByUserExpectation

	callArgs []*OrdersRepositoryMockListByUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrdersRepositoryMockListByUserExpectation specifies expectation struct of the OrdersRepository.ListByUser
type OrdersRepositoryMockListByUserExpectation struct {
	mock               *OrdersRepositoryMock
	params             *OrdersRepositoryMockListByUserParams
	paramPtrs          *OrdersRepositoryMockListByUserParamPtrs
	expectationOrigins OrdersRepositoryMockListByUserExpectationOrigins
	results            *OrdersRepositoryMockListByUserResults
	returnOrigin       string
	Counter            uint64
}

// OrdersRepositoryMockListByUserParams contains parameters of the OrdersRepository.ListByUser
type OrdersRepositoryMockListByUserParams struct {
	ctx       context.Context
	userID    string
	onlyInPVZ bool
	lastN     int
	pg        *vo.Pagination
}

// OrdersRepositoryMockListByUserParamPtrs contains pointers to parameters of the OrdersRepository.ListByUser
type OrdersRepositoryMockListByUserParamPtrs struct {
	ctx       *context.Context
	userID    *string
	onlyInPVZ *bool
	lastN     *int
	pg        **vo.Pagination
}

// OrdersRepositoryMockListByUserResults contains results of the OrdersRepository.ListByUser
type OrdersRepositoryMockListByUserResults struct {
	opa1 []*models.Order
	err  error
}

// OrdersRepositoryMockListByUserOrigins contains origins of expectations of the OrdersRepository.ListByUser
type OrdersRepositoryMockListByUserExpectationOrigins struct {
	origin          string
	originCtx       string
	originUserID    string
	originOnlyInPVZ string
	originLastN     string
	originPg        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListByUser *mOrdersRepositoryMockListByUser) Optional() *mOrdersRepositoryMockListByUser {
	mmListByUser.optional = true
	return mmListByUser
}

// Expect sets up expected params for OrdersRepository.ListByUser
func (mmListByUser *mOrdersRepositoryMockListByUser) Expect(ctx context.Context, userID string, onlyInPVZ bool, lastN int, pg *vo.Pagination) *mOrdersRepositoryMockListByUser {
	if mmListByUser.mock.funcListByUser != nil {
		mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Set")
	}

	if mmListByUser.defaultExpectation == nil {
		mmListByUser.defaultExpectation = &OrdersRepositoryMockListByUserExpectation{}
	}

	if mmListByUser.defaultExpectation.paramPtrs != nil {
		mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by ExpectParams functions")
	}

	mmListByUser.defaultExpectation.params = &OrdersRepositoryMockListByUserParams{ctx, userID, onlyInPVZ, lastN, pg}
	mmListByUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListByUser.expectations {
		if minimock.Equal(e.params, mmListByUser.defaultExpectation.params) {
			mmListByUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListByUser.defaultExpectation.params)
		}
	}

	return mmListByUser
}

// ExpectCtxParam1 sets up expected param ctx for OrdersRepository.ListByUser
func (mmListByUser *mOrdersRepositoryMockListByUser) ExpectCtxParam1(ctx context.Context) *mOrdersRepositoryMockListByUser {
	if mmListByUser.mock.funcListByUser != nil {
		mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Set")
	}

	if mmListByUser.defaultExpectation == nil {
		mmListByUser.defaultExpectation = &OrdersRepositoryMockListByUserExpectation{}
	}

	if mmListByUser.defaultExpectation.params != nil {
		mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Expect")
	}

	if mmListByUser.defaultExpectation.paramPtrs == nil {
		mmListByUser.defaultExpectation.paramPtrs = &OrdersRepositoryMockListByUserParamPtrs{}
	}
	mmListByUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmListByUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListByUser
}

// ExpectUserIDParam2 sets up expected param userID for OrdersRepository.ListByUser
func (mmListByUser *mOrdersRepositoryMockListByUser) ExpectUserIDParam2(userID string) *mOrdersRepositoryMockListByUser {
	if mmListByUser.mock.funcListByUser != nil {
		mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Set")
	}

	if mmListByUser.defaultExpectation == nil {
		mmListByUser.defaultExpectation = &OrdersRepositoryMockListByUserExpectation{}
	}

	if mmListByUser.defaultExpectation.params != nil {
		mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Expect")
	}

	if mmListByUser.defaultExpectation.paramPtrs == nil {
		mmListByUser.defaultExpectation.paramPtrs = &OrdersRepositoryMockListByUserParamPtrs{}
	}
	mmListByUser.defaultExpectation.paramPtrs.userID = &userID
	mmListByUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmListByUser
}

// ExpectOnlyInPVZParam3 sets up expected param onlyInPVZ for OrdersRepository.ListByUser
func (mmListByUser *mOrdersRepositoryMockListByUser) ExpectOnlyInPVZParam3(onlyInPVZ bool) *mOrdersRepositoryMockListByUser {
	if mmListByUser.mock.funcListByUser != nil {
		mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Set")
	}

	if mmListByUser.defaultExpectation == nil {
		mmListByUser.defaultExpectation = &OrdersRepositoryMockListByUserExpectation{}
	}

	if mmListByUser.defaultExpectation.params != nil {
		mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Expect")
	}

	if mmListByUser.defaultExpectation.paramPtrs == nil {
		mmListByUser.defaultExpectation.paramPtrs = &OrdersRepositoryMockListByUserParamPtrs{}
	}
	mmListByUser.defaultExpectation.paramPtrs.onlyInPVZ = &onlyInPVZ
	mmListByUser.defaultExpectation.expectationOrigins.originOnlyInPVZ = minimock.CallerInfo(1)

	return mmListByUser
}

// ExpectLastNParam4 sets up expected param lastN for OrdersRepository.ListByUser
func (mmListByUser *mOrdersRepositoryMockListByUser) ExpectLastNParam4(lastN int) *mOrdersRepositoryMockListByUser {
	if mmListByUser.mock.funcListByUser != nil {
		mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Set")
	}

	if mmListByUser.defaultExpectation == nil {
		mmListByUser.defaultExpectation = &OrdersRepositoryMockListByUserExpectation{}
	}

	if mmListByUser.defaultExpectation.params != nil {
		mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Expect")
	}

	if mmListByUser.defaultExpectation.paramPtrs == nil {
		mmListByUser.defaultExpectation.paramPtrs = &OrdersRepositoryMockListByUserParamPtrs{}
	}
	mmListByUser.defaultExpectation.paramPtrs.lastN = &lastN
	mmListByUser.defaultExpectation.expectationOrigins.originLastN = minimock.CallerInfo(1)

	return mmListByUser
}

// ExpectPgParam5 sets up expected param pg for OrdersRepository.ListByUser
func (mmListByUser *mOrdersRepositoryMockListByUser) ExpectPgParam5(pg *vo.Pagination) *mOrdersRepositoryMockListByUser {
	if mmListByUser.mock.funcListByUser != nil {
		mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Set")
	}

	if mmListByUser.defaultExpectation == nil {
		mmListByUser.defaultExpectation = &OrdersRepositoryMockListByUserExpectation{}
	}

	if mmListByUser.defaultExpectation.params != nil {
		mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Expect")
	}

	if mmListByUser.defaultExpectation.paramPtrs == nil {
		mmListByUser.defaultExpectation.paramPtrs = &OrdersRepositoryMockListByUserParamPtrs{}
	}
	mmListByUser.defaultExpectation.paramPtrs.pg = &pg
	mmListByUser.defaultExpectation.expectationOrigins.originPg = minimock.CallerInfo(1)

	return mmListByUser
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.ListByUser
func (mmListByUser *mOrdersRepositoryMockListByUser) Inspect(f func(ctx context.Context, userID string, onlyInPVZ bool, lastN int, pg *vo.Pagination)) *mOrdersRepositoryMockListByUser {
	if mmListByUser.mock.inspectFuncListByUser != nil {
		mmListByUser.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.ListByUser")
	}

	mmListByUser.mock.inspectFuncListByUser = f

	return mmListByUser
}

// Return sets up results that will be returned by OrdersRepository.ListByUser
func (mmListByUser *mOrdersRepositoryMockListByUser) Return(opa1 []*models.Order, err error) *OrdersRepositoryMock {
	if mmListByUser.mock.funcListByUser != nil {
		mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Set")
	}

	if mmListByUser.defaultExpectation == nil {
		mmListByUser.defaultExpectation = &OrdersRepositoryMockListByUserExpectation{mock: mmListByUser.mock}
	}
	mmListByUser.defaultExpectation.results = &OrdersRepositoryMockListByUserResults{opa1, err}
	mmListByUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListByUser.mock
}

// Set uses given function f to mock the OrdersRepository.ListByUser method
func (mmListByUser *mOrdersRepositoryMockListByUser) Set(f func(ctx context.Context, userID string, onlyInPVZ bool, lastN int, pg *vo.Pagination) (opa1 []*models.Order, err error)) *OrdersRepositoryMock {
	if mmListByUser.defaultExpectation != nil {
		mmListByUser.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.ListByUser method")
	}

	if len(mmListByUser.expectations) > 0 {
		mmListByUser.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.ListByUser method")
	}

	mmListByUser.mock.funcListByUser = f
	mmListByUser.mock.funcListByUserOrigin = minimock.CallerInfo(1)
	return mmListByUser.mock
}

// When sets expectation for the OrdersRepository.ListByUser which will trigger the result defined by the following
// Then helper
func (mmListByUser *mOrdersRepositoryMockListByUser) When(ctx context.Context, userID string, onlyInPVZ bool, lastN int, pg *vo.Pagination) *OrdersRepositoryMockListByUserExpectation {
	if mmListByUser.mock.funcListByUser != nil {
		mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Set")
	}

	expectation := &OrdersRepositoryMockListByUserExpectation{
		mock:               mmListByUser.mock,
		params:             &OrdersRepositoryMockListByUserParams{ctx, userID, onlyInPVZ, lastN, pg},
		expectationOrigins: OrdersRepositoryMockListByUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListByUser.expectations = append(mmListByUser.expectations, expectation)
	return expectation
}

// Then sets up OrdersRepository.ListByUser return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockListByUserExpectation) Then(opa1 []*models.Order, err error) *OrdersRepositoryMock {
	e.results = &OrdersRepositoryMockListByUserResults{opa1, err}
	return e.mock
}

// Times sets number of times OrdersRepository.ListByUser should be invoked
func (mmListByUser *mOrdersRepositoryMockListByUser) Times(n uint64) *mOrdersRepositoryMockListByUser {
	if n == 0 {
		mmListByUser.mock.t.Fatalf("Times of OrdersRepositoryMock.ListByUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListByUser.expectedInvocations, n)
	mmListByUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListByUser
}

func (mmListByUser *mOrdersRepositoryMockListByUser) invocationsDone() bool {
	if len(mmListByUser.expectations) == 0 && mmListByUser.defaultExpectation == nil && mmListByUser.mock.funcListByUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListByUser.mock.afterListByUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListByUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListByUser implements mm_usecase.OrdersRepository
func (mmListByUser *OrdersRepositoryMock) ListByUser(ctx context.Context, userID string, onlyInPVZ bool, lastN int, pg *vo.Pagination) (opa1 []*models.Order, err error) {
	mm_atomic.AddUint64(&mmListByUser.beforeListByUserCounter, 1)
	defer mm_atomic.AddUint64(&mmListByUser.afterListByUserCounter, 1)

	mmListByUser.t.Helper()

	if mmListByUser.inspectFuncListByUser != nil {
		mmListByUser.inspectFuncListByUser(ctx, userID, onlyInPVZ, lastN, pg)
	}

	mm_params := OrdersRepositoryMockListByUserParams{ctx, userID, onlyInPVZ, lastN, pg}

	// Record call args
	mmListByUser.ListByUserMock.mutex.Lock()
	mmListByUser.ListByUserMock.callArgs = append(mmListByUser.ListByUserMock.callArgs, &mm_params)
	mmListByUser.ListByUserMock.mutex.Unlock()

	for _, e := range mmListByUser.ListByUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.opa1, e.results.err
		}
	}

	if mmListByUser.ListByUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListByUser.ListByUserMock.defaultExpectation.Counter, 1)
		mm_want := mmListByUser.ListByUserMock.defaultExpectation.params
		mm_want_ptrs := mmListByUser.ListByUserMock.defaultExpectation.paramPtrs

		mm_got := OrdersRepositoryMockListByUserParams{ctx, userID, onlyInPVZ, lastN, pg}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListByUser.t.Errorf("OrdersRepositoryMock.ListByUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListByUser.ListByUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmListByUser.t.Errorf("OrdersRepositoryMock.ListByUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListByUser.ListByUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.onlyInPVZ != nil && !minimock.Equal(*mm_want_ptrs.onlyInPVZ, mm_got.onlyInPVZ) {
				mmListByUser.t.Errorf("OrdersRepositoryMock.ListByUser got unexpected parameter onlyInPVZ, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListByUser.ListByUserMock.defaultExpectation.expectationOrigins.originOnlyInPVZ, *mm_want_ptrs.onlyInPVZ, mm_got.onlyInPVZ, minimock.Diff(*mm_want_ptrs.onlyInPVZ, mm_got.onlyInPVZ))
			}

			if mm_want_ptrs.lastN != nil && !minimock.Equal(*mm_want_ptrs.lastN, mm_got.lastN) {
				mmListByUser.t.Errorf("OrdersRepositoryMock.ListByUser got unexpected parameter lastN, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListByUser.ListByUserMock.defaultExpectation.expectationOrigins.originLastN, *mm_want_ptrs.lastN, mm_got.lastN, minimock.Diff(*mm_want_ptrs.lastN, mm_got.lastN))
			}

			if mm_want_ptrs.pg != nil && !minimock.Equal(*mm_want_ptrs.pg, mm_got.pg) {
				mmListByUser.t.Errorf("OrdersRepositoryMock.ListByUser got unexpected parameter pg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListByUser.ListByUserMock.defaultExpectation.expectationOrigins.originPg, *mm_want_ptrs.pg, mm_got.pg, minimock.Diff(*mm_want_ptrs.pg, mm_got.pg))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListByUser.t.Errorf("OrdersRepositoryMock.ListByUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListByUser.ListByUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListByUser.ListByUserMock.defaultExpectation.results
		if mm_results == nil {
			mmListByUser.t.Fatal("No results are set for the OrdersRepositoryMock.ListByUser")
		}
		return (*mm_results).opa1, (*mm_results).err
	}
	if mmListByUser.funcListByUser != nil {
		return mmListByUser.funcListByUser(ctx, userID, onlyInPVZ, lastN, pg)
	}
	mmListByUser.t.Fatalf("Unexpected call to OrdersRepositoryMock.ListByUser. %v %v %v %v %v", ctx, userID, onlyInPVZ, lastN, pg)
	return
}

// ListByUserAfterCounter returns a count of finished OrdersRepositoryMock.ListByUser invocations
func (mmListByUser *OrdersRepositoryMock) ListByUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListByUser.afterListByUserCounter)
}

// ListByUserBeforeCounter returns a count of OrdersRepositoryMock.ListByUser invocations
func (mmListByUser *OrdersRepositoryMock) ListByUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListByUser.beforeListByUserCounter)
}

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.ListByUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListByUser *mOrdersRepositoryMockListByUser) Calls() []*OrdersRepositoryMockListByUserParams {
	mmListByUser.mutex.RLock()

	argCopy := make([]*OrdersRepositoryMockListByUserParams, len(mmListByUser.callArgs))
	copy(argCopy, mmListByUser.callArgs)

	mmListByUser.mutex.RUnlock()

	return argCopy
}

// MinimockListByUserDone returns true if the count of the ListByUser invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockListByUserDone() bool {
	if m.ListByUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListByUserMock.invocationsDone()
}

// MinimockListByUserInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockListByUserInspect() {
	for _, e := range m.ListByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersRepositoryMock.ListByUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListByUserCounter := mm_atomic.LoadUint64(&m.afterListByUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListByUserMock.defaultExpectation != nil && afterListByUserCounter < 1 {
		if m.ListByUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrdersRepositoryMock.ListByUser at\n%s", m.ListByUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrdersRepositoryMock.ListByUser at\n%s with params: %#v", m.ListByUserMock.defaultExpectation.expectationOrigins.origin, *m.ListByUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListByUser != nil && afterListByUserCounter < 1 {
		m.t.Errorf("Expected call to OrdersRepositoryMock.ListByUser at\n%s", m.funcListByUserOrigin)
	}

	if !m.ListByUserMock.invocationsDone() && afterListByUserCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersRepositoryMock.ListByUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListByUserMock.expectedInvocations), m.ListByUserMock.expectedInvocationsOrigin, afterListByUserCounter)
	}
}

type mOrdersRepositoryMockUpdate struct {
	optional           bool
	mock               *OrdersRepositoryMock
	defaultExpectation *OrdersRepositoryMockUpdateExpectation
	expectations       []*OrdersRepositoryMockUpdateExpectation

	callArgs []*OrdersRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrdersRepositoryMockUpdateExpectation specifies expectation struct of the OrdersRepository.Update
type OrdersRepositoryMockUpdateExpectation struct {
	mock               *OrdersRepositoryMock
	params             *OrdersRepositoryMockUpdateParams
	paramPtrs          *OrdersRepositoryMockUpdateParamPtrs
	expectationOrigins OrdersRepositoryMockUpdateExpectationOrigins
	results            *OrdersRepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// OrdersRepositoryMockUpdateParams contains parameters of the OrdersRepository.Update
type OrdersRepositoryMockUpdateParams struct {
	ctx context.Context
	o   *models.Order
}

// OrdersRepositoryMockUpdateParamPtrs contains pointers to parameters of the OrdersRepository.Update
type OrdersRepositoryMockUpdateParamPtrs struct {
	ctx *context.Context
	o   **models.Order
}

// OrdersRepositoryMockUpdateResults contains results of the OrdersRepository.Update
type OrdersRepositoryMockUpdateResults struct {
	err error
}

// OrdersRepositoryMockUpdateOrigins contains origins of expectations of the OrdersRepository.Update
type OrdersRepositoryMockUpdateExpectationOrigins struct {
	origin    string
	originCtx string
	originO   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mOrdersRepositoryMockUpdate) Optional() *mOrdersRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for OrdersRepository.Update
func (mmUpdate *mOrdersRepositoryMockUpdate) Expect(ctx context.Context, o *models.Order) *mOrdersRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("OrdersRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &OrdersRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("OrdersRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &OrdersRepositoryMockUpdateParams{ctx, o}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for OrdersRepository.Update
func (mmUpdate *mOrdersRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mOrdersRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("OrdersRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &OrdersRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("OrdersRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &OrdersRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectOParam2 sets up expected param o for OrdersRepository.Update
func (mmUpdate *mOrdersRepositoryMockUpdate) ExpectOParam2(o *models.Order) *mOrdersRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("OrdersRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &OrdersRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("OrdersRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &OrdersRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.o = &o
	mmUpdate.defaultExpectation.expectationOrigins.originO = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.Update
func (mmUpdate *mOrdersRepositoryMockUpdate) Inspect(f func(ctx context.Context, o *models.Order)) *mOrdersRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by OrdersRepository.Update
func (mmUpdate *mOrdersRepositoryMockUpdate) Return(err error) *OrdersRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("OrdersRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &OrdersRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &OrdersRepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the OrdersRepository.Update method
func (mmUpdate *mOrdersRepositoryMockUpdate) Set(f func(ctx context.Context, o *models.Order) (err error)) *OrdersRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the OrdersRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mOrdersRepositoryMockUpdate) When(ctx context.Context, o *models.Order) *OrdersRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("OrdersRepositoryMock.Update mock is already set by Set")
	}

	expectation := &OrdersRepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &OrdersRepositoryMockUpdateParams{ctx, o},
		expectationOrigins: OrdersRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up OrdersRepository.Update return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockUpdateExpectation) Then(err error) *OrdersRepositoryMock {
	e.results = &OrdersRepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times OrdersRepository.Update should be invoked
func (mmUpdate *mOrdersRepositoryMockUpdate) Times(n uint64) *mOrdersRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of OrdersRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mOrdersRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_usecase.OrdersRepository
func (mmUpdate *OrdersRepositoryMock) Update(ctx context.Context, o *models.Order) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, o)
	}

	mm_params := OrdersRepositoryMockUpdateParams{ctx, o}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := OrdersRepositoryMockUpdateParams{ctx, o}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("OrdersRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o != nil && !minimock.Equal(*mm_want_ptrs.o, mm_got.o) {
				mmUpdate.t.Errorf("OrdersRepositoryMock.Update got unexpected parameter o, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originO, *mm_want_ptrs.o, mm_got.o, minimock.Diff(*mm_want_ptrs.o, mm_got.o))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("OrdersRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the OrdersRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, o)
	}
	mmUpdate.t.Fatalf("Unexpected call to OrdersRepositoryMock.Update. %v %v", ctx, o)
	return
}

// UpdateAfterCounter returns a count of finished OrdersRepositoryMock.Update invocations
func (mmUpdate *OrdersRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of OrdersRepositoryMock.Update invocations
func (mmUpdate *OrdersRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mOrdersRepositoryMockUpdate) Calls() []*OrdersRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*OrdersRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrdersRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrdersRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to OrdersRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersRepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrdersRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockImportManyInspect()

			m.MinimockListAllOrdersInspect()

			m.MinimockListByUserInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrdersRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrdersRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockImportManyDone() &&
		m.MinimockListAllOrdersDone() &&
		m.MinimockListByUserDone() &&
		m.MinimockUpdateDone()
}
