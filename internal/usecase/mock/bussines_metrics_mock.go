// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i pvz-cli/internal/usecase.BussinesMetrics -o bussines_metrics_mock.go -n BussinesMetricsMock -p mock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// BussinesMetricsMock implements mm_usecase.BussinesMetrics
type BussinesMetricsMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcIncOrdersAccepted          func()
	funcIncOrdersAcceptedOrigin    string
	inspectFuncIncOrdersAccepted   func()
	afterIncOrdersAcceptedCounter  uint64
	beforeIncOrdersAcceptedCounter uint64
	IncOrdersAcceptedMock          mBussinesMetricsMockIncOrdersAccepted

	funcIncOrdersIssued          func()
	funcIncOrdersIssuedOrigin    string
	inspectFuncIncOrdersIssued   func()
	afterIncOrdersIssuedCounter  uint64
	beforeIncOrdersIssuedCounter uint64
	IncOrdersIssuedMock          mBussinesMetricsMockIncOrdersIssued

	funcIncOrdersReturned          func()
	funcIncOrdersReturnedOrigin    string
	inspectFuncIncOrdersReturned   func()
	afterIncOrdersReturnedCounter  uint64
	beforeIncOrdersReturnedCounter uint64
	IncOrdersReturnedMock          mBussinesMetricsMockIncOrdersReturned
}

// NewBussinesMetricsMock returns a mock for mm_usecase.BussinesMetrics
func NewBussinesMetricsMock(t minimock.Tester) *BussinesMetricsMock {
	m := &BussinesMetricsMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.IncOrdersAcceptedMock = mBussinesMetricsMockIncOrdersAccepted{mock: m}

	m.IncOrdersIssuedMock = mBussinesMetricsMockIncOrdersIssued{mock: m}

	m.IncOrdersReturnedMock = mBussinesMetricsMockIncOrdersReturned{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mBussinesMetricsMockIncOrdersAccepted struct {
	optional           bool
	mock               *BussinesMetricsMock
	defaultExpectation *BussinesMetricsMockIncOrdersAcceptedExpectation
	expectations       []*BussinesMetricsMockIncOrdersAcceptedExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BussinesMetricsMockIncOrdersAcceptedExpectation specifies expectation struct of the BussinesMetrics.IncOrdersAccepted
type BussinesMetricsMockIncOrdersAcceptedExpectation struct {
	mock *BussinesMetricsMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIncOrdersAccepted *mBussinesMetricsMockIncOrdersAccepted) Optional() *mBussinesMetricsMockIncOrdersAccepted {
	mmIncOrdersAccepted.optional = true
	return mmIncOrdersAccepted
}

// Expect sets up expected params for BussinesMetrics.IncOrdersAccepted
func (mmIncOrdersAccepted *mBussinesMetricsMockIncOrdersAccepted) Expect() *mBussinesMetricsMockIncOrdersAccepted {
	if mmIncOrdersAccepted.mock.funcIncOrdersAccepted != nil {
		mmIncOrdersAccepted.mock.t.Fatalf("BussinesMetricsMock.IncOrdersAccepted mock is already set by Set")
	}

	if mmIncOrdersAccepted.defaultExpectation == nil {
		mmIncOrdersAccepted.defaultExpectation = &BussinesMetricsMockIncOrdersAcceptedExpectation{}
	}

	return mmIncOrdersAccepted
}

// Inspect accepts an inspector function that has same arguments as the BussinesMetrics.IncOrdersAccepted
func (mmIncOrdersAccepted *mBussinesMetricsMockIncOrdersAccepted) Inspect(f func()) *mBussinesMetricsMockIncOrdersAccepted {
	if mmIncOrdersAccepted.mock.inspectFuncIncOrdersAccepted != nil {
		mmIncOrdersAccepted.mock.t.Fatalf("Inspect function is already set for BussinesMetricsMock.IncOrdersAccepted")
	}

	mmIncOrdersAccepted.mock.inspectFuncIncOrdersAccepted = f

	return mmIncOrdersAccepted
}

// Return sets up results that will be returned by BussinesMetrics.IncOrdersAccepted
func (mmIncOrdersAccepted *mBussinesMetricsMockIncOrdersAccepted) Return() *BussinesMetricsMock {
	if mmIncOrdersAccepted.mock.funcIncOrdersAccepted != nil {
		mmIncOrdersAccepted.mock.t.Fatalf("BussinesMetricsMock.IncOrdersAccepted mock is already set by Set")
	}

	if mmIncOrdersAccepted.defaultExpectation == nil {
		mmIncOrdersAccepted.defaultExpectation = &BussinesMetricsMockIncOrdersAcceptedExpectation{mock: mmIncOrdersAccepted.mock}
	}

	mmIncOrdersAccepted.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIncOrdersAccepted.mock
}

// Set uses given function f to mock the BussinesMetrics.IncOrdersAccepted method
func (mmIncOrdersAccepted *mBussinesMetricsMockIncOrdersAccepted) Set(f func()) *BussinesMetricsMock {
	if mmIncOrdersAccepted.defaultExpectation != nil {
		mmIncOrdersAccepted.mock.t.Fatalf("Default expectation is already set for the BussinesMetrics.IncOrdersAccepted method")
	}

	if len(mmIncOrdersAccepted.expectations) > 0 {
		mmIncOrdersAccepted.mock.t.Fatalf("Some expectations are already set for the BussinesMetrics.IncOrdersAccepted method")
	}

	mmIncOrdersAccepted.mock.funcIncOrdersAccepted = f
	mmIncOrdersAccepted.mock.funcIncOrdersAcceptedOrigin = minimock.CallerInfo(1)
	return mmIncOrdersAccepted.mock
}

// Times sets number of times BussinesMetrics.IncOrdersAccepted should be invoked
func (mmIncOrdersAccepted *mBussinesMetricsMockIncOrdersAccepted) Times(n uint64) *mBussinesMetricsMockIncOrdersAccepted {
	if n == 0 {
		mmIncOrdersAccepted.mock.t.Fatalf("Times of BussinesMetricsMock.IncOrdersAccepted mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIncOrdersAccepted.expectedInvocations, n)
	mmIncOrdersAccepted.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIncOrdersAccepted
}

func (mmIncOrdersAccepted *mBussinesMetricsMockIncOrdersAccepted) invocationsDone() bool {
	if len(mmIncOrdersAccepted.expectations) == 0 && mmIncOrdersAccepted.defaultExpectation == nil && mmIncOrdersAccepted.mock.funcIncOrdersAccepted == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIncOrdersAccepted.mock.afterIncOrdersAcceptedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIncOrdersAccepted.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IncOrdersAccepted implements mm_usecase.BussinesMetrics
func (mmIncOrdersAccepted *BussinesMetricsMock) IncOrdersAccepted() {
	mm_atomic.AddUint64(&mmIncOrdersAccepted.beforeIncOrdersAcceptedCounter, 1)
	defer mm_atomic.AddUint64(&mmIncOrdersAccepted.afterIncOrdersAcceptedCounter, 1)

	mmIncOrdersAccepted.t.Helper()

	if mmIncOrdersAccepted.inspectFuncIncOrdersAccepted != nil {
		mmIncOrdersAccepted.inspectFuncIncOrdersAccepted()
	}

	if mmIncOrdersAccepted.IncOrdersAcceptedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIncOrdersAccepted.IncOrdersAcceptedMock.defaultExpectation.Counter, 1)

		return

	}
	if mmIncOrdersAccepted.funcIncOrdersAccepted != nil {
		mmIncOrdersAccepted.funcIncOrdersAccepted()
		return
	}
	mmIncOrdersAccepted.t.Fatalf("Unexpected call to BussinesMetricsMock.IncOrdersAccepted.")

}

// IncOrdersAcceptedAfterCounter returns a count of finished BussinesMetricsMock.IncOrdersAccepted invocations
func (mmIncOrdersAccepted *BussinesMetricsMock) IncOrdersAcceptedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncOrdersAccepted.afterIncOrdersAcceptedCounter)
}

// IncOrdersAcceptedBeforeCounter returns a count of BussinesMetricsMock.IncOrdersAccepted invocations
func (mmIncOrdersAccepted *BussinesMetricsMock) IncOrdersAcceptedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncOrdersAccepted.beforeIncOrdersAcceptedCounter)
}

// MinimockIncOrdersAcceptedDone returns true if the count of the IncOrdersAccepted invocations corresponds
// the number of defined expectations
func (m *BussinesMetricsMock) MinimockIncOrdersAcceptedDone() bool {
	if m.IncOrdersAcceptedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IncOrdersAcceptedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IncOrdersAcceptedMock.invocationsDone()
}

// MinimockIncOrdersAcceptedInspect logs each unmet expectation
func (m *BussinesMetricsMock) MinimockIncOrdersAcceptedInspect() {
	for _, e := range m.IncOrdersAcceptedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to BussinesMetricsMock.IncOrdersAccepted")
		}
	}

	afterIncOrdersAcceptedCounter := mm_atomic.LoadUint64(&m.afterIncOrdersAcceptedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IncOrdersAcceptedMock.defaultExpectation != nil && afterIncOrdersAcceptedCounter < 1 {
		m.t.Errorf("Expected call to BussinesMetricsMock.IncOrdersAccepted at\n%s", m.IncOrdersAcceptedMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncOrdersAccepted != nil && afterIncOrdersAcceptedCounter < 1 {
		m.t.Errorf("Expected call to BussinesMetricsMock.IncOrdersAccepted at\n%s", m.funcIncOrdersAcceptedOrigin)
	}

	if !m.IncOrdersAcceptedMock.invocationsDone() && afterIncOrdersAcceptedCounter > 0 {
		m.t.Errorf("Expected %d calls to BussinesMetricsMock.IncOrdersAccepted at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IncOrdersAcceptedMock.expectedInvocations), m.IncOrdersAcceptedMock.expectedInvocationsOrigin, afterIncOrdersAcceptedCounter)
	}
}

type mBussinesMetricsMockIncOrdersIssued struct {
	optional           bool
	mock               *BussinesMetricsMock
	defaultExpectation *BussinesMetricsMockIncOrdersIssuedExpectation
	expectations       []*BussinesMetricsMockIncOrdersIssuedExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BussinesMetricsMockIncOrdersIssuedExpectation specifies expectation struct of the BussinesMetrics.IncOrdersIssued
type BussinesMetricsMockIncOrdersIssuedExpectation struct {
	mock *BussinesMetricsMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIncOrdersIssued *mBussinesMetricsMockIncOrdersIssued) Optional() *mBussinesMetricsMockIncOrdersIssued {
	mmIncOrdersIssued.optional = true
	return mmIncOrdersIssued
}

// Expect sets up expected params for BussinesMetrics.IncOrdersIssued
func (mmIncOrdersIssued *mBussinesMetricsMockIncOrdersIssued) Expect() *mBussinesMetricsMockIncOrdersIssued {
	if mmIncOrdersIssued.mock.funcIncOrdersIssued != nil {
		mmIncOrdersIssued.mock.t.Fatalf("BussinesMetricsMock.IncOrdersIssued mock is already set by Set")
	}

	if mmIncOrdersIssued.defaultExpectation == nil {
		mmIncOrdersIssued.defaultExpectation = &BussinesMetricsMockIncOrdersIssuedExpectation{}
	}

	return mmIncOrdersIssued
}

// Inspect accepts an inspector function that has same arguments as the BussinesMetrics.IncOrdersIssued
func (mmIncOrdersIssued *mBussinesMetricsMockIncOrdersIssued) Inspect(f func()) *mBussinesMetricsMockIncOrdersIssued {
	if mmIncOrdersIssued.mock.inspectFuncIncOrdersIssued != nil {
		mmIncOrdersIssued.mock.t.Fatalf("Inspect function is already set for BussinesMetricsMock.IncOrdersIssued")
	}

	mmIncOrdersIssued.mock.inspectFuncIncOrdersIssued = f

	return mmIncOrdersIssued
}

// Return sets up results that will be returned by BussinesMetrics.IncOrdersIssued
func (mmIncOrdersIssued *mBussinesMetricsMockIncOrdersIssued) Return() *BussinesMetricsMock {
	if mmIncOrdersIssued.mock.funcIncOrdersIssued != nil {
		mmIncOrdersIssued.mock.t.Fatalf("BussinesMetricsMock.IncOrdersIssued mock is already set by Set")
	}

	if mmIncOrdersIssued.defaultExpectation == nil {
		mmIncOrdersIssued.defaultExpectation = &BussinesMetricsMockIncOrdersIssuedExpectation{mock: mmIncOrdersIssued.mock}
	}

	mmIncOrdersIssued.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIncOrdersIssued.mock
}

// Set uses given function f to mock the BussinesMetrics.IncOrdersIssued method
func (mmIncOrdersIssued *mBussinesMetricsMockIncOrdersIssued) Set(f func()) *BussinesMetricsMock {
	if mmIncOrdersIssued.defaultExpectation != nil {
		mmIncOrdersIssued.mock.t.Fatalf("Default expectation is already set for the BussinesMetrics.IncOrdersIssued method")
	}

	if len(mmIncOrdersIssued.expectations) > 0 {
		mmIncOrdersIssued.mock.t.Fatalf("Some expectations are already set for the BussinesMetrics.IncOrdersIssued method")
	}

	mmIncOrdersIssued.mock.funcIncOrdersIssued = f
	mmIncOrdersIssued.mock.funcIncOrdersIssuedOrigin = minimock.CallerInfo(1)
	return mmIncOrdersIssued.mock
}

// Times sets number of times BussinesMetrics.IncOrdersIssued should be invoked
func (mmIncOrdersIssued *mBussinesMetricsMockIncOrdersIssued) Times(n uint64) *mBussinesMetricsMockIncOrdersIssued {
	if n == 0 {
		mmIncOrdersIssued.mock.t.Fatalf("Times of BussinesMetricsMock.IncOrdersIssued mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIncOrdersIssued.expectedInvocations, n)
	mmIncOrdersIssued.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIncOrdersIssued
}

func (mmIncOrdersIssued *mBussinesMetricsMockIncOrdersIssued) invocationsDone() bool {
	if len(mmIncOrdersIssued.expectations) == 0 && mmIncOrdersIssued.defaultExpectation == nil && mmIncOrdersIssued.mock.funcIncOrdersIssued == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIncOrdersIssued.mock.afterIncOrdersIssuedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIncOrdersIssued.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IncOrdersIssued implements mm_usecase.BussinesMetrics
func (mmIncOrdersIssued *BussinesMetricsMock) IncOrdersIssued() {
	mm_atomic.AddUint64(&mmIncOrdersIssued.beforeIncOrdersIssuedCounter, 1)
	defer mm_atomic.AddUint64(&mmIncOrdersIssued.afterIncOrdersIssuedCounter, 1)

	mmIncOrdersIssued.t.Helper()

	if mmIncOrdersIssued.inspectFuncIncOrdersIssued != nil {
		mmIncOrdersIssued.inspectFuncIncOrdersIssued()
	}

	if mmIncOrdersIssued.IncOrdersIssuedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIncOrdersIssued.IncOrdersIssuedMock.defaultExpectation.Counter, 1)

		return

	}
	if mmIncOrdersIssued.funcIncOrdersIssued != nil {
		mmIncOrdersIssued.funcIncOrdersIssued()
		return
	}
	mmIncOrdersIssued.t.Fatalf("Unexpected call to BussinesMetricsMock.IncOrdersIssued.")

}

// IncOrdersIssuedAfterCounter returns a count of finished BussinesMetricsMock.IncOrdersIssued invocations
func (mmIncOrdersIssued *BussinesMetricsMock) IncOrdersIssuedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncOrdersIssued.afterIncOrdersIssuedCounter)
}

// IncOrdersIssuedBeforeCounter returns a count of BussinesMetricsMock.IncOrdersIssued invocations
func (mmIncOrdersIssued *BussinesMetricsMock) IncOrdersIssuedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncOrdersIssued.beforeIncOrdersIssuedCounter)
}

// MinimockIncOrdersIssuedDone returns true if the count of the IncOrdersIssued invocations corresponds
// the number of defined expectations
func (m *BussinesMetricsMock) MinimockIncOrdersIssuedDone() bool {
	if m.IncOrdersIssuedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IncOrdersIssuedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IncOrdersIssuedMock.invocationsDone()
}

// MinimockIncOrdersIssuedInspect logs each unmet expectation
func (m *BussinesMetricsMock) MinimockIncOrdersIssuedInspect() {
	for _, e := range m.IncOrdersIssuedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to BussinesMetricsMock.IncOrdersIssued")
		}
	}

	afterIncOrdersIssuedCounter := mm_atomic.LoadUint64(&m.afterIncOrdersIssuedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IncOrdersIssuedMock.defaultExpectation != nil && afterIncOrdersIssuedCounter < 1 {
		m.t.Errorf("Expected call to BussinesMetricsMock.IncOrdersIssued at\n%s", m.IncOrdersIssuedMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncOrdersIssued != nil && afterIncOrdersIssuedCounter < 1 {
		m.t.Errorf("Expected call to BussinesMetricsMock.IncOrdersIssued at\n%s", m.funcIncOrdersIssuedOrigin)
	}

	if !m.IncOrdersIssuedMock.invocationsDone() && afterIncOrdersIssuedCounter > 0 {
		m.t.Errorf("Expected %d calls to BussinesMetricsMock.IncOrdersIssued at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IncOrdersIssuedMock.expectedInvocations), m.IncOrdersIssuedMock.expectedInvocationsOrigin, afterIncOrdersIssuedCounter)
	}
}

type mBussinesMetricsMockIncOrdersReturned struct {
	optional           bool
	mock               *BussinesMetricsMock
	defaultExpectation *BussinesMetricsMockIncOrdersReturnedExpectation
	expectations       []*BussinesMetricsMockIncOrdersReturnedExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BussinesMetricsMockIncOrdersReturnedExpectation specifies expectation struct of the BussinesMetrics.IncOrdersReturned
type BussinesMetricsMockIncOrdersReturnedExpectation struct {
	mock *BussinesMetricsMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIncOrdersReturned *mBussinesMetricsMockIncOrdersReturned) Optional() *mBussinesMetricsMockIncOrdersReturned {
	mmIncOrdersReturned.optional = true
	return mmIncOrdersReturned
}

// Expect sets up expected params for BussinesMetrics.IncOrdersReturned
func (mmIncOrdersReturned *mBussinesMetricsMockIncOrdersReturned) Expect() *mBussinesMetricsMockIncOrdersReturned {
	if mmIncOrdersReturned.mock.funcIncOrdersReturned != nil {
		mmIncOrdersReturned.mock.t.Fatalf("BussinesMetricsMock.IncOrdersReturned mock is already set by Set")
	}

	if mmIncOrdersReturned.defaultExpectation == nil {
		mmIncOrdersReturned.defaultExpectation = &BussinesMetricsMockIncOrdersReturnedExpectation{}
	}

	return mmIncOrdersReturned
}

// Inspect accepts an inspector function that has same arguments as the BussinesMetrics.IncOrdersReturned
func (mmIncOrdersReturned *mBussinesMetricsMockIncOrdersReturned) Inspect(f func()) *mBussinesMetricsMockIncOrdersReturned {
	if mmIncOrdersReturned.mock.inspectFuncIncOrdersReturned != nil {
		mmIncOrdersReturned.mock.t.Fatalf("Inspect function is already set for BussinesMetricsMock.IncOrdersReturned")
	}

	mmIncOrdersReturned.mock.inspectFuncIncOrdersReturned = f

	return mmIncOrdersReturned
}

// Return sets up results that will be returned by BussinesMetrics.IncOrdersReturned
func (mmIncOrdersReturned *mBussinesMetricsMockIncOrdersReturned) Return() *BussinesMetricsMock {
	if mmIncOrdersReturned.mock.funcIncOrdersReturned != nil {
		mmIncOrdersReturned.mock.t.Fatalf("BussinesMetricsMock.IncOrdersReturned mock is already set by Set")
	}

	if mmIncOrdersReturned.defaultExpectation == nil {
		mmIncOrdersReturned.defaultExpectation = &BussinesMetricsMockIncOrdersReturnedExpectation{mock: mmIncOrdersReturned.mock}
	}

	mmIncOrdersReturned.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIncOrdersReturned.mock
}

// Set uses given function f to mock the BussinesMetrics.IncOrdersReturned method
func (mmIncOrdersReturned *mBussinesMetricsMockIncOrdersReturned) Set(f func()) *BussinesMetricsMock {
	if mmIncOrdersReturned.defaultExpectation != nil {
		mmIncOrdersReturned.mock.t.Fatalf("Default expectation is already set for the BussinesMetrics.IncOrdersReturned method")
	}

	if len(mmIncOrdersReturned.expectations) > 0 {
		mmIncOrdersReturned.mock.t.Fatalf("Some expectations are already set for the BussinesMetrics.IncOrdersReturned method")
	}

	mmIncOrdersReturned.mock.funcIncOrdersReturned = f
	mmIncOrdersReturned.mock.funcIncOrdersReturnedOrigin = minimock.CallerInfo(1)
	return mmIncOrdersReturned.mock
}

// Times sets number of times BussinesMetrics.IncOrdersReturned should be invoked
func (mmIncOrdersReturned *mBussinesMetricsMockIncOrdersReturned) Times(n uint64) *mBussinesMetricsMockIncOrdersReturned {
	if n == 0 {
		mmIncOrdersReturned.mock.t.Fatalf("Times of BussinesMetricsMock.IncOrdersReturned mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIncOrdersReturned.expectedInvocations, n)
	mmIncOrdersReturned.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIncOrdersReturned
}

func (mmIncOrdersReturned *mBussinesMetricsMockIncOrdersReturned) invocationsDone() bool {
	if len(mmIncOrdersReturned.expectations) == 0 && mmIncOrdersReturned.defaultExpectation == nil && mmIncOrdersReturned.mock.funcIncOrdersReturned == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIncOrdersReturned.mock.afterIncOrdersReturnedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIncOrdersReturned.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IncOrdersReturned implements mm_usecase.BussinesMetrics
func (mmIncOrdersReturned *BussinesMetricsMock) IncOrdersReturned() {
	mm_atomic.AddUint64(&mmIncOrdersReturned.beforeIncOrdersReturnedCounter, 1)
	defer mm_atomic.AddUint64(&mmIncOrdersReturned.afterIncOrdersReturnedCounter, 1)

	mmIncOrdersReturned.t.Helper()

	if mmIncOrdersReturned.inspectFuncIncOrdersReturned != nil {
		mmIncOrdersReturned.inspectFuncIncOrdersReturned()
	}

	if mmIncOrdersReturned.IncOrdersReturnedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIncOrdersReturned.IncOrdersReturnedMock.defaultExpectation.Counter, 1)

		return

	}
	if mmIncOrdersReturned.funcIncOrdersReturned != nil {
		mmIncOrdersReturned.funcIncOrdersReturned()
		return
	}
	mmIncOrdersReturned.t.Fatalf("Unexpected call to BussinesMetricsMock.IncOrdersReturned.")

}

// IncOrdersReturnedAfterCounter returns a count of finished BussinesMetricsMock.IncOrdersReturned invocations
func (mmIncOrdersReturned *BussinesMetricsMock) IncOrdersReturnedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncOrdersReturned.afterIncOrdersReturnedCounter)
}

// IncOrdersReturnedBeforeCounter returns a count of BussinesMetricsMock.IncOrdersReturned invocations
func (mmIncOrdersReturned *BussinesMetricsMock) IncOrdersReturnedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncOrdersReturned.beforeIncOrdersReturnedCounter)
}

// MinimockIncOrdersReturnedDone returns true if the count of the IncOrdersReturned invocations corresponds
// the number of defined expectations
func (m *BussinesMetricsMock) MinimockIncOrdersReturnedDone() bool {
	if m.IncOrdersReturnedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IncOrdersReturnedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IncOrdersReturnedMock.invocationsDone()
}

// MinimockIncOrdersReturnedInspect logs each unmet expectation
func (m *BussinesMetricsMock) MinimockIncOrdersReturnedInspect() {
	for _, e := range m.IncOrdersReturnedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to BussinesMetricsMock.IncOrdersReturned")
		}
	}

	afterIncOrdersReturnedCounter := mm_atomic.LoadUint64(&m.afterIncOrdersReturnedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IncOrdersReturnedMock.defaultExpectation != nil && afterIncOrdersReturnedCounter < 1 {
		m.t.Errorf("Expected call to BussinesMetricsMock.IncOrdersReturned at\n%s", m.IncOrdersReturnedMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncOrdersReturned != nil && afterIncOrdersReturnedCounter < 1 {
		m.t.Errorf("Expected call to BussinesMetricsMock.IncOrdersReturned at\n%s", m.funcIncOrdersReturnedOrigin)
	}

	if !m.IncOrdersReturnedMock.invocationsDone() && afterIncOrdersReturnedCounter > 0 {
		m.t.Errorf("Expected %d calls to BussinesMetricsMock.IncOrdersReturned at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IncOrdersReturnedMock.expectedInvocations), m.IncOrdersReturnedMock.expectedInvocationsOrigin, afterIncOrdersReturnedCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BussinesMetricsMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockIncOrdersAcceptedInspect()

			m.MinimockIncOrdersIssuedInspect()

			m.MinimockIncOrdersReturnedInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BussinesMetricsMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *BussinesMetricsMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockIncOrdersAcceptedDone() &&
		m.MinimockIncOrdersIssuedDone() &&
		m.MinimockIncOrdersReturnedDone()
}
