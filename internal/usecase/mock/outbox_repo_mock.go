// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i pvz-cli/internal/usecase.OutboxRepository -o outbox_repo_mock.go -n OutboxRepositoryMock -p mock

import (
	"context"
	"pvz-cli/internal/domain/models"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// OutboxRepositoryMock implements mm_usecase.OutboxRepository
type OutboxRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAdd          func(ctx context.Context, evt *models.OrderEvent) (err error)
	funcAddOrigin    string
	inspectFuncAdd   func(ctx context.Context, evt *models.OrderEvent)
	afterAddCounter  uint64
	beforeAddCounter uint64
	AddMock          mOutboxRepositoryMockAdd

	funcMarkCompleted          func(ctx context.Context, id uuid.UUID, sentAt time.Time) (err error)
	funcMarkCompletedOrigin    string
	inspectFuncMarkCompleted   func(ctx context.Context, id uuid.UUID, sentAt time.Time)
	afterMarkCompletedCounter  uint64
	beforeMarkCompletedCounter uint64
	MarkCompletedMock          mOutboxRepositoryMockMarkCompleted

	funcMarkFinalFailed          func(ctx context.Context, id uuid.UUID) (err error)
	funcMarkFinalFailedOrigin    string
	inspectFuncMarkFinalFailed   func(ctx context.Context, id uuid.UUID)
	afterMarkFinalFailedCounter  uint64
	beforeMarkFinalFailedCounter uint64
	MarkFinalFailedMock          mOutboxRepositoryMockMarkFinalFailed

	funcMarkProcessing          func(ctx context.Context, ids []uuid.UUID) (err error)
	funcMarkProcessingOrigin    string
	inspectFuncMarkProcessing   func(ctx context.Context, ids []uuid.UUID)
	afterMarkProcessingCounter  uint64
	beforeMarkProcessingCounter uint64
	MarkProcessingMock          mOutboxRepositoryMockMarkProcessing

	funcMarkRetry          func(ctx context.Context, id uuid.UUID, errMsg string) (err error)
	funcMarkRetryOrigin    string
	inspectFuncMarkRetry   func(ctx context.Context, id uuid.UUID, errMsg string)
	afterMarkRetryCounter  uint64
	beforeMarkRetryCounter uint64
	MarkRetryMock          mOutboxRepositoryMockMarkRetry

	funcPickReadyTx          func(ctx context.Context, limit int) (oa1 []models.OutboxRecord, err error)
	funcPickReadyTxOrigin    string
	inspectFuncPickReadyTx   func(ctx context.Context, limit int)
	afterPickReadyTxCounter  uint64
	beforePickReadyTxCounter uint64
	PickReadyTxMock          mOutboxRepositoryMockPickReadyTx
}

// NewOutboxRepositoryMock returns a mock for mm_usecase.OutboxRepository
func NewOutboxRepositoryMock(t minimock.Tester) *OutboxRepositoryMock {
	m := &OutboxRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMock = mOutboxRepositoryMockAdd{mock: m}
	m.AddMock.callArgs = []*OutboxRepositoryMockAddParams{}

	m.MarkCompletedMock = mOutboxRepositoryMockMarkCompleted{mock: m}
	m.MarkCompletedMock.callArgs = []*OutboxRepositoryMockMarkCompletedParams{}

	m.MarkFinalFailedMock = mOutboxRepositoryMockMarkFinalFailed{mock: m}
	m.MarkFinalFailedMock.callArgs = []*OutboxRepositoryMockMarkFinalFailedParams{}

	m.MarkProcessingMock = mOutboxRepositoryMockMarkProcessing{mock: m}
	m.MarkProcessingMock.callArgs = []*OutboxRepositoryMockMarkProcessingParams{}

	m.MarkRetryMock = mOutboxRepositoryMockMarkRetry{mock: m}
	m.MarkRetryMock.callArgs = []*OutboxRepositoryMockMarkRetryParams{}

	m.PickReadyTxMock = mOutboxRepositoryMockPickReadyTx{mock: m}
	m.PickReadyTxMock.callArgs = []*OutboxRepositoryMockPickReadyTxParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOutboxRepositoryMockAdd struct {
	optional           bool
	mock               *OutboxRepositoryMock
	defaultExpectation *OutboxRepositoryMockAddExpectation
	expectations       []*OutboxRepositoryMockAddExpectation

	callArgs []*OutboxRepositoryMockAddParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutboxRepositoryMockAddExpectation specifies expectation struct of the OutboxRepository.Add
type OutboxRepositoryMockAddExpectation struct {
	mock               *OutboxRepositoryMock
	params             *OutboxRepositoryMockAddParams
	paramPtrs          *OutboxRepositoryMockAddParamPtrs
	expectationOrigins OutboxRepositoryMockAddExpectationOrigins
	results            *OutboxRepositoryMockAddResults
	returnOrigin       string
	Counter            uint64
}

// OutboxRepositoryMockAddParams contains parameters of the OutboxRepository.Add
type OutboxRepositoryMockAddParams struct {
	ctx context.Context
	evt *models.OrderEvent
}

// OutboxRepositoryMockAddParamPtrs contains pointers to parameters of the OutboxRepository.Add
type OutboxRepositoryMockAddParamPtrs struct {
	ctx *context.Context
	evt **models.OrderEvent
}

// OutboxRepositoryMockAddResults contains results of the OutboxRepository.Add
type OutboxRepositoryMockAddResults struct {
	err error
}

// OutboxRepositoryMockAddOrigins contains origins of expectations of the OutboxRepository.Add
type OutboxRepositoryMockAddExpectationOrigins struct {
	origin    string
	originCtx string
	originEvt string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAdd *mOutboxRepositoryMockAdd) Optional() *mOutboxRepositoryMockAdd {
	mmAdd.optional = true
	return mmAdd
}

// Expect sets up expected params for OutboxRepository.Add
func (mmAdd *mOutboxRepositoryMockAdd) Expect(ctx context.Context, evt *models.OrderEvent) *mOutboxRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("OutboxRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &OutboxRepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.paramPtrs != nil {
		mmAdd.mock.t.Fatalf("OutboxRepositoryMock.Add mock is already set by ExpectParams functions")
	}

	mmAdd.defaultExpectation.params = &OutboxRepositoryMockAddParams{ctx, evt}
	mmAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAdd.expectations {
		if minimock.Equal(e.params, mmAdd.defaultExpectation.params) {
			mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
		}
	}

	return mmAdd
}

// ExpectCtxParam1 sets up expected param ctx for OutboxRepository.Add
func (mmAdd *mOutboxRepositoryMockAdd) ExpectCtxParam1(ctx context.Context) *mOutboxRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("OutboxRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &OutboxRepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("OutboxRepositoryMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &OutboxRepositoryMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.ctx = &ctx
	mmAdd.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAdd
}

// ExpectEvtParam2 sets up expected param evt for OutboxRepository.Add
func (mmAdd *mOutboxRepositoryMockAdd) ExpectEvtParam2(evt *models.OrderEvent) *mOutboxRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("OutboxRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &OutboxRepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("OutboxRepositoryMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &OutboxRepositoryMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.evt = &evt
	mmAdd.defaultExpectation.expectationOrigins.originEvt = minimock.CallerInfo(1)

	return mmAdd
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepository.Add
func (mmAdd *mOutboxRepositoryMockAdd) Inspect(f func(ctx context.Context, evt *models.OrderEvent)) *mOutboxRepositoryMockAdd {
	if mmAdd.mock.inspectFuncAdd != nil {
		mmAdd.mock.t.Fatalf("Inspect function is already set for OutboxRepositoryMock.Add")
	}

	mmAdd.mock.inspectFuncAdd = f

	return mmAdd
}

// Return sets up results that will be returned by OutboxRepository.Add
func (mmAdd *mOutboxRepositoryMockAdd) Return(err error) *OutboxRepositoryMock {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("OutboxRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &OutboxRepositoryMockAddExpectation{mock: mmAdd.mock}
	}
	mmAdd.defaultExpectation.results = &OutboxRepositoryMockAddResults{err}
	mmAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAdd.mock
}

// Set uses given function f to mock the OutboxRepository.Add method
func (mmAdd *mOutboxRepositoryMockAdd) Set(f func(ctx context.Context, evt *models.OrderEvent) (err error)) *OutboxRepositoryMock {
	if mmAdd.defaultExpectation != nil {
		mmAdd.mock.t.Fatalf("Default expectation is already set for the OutboxRepository.Add method")
	}

	if len(mmAdd.expectations) > 0 {
		mmAdd.mock.t.Fatalf("Some expectations are already set for the OutboxRepository.Add method")
	}

	mmAdd.mock.funcAdd = f
	mmAdd.mock.funcAddOrigin = minimock.CallerInfo(1)
	return mmAdd.mock
}

// When sets expectation for the OutboxRepository.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mOutboxRepositoryMockAdd) When(ctx context.Context, evt *models.OrderEvent) *OutboxRepositoryMockAddExpectation {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("OutboxRepositoryMock.Add mock is already set by Set")
	}

	expectation := &OutboxRepositoryMockAddExpectation{
		mock:               mmAdd.mock,
		params:             &OutboxRepositoryMockAddParams{ctx, evt},
		expectationOrigins: OutboxRepositoryMockAddExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAdd.expectations = append(mmAdd.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepository.Add return parameters for the expectation previously defined by the When method
func (e *OutboxRepositoryMockAddExpectation) Then(err error) *OutboxRepositoryMock {
	e.results = &OutboxRepositoryMockAddResults{err}
	return e.mock
}

// Times sets number of times OutboxRepository.Add should be invoked
func (mmAdd *mOutboxRepositoryMockAdd) Times(n uint64) *mOutboxRepositoryMockAdd {
	if n == 0 {
		mmAdd.mock.t.Fatalf("Times of OutboxRepositoryMock.Add mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAdd.expectedInvocations, n)
	mmAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAdd
}

func (mmAdd *mOutboxRepositoryMockAdd) invocationsDone() bool {
	if len(mmAdd.expectations) == 0 && mmAdd.defaultExpectation == nil && mmAdd.mock.funcAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAdd.mock.afterAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Add implements mm_usecase.OutboxRepository
func (mmAdd *OutboxRepositoryMock) Add(ctx context.Context, evt *models.OrderEvent) (err error) {
	mm_atomic.AddUint64(&mmAdd.beforeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmAdd.afterAddCounter, 1)

	mmAdd.t.Helper()

	if mmAdd.inspectFuncAdd != nil {
		mmAdd.inspectFuncAdd(ctx, evt)
	}

	mm_params := OutboxRepositoryMockAddParams{ctx, evt}

	// Record call args
	mmAdd.AddMock.mutex.Lock()
	mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, &mm_params)
	mmAdd.AddMock.mutex.Unlock()

	for _, e := range mmAdd.AddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAdd.AddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAdd.AddMock.defaultExpectation.Counter, 1)
		mm_want := mmAdd.AddMock.defaultExpectation.params
		mm_want_ptrs := mmAdd.AddMock.defaultExpectation.paramPtrs

		mm_got := OutboxRepositoryMockAddParams{ctx, evt}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAdd.t.Errorf("OutboxRepositoryMock.Add got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAdd.AddMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.evt != nil && !minimock.Equal(*mm_want_ptrs.evt, mm_got.evt) {
				mmAdd.t.Errorf("OutboxRepositoryMock.Add got unexpected parameter evt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAdd.AddMock.defaultExpectation.expectationOrigins.originEvt, *mm_want_ptrs.evt, mm_got.evt, minimock.Diff(*mm_want_ptrs.evt, mm_got.evt))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAdd.t.Errorf("OutboxRepositoryMock.Add got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAdd.AddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAdd.AddMock.defaultExpectation.results
		if mm_results == nil {
			mmAdd.t.Fatal("No results are set for the OutboxRepositoryMock.Add")
		}
		return (*mm_results).err
	}
	if mmAdd.funcAdd != nil {
		return mmAdd.funcAdd(ctx, evt)
	}
	mmAdd.t.Fatalf("Unexpected call to OutboxRepositoryMock.Add. %v %v", ctx, evt)
	return
}

// AddAfterCounter returns a count of finished OutboxRepositoryMock.Add invocations
func (mmAdd *OutboxRepositoryMock) AddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.afterAddCounter)
}

// AddBeforeCounter returns a count of OutboxRepositoryMock.Add invocations
func (mmAdd *OutboxRepositoryMock) AddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.beforeAddCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepositoryMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mOutboxRepositoryMockAdd) Calls() []*OutboxRepositoryMockAddParams {
	mmAdd.mutex.RLock()

	argCopy := make([]*OutboxRepositoryMockAddParams, len(mmAdd.callArgs))
	copy(argCopy, mmAdd.callArgs)

	mmAdd.mutex.RUnlock()

	return argCopy
}

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *OutboxRepositoryMock) MinimockAddDone() bool {
	if m.AddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddMock.invocationsDone()
}

// MinimockAddInspect logs each unmet expectation
func (m *OutboxRepositoryMock) MinimockAddInspect() {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepositoryMock.Add at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddCounter := mm_atomic.LoadUint64(&m.afterAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && afterAddCounter < 1 {
		if m.AddMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutboxRepositoryMock.Add at\n%s", m.AddMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutboxRepositoryMock.Add at\n%s with params: %#v", m.AddMock.defaultExpectation.expectationOrigins.origin, *m.AddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && afterAddCounter < 1 {
		m.t.Errorf("Expected call to OutboxRepositoryMock.Add at\n%s", m.funcAddOrigin)
	}

	if !m.AddMock.invocationsDone() && afterAddCounter > 0 {
		m.t.Errorf("Expected %d calls to OutboxRepositoryMock.Add at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddMock.expectedInvocations), m.AddMock.expectedInvocationsOrigin, afterAddCounter)
	}
}

type mOutboxRepositoryMockMarkCompleted struct {
	optional           bool
	mock               *OutboxRepositoryMock
	defaultExpectation *OutboxRepositoryMockMarkCompletedExpectation
	expectations       []*OutboxRepositoryMockMarkCompletedExpectation

	callArgs []*OutboxRepositoryMockMarkCompletedParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutboxRepositoryMockMarkCompletedExpectation specifies expectation struct of the OutboxRepository.MarkCompleted
type OutboxRepositoryMockMarkCompletedExpectation struct {
	mock               *OutboxRepositoryMock
	params             *OutboxRepositoryMockMarkCompletedParams
	paramPtrs          *OutboxRepositoryMockMarkCompletedParamPtrs
	expectationOrigins OutboxRepositoryMockMarkCompletedExpectationOrigins
	results            *OutboxRepositoryMockMarkCompletedResults
	returnOrigin       string
	Counter            uint64
}

// OutboxRepositoryMockMarkCompletedParams contains parameters of the OutboxRepository.MarkCompleted
type OutboxRepositoryMockMarkCompletedParams struct {
	ctx    context.Context
	id     uuid.UUID
	sentAt time.Time
}

// OutboxRepositoryMockMarkCompletedParamPtrs contains pointers to parameters of the OutboxRepository.MarkCompleted
type OutboxRepositoryMockMarkCompletedParamPtrs struct {
	ctx    *context.Context
	id     *uuid.UUID
	sentAt *time.Time
}

// OutboxRepositoryMockMarkCompletedResults contains results of the OutboxRepository.MarkCompleted
type OutboxRepositoryMockMarkCompletedResults struct {
	err error
}

// OutboxRepositoryMockMarkCompletedOrigins contains origins of expectations of the OutboxRepository.MarkCompleted
type OutboxRepositoryMockMarkCompletedExpectationOrigins struct {
	origin       string
	originCtx    string
	originId     string
	originSentAt string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMarkCompleted *mOutboxRepositoryMockMarkCompleted) Optional() *mOutboxRepositoryMockMarkCompleted {
	mmMarkCompleted.optional = true
	return mmMarkCompleted
}

// Expect sets up expected params for OutboxRepository.MarkCompleted
func (mmMarkCompleted *mOutboxRepositoryMockMarkCompleted) Expect(ctx context.Context, id uuid.UUID, sentAt time.Time) *mOutboxRepositoryMockMarkCompleted {
	if mmMarkCompleted.mock.funcMarkCompleted != nil {
		mmMarkCompleted.mock.t.Fatalf("OutboxRepositoryMock.MarkCompleted mock is already set by Set")
	}

	if mmMarkCompleted.defaultExpectation == nil {
		mmMarkCompleted.defaultExpectation = &OutboxRepositoryMockMarkCompletedExpectation{}
	}

	if mmMarkCompleted.defaultExpectation.paramPtrs != nil {
		mmMarkCompleted.mock.t.Fatalf("OutboxRepositoryMock.MarkCompleted mock is already set by ExpectParams functions")
	}

	mmMarkCompleted.defaultExpectation.params = &OutboxRepositoryMockMarkCompletedParams{ctx, id, sentAt}
	mmMarkCompleted.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmMarkCompleted.expectations {
		if minimock.Equal(e.params, mmMarkCompleted.defaultExpectation.params) {
			mmMarkCompleted.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMarkCompleted.defaultExpectation.params)
		}
	}

	return mmMarkCompleted
}

// ExpectCtxParam1 sets up expected param ctx for OutboxRepository.MarkCompleted
func (mmMarkCompleted *mOutboxRepositoryMockMarkCompleted) ExpectCtxParam1(ctx context.Context) *mOutboxRepositoryMockMarkCompleted {
	if mmMarkCompleted.mock.funcMarkCompleted != nil {
		mmMarkCompleted.mock.t.Fatalf("OutboxRepositoryMock.MarkCompleted mock is already set by Set")
	}

	if mmMarkCompleted.defaultExpectation == nil {
		mmMarkCompleted.defaultExpectation = &OutboxRepositoryMockMarkCompletedExpectation{}
	}

	if mmMarkCompleted.defaultExpectation.params != nil {
		mmMarkCompleted.mock.t.Fatalf("OutboxRepositoryMock.MarkCompleted mock is already set by Expect")
	}

	if mmMarkCompleted.defaultExpectation.paramPtrs == nil {
		mmMarkCompleted.defaultExpectation.paramPtrs = &OutboxRepositoryMockMarkCompletedParamPtrs{}
	}
	mmMarkCompleted.defaultExpectation.paramPtrs.ctx = &ctx
	mmMarkCompleted.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmMarkCompleted
}

// ExpectIdParam2 sets up expected param id for OutboxRepository.MarkCompleted
func (mmMarkCompleted *mOutboxRepositoryMockMarkCompleted) ExpectIdParam2(id uuid.UUID) *mOutboxRepositoryMockMarkCompleted {
	if mmMarkCompleted.mock.funcMarkCompleted != nil {
		mmMarkCompleted.mock.t.Fatalf("OutboxRepositoryMock.MarkCompleted mock is already set by Set")
	}

	if mmMarkCompleted.defaultExpectation == nil {
		mmMarkCompleted.defaultExpectation = &OutboxRepositoryMockMarkCompletedExpectation{}
	}

	if mmMarkCompleted.defaultExpectation.params != nil {
		mmMarkCompleted.mock.t.Fatalf("OutboxRepositoryMock.MarkCompleted mock is already set by Expect")
	}

	if mmMarkCompleted.defaultExpectation.paramPtrs == nil {
		mmMarkCompleted.defaultExpectation.paramPtrs = &OutboxRepositoryMockMarkCompletedParamPtrs{}
	}
	mmMarkCompleted.defaultExpectation.paramPtrs.id = &id
	mmMarkCompleted.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmMarkCompleted
}

// ExpectSentAtParam3 sets up expected param sentAt for OutboxRepository.MarkCompleted
func (mmMarkCompleted *mOutboxRepositoryMockMarkCompleted) ExpectSentAtParam3(sentAt time.Time) *mOutboxRepositoryMockMarkCompleted {
	if mmMarkCompleted.mock.funcMarkCompleted != nil {
		mmMarkCompleted.mock.t.Fatalf("OutboxRepositoryMock.MarkCompleted mock is already set by Set")
	}

	if mmMarkCompleted.defaultExpectation == nil {
		mmMarkCompleted.defaultExpectation = &OutboxRepositoryMockMarkCompletedExpectation{}
	}

	if mmMarkCompleted.defaultExpectation.params != nil {
		mmMarkCompleted.mock.t.Fatalf("OutboxRepositoryMock.MarkCompleted mock is already set by Expect")
	}

	if mmMarkCompleted.defaultExpectation.paramPtrs == nil {
		mmMarkCompleted.defaultExpectation.paramPtrs = &OutboxRepositoryMockMarkCompletedParamPtrs{}
	}
	mmMarkCompleted.defaultExpectation.paramPtrs.sentAt = &sentAt
	mmMarkCompleted.defaultExpectation.expectationOrigins.originSentAt = minimock.CallerInfo(1)

	return mmMarkCompleted
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepository.MarkCompleted
func (mmMarkCompleted *mOutboxRepositoryMockMarkCompleted) Inspect(f func(ctx context.Context, id uuid.UUID, sentAt time.Time)) *mOutboxRepositoryMockMarkCompleted {
	if mmMarkCompleted.mock.inspectFuncMarkCompleted != nil {
		mmMarkCompleted.mock.t.Fatalf("Inspect function is already set for OutboxRepositoryMock.MarkCompleted")
	}

	mmMarkCompleted.mock.inspectFuncMarkCompleted = f

	return mmMarkCompleted
}

// Return sets up results that will be returned by OutboxRepository.MarkCompleted
func (mmMarkCompleted *mOutboxRepositoryMockMarkCompleted) Return(err error) *OutboxRepositoryMock {
	if mmMarkCompleted.mock.funcMarkCompleted != nil {
		mmMarkCompleted.mock.t.Fatalf("OutboxRepositoryMock.MarkCompleted mock is already set by Set")
	}

	if mmMarkCompleted.defaultExpectation == nil {
		mmMarkCompleted.defaultExpectation = &OutboxRepositoryMockMarkCompletedExpectation{mock: mmMarkCompleted.mock}
	}
	mmMarkCompleted.defaultExpectation.results = &OutboxRepositoryMockMarkCompletedResults{err}
	mmMarkCompleted.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMarkCompleted.mock
}

// Set uses given function f to mock the OutboxRepository.MarkCompleted method
func (mmMarkCompleted *mOutboxRepositoryMockMarkCompleted) Set(f func(ctx context.Context, id uuid.UUID, sentAt time.Time) (err error)) *OutboxRepositoryMock {
	if mmMarkCompleted.defaultExpectation != nil {
		mmMarkCompleted.mock.t.Fatalf("Default expectation is already set for the OutboxRepository.MarkCompleted method")
	}

	if len(mmMarkCompleted.expectations) > 0 {
		mmMarkCompleted.mock.t.Fatalf("Some expectations are already set for the OutboxRepository.MarkCompleted method")
	}

	mmMarkCompleted.mock.funcMarkCompleted = f
	mmMarkCompleted.mock.funcMarkCompletedOrigin = minimock.CallerInfo(1)
	return mmMarkCompleted.mock
}

// When sets expectation for the OutboxRepository.MarkCompleted which will trigger the result defined by the following
// Then helper
func (mmMarkCompleted *mOutboxRepositoryMockMarkCompleted) When(ctx context.Context, id uuid.UUID, sentAt time.Time) *OutboxRepositoryMockMarkCompletedExpectation {
	if mmMarkCompleted.mock.funcMarkCompleted != nil {
		mmMarkCompleted.mock.t.Fatalf("OutboxRepositoryMock.MarkCompleted mock is already set by Set")
	}

	expectation := &OutboxRepositoryMockMarkCompletedExpectation{
		mock:               mmMarkCompleted.mock,
		params:             &OutboxRepositoryMockMarkCompletedParams{ctx, id, sentAt},
		expectationOrigins: OutboxRepositoryMockMarkCompletedExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmMarkCompleted.expectations = append(mmMarkCompleted.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepository.MarkCompleted return parameters for the expectation previously defined by the When method
func (e *OutboxRepositoryMockMarkCompletedExpectation) Then(err error) *OutboxRepositoryMock {
	e.results = &OutboxRepositoryMockMarkCompletedResults{err}
	return e.mock
}

// Times sets number of times OutboxRepository.MarkCompleted should be invoked
func (mmMarkCompleted *mOutboxRepositoryMockMarkCompleted) Times(n uint64) *mOutboxRepositoryMockMarkCompleted {
	if n == 0 {
		mmMarkCompleted.mock.t.Fatalf("Times of OutboxRepositoryMock.MarkCompleted mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMarkCompleted.expectedInvocations, n)
	mmMarkCompleted.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMarkCompleted
}

func (mmMarkCompleted *mOutboxRepositoryMockMarkCompleted) invocationsDone() bool {
	if len(mmMarkCompleted.expectations) == 0 && mmMarkCompleted.defaultExpectation == nil && mmMarkCompleted.mock.funcMarkCompleted == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMarkCompleted.mock.afterMarkCompletedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMarkCompleted.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MarkCompleted implements mm_usecase.OutboxRepository
func (mmMarkCompleted *OutboxRepositoryMock) MarkCompleted(ctx context.Context, id uuid.UUID, sentAt time.Time) (err error) {
	mm_atomic.AddUint64(&mmMarkCompleted.beforeMarkCompletedCounter, 1)
	defer mm_atomic.AddUint64(&mmMarkCompleted.afterMarkCompletedCounter, 1)

	mmMarkCompleted.t.Helper()

	if mmMarkCompleted.inspectFuncMarkCompleted != nil {
		mmMarkCompleted.inspectFuncMarkCompleted(ctx, id, sentAt)
	}

	mm_params := OutboxRepositoryMockMarkCompletedParams{ctx, id, sentAt}

	// Record call args
	mmMarkCompleted.MarkCompletedMock.mutex.Lock()
	mmMarkCompleted.MarkCompletedMock.callArgs = append(mmMarkCompleted.MarkCompletedMock.callArgs, &mm_params)
	mmMarkCompleted.MarkCompletedMock.mutex.Unlock()

	for _, e := range mmMarkCompleted.MarkCompletedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMarkCompleted.MarkCompletedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMarkCompleted.MarkCompletedMock.defaultExpectation.Counter, 1)
		mm_want := mmMarkCompleted.MarkCompletedMock.defaultExpectation.params
		mm_want_ptrs := mmMarkCompleted.MarkCompletedMock.defaultExpectation.paramPtrs

		mm_got := OutboxRepositoryMockMarkCompletedParams{ctx, id, sentAt}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmMarkCompleted.t.Errorf("OutboxRepositoryMock.MarkCompleted got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkCompleted.MarkCompletedMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmMarkCompleted.t.Errorf("OutboxRepositoryMock.MarkCompleted got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkCompleted.MarkCompletedMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.sentAt != nil && !minimock.Equal(*mm_want_ptrs.sentAt, mm_got.sentAt) {
				mmMarkCompleted.t.Errorf("OutboxRepositoryMock.MarkCompleted got unexpected parameter sentAt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkCompleted.MarkCompletedMock.defaultExpectation.expectationOrigins.originSentAt, *mm_want_ptrs.sentAt, mm_got.sentAt, minimock.Diff(*mm_want_ptrs.sentAt, mm_got.sentAt))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMarkCompleted.t.Errorf("OutboxRepositoryMock.MarkCompleted got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmMarkCompleted.MarkCompletedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMarkCompleted.MarkCompletedMock.defaultExpectation.results
		if mm_results == nil {
			mmMarkCompleted.t.Fatal("No results are set for the OutboxRepositoryMock.MarkCompleted")
		}
		return (*mm_results).err
	}
	if mmMarkCompleted.funcMarkCompleted != nil {
		return mmMarkCompleted.funcMarkCompleted(ctx, id, sentAt)
	}
	mmMarkCompleted.t.Fatalf("Unexpected call to OutboxRepositoryMock.MarkCompleted. %v %v %v", ctx, id, sentAt)
	return
}

// MarkCompletedAfterCounter returns a count of finished OutboxRepositoryMock.MarkCompleted invocations
func (mmMarkCompleted *OutboxRepositoryMock) MarkCompletedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkCompleted.afterMarkCompletedCounter)
}

// MarkCompletedBeforeCounter returns a count of OutboxRepositoryMock.MarkCompleted invocations
func (mmMarkCompleted *OutboxRepositoryMock) MarkCompletedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkCompleted.beforeMarkCompletedCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepositoryMock.MarkCompleted.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMarkCompleted *mOutboxRepositoryMockMarkCompleted) Calls() []*OutboxRepositoryMockMarkCompletedParams {
	mmMarkCompleted.mutex.RLock()

	argCopy := make([]*OutboxRepositoryMockMarkCompletedParams, len(mmMarkCompleted.callArgs))
	copy(argCopy, mmMarkCompleted.callArgs)

	mmMarkCompleted.mutex.RUnlock()

	return argCopy
}

// MinimockMarkCompletedDone returns true if the count of the MarkCompleted invocations corresponds
// the number of defined expectations
func (m *OutboxRepositoryMock) MinimockMarkCompletedDone() bool {
	if m.MarkCompletedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MarkCompletedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MarkCompletedMock.invocationsDone()
}

// MinimockMarkCompletedInspect logs each unmet expectation
func (m *OutboxRepositoryMock) MinimockMarkCompletedInspect() {
	for _, e := range m.MarkCompletedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepositoryMock.MarkCompleted at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterMarkCompletedCounter := mm_atomic.LoadUint64(&m.afterMarkCompletedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MarkCompletedMock.defaultExpectation != nil && afterMarkCompletedCounter < 1 {
		if m.MarkCompletedMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutboxRepositoryMock.MarkCompleted at\n%s", m.MarkCompletedMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutboxRepositoryMock.MarkCompleted at\n%s with params: %#v", m.MarkCompletedMock.defaultExpectation.expectationOrigins.origin, *m.MarkCompletedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarkCompleted != nil && afterMarkCompletedCounter < 1 {
		m.t.Errorf("Expected call to OutboxRepositoryMock.MarkCompleted at\n%s", m.funcMarkCompletedOrigin)
	}

	if !m.MarkCompletedMock.invocationsDone() && afterMarkCompletedCounter > 0 {
		m.t.Errorf("Expected %d calls to OutboxRepositoryMock.MarkCompleted at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MarkCompletedMock.expectedInvocations), m.MarkCompletedMock.expectedInvocationsOrigin, afterMarkCompletedCounter)
	}
}

type mOutboxRepositoryMockMarkFinalFailed struct {
	optional           bool
	mock               *OutboxRepositoryMock
	defaultExpectation *OutboxRepositoryMockMarkFinalFailedExpectation
	expectations       []*OutboxRepositoryMockMarkFinalFailedExpectation

	callArgs []*OutboxRepositoryMockMarkFinalFailedParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutboxRepositoryMockMarkFinalFailedExpectation specifies expectation struct of the OutboxRepository.MarkFinalFailed
type OutboxRepositoryMockMarkFinalFailedExpectation struct {
	mock               *OutboxRepositoryMock
	params             *OutboxRepositoryMockMarkFinalFailedParams
	paramPtrs          *OutboxRepositoryMockMarkFinalFailedParamPtrs
	expectationOrigins OutboxRepositoryMockMarkFinalFailedExpectationOrigins
	results            *OutboxRepositoryMockMarkFinalFailedResults
	returnOrigin       string
	Counter            uint64
}

// OutboxRepositoryMockMarkFinalFailedParams contains parameters of the OutboxRepository.MarkFinalFailed
type OutboxRepositoryMockMarkFinalFailedParams struct {
	ctx context.Context
	id  uuid.UUID
}

// OutboxRepositoryMockMarkFinalFailedParamPtrs contains pointers to parameters of the OutboxRepository.MarkFinalFailed
type OutboxRepositoryMockMarkFinalFailedParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// OutboxRepositoryMockMarkFinalFailedResults contains results of the OutboxRepository.MarkFinalFailed
type OutboxRepositoryMockMarkFinalFailedResults struct {
	err error
}

// OutboxRepositoryMockMarkFinalFailedOrigins contains origins of expectations of the OutboxRepository.MarkFinalFailed
type OutboxRepositoryMockMarkFinalFailedExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMarkFinalFailed *mOutboxRepositoryMockMarkFinalFailed) Optional() *mOutboxRepositoryMockMarkFinalFailed {
	mmMarkFinalFailed.optional = true
	return mmMarkFinalFailed
}

// Expect sets up expected params for OutboxRepository.MarkFinalFailed
func (mmMarkFinalFailed *mOutboxRepositoryMockMarkFinalFailed) Expect(ctx context.Context, id uuid.UUID) *mOutboxRepositoryMockMarkFinalFailed {
	if mmMarkFinalFailed.mock.funcMarkFinalFailed != nil {
		mmMarkFinalFailed.mock.t.Fatalf("OutboxRepositoryMock.MarkFinalFailed mock is already set by Set")
	}

	if mmMarkFinalFailed.defaultExpectation == nil {
		mmMarkFinalFailed.defaultExpectation = &OutboxRepositoryMockMarkFinalFailedExpectation{}
	}

	if mmMarkFinalFailed.defaultExpectation.paramPtrs != nil {
		mmMarkFinalFailed.mock.t.Fatalf("OutboxRepositoryMock.MarkFinalFailed mock is already set by ExpectParams functions")
	}

	mmMarkFinalFailed.defaultExpectation.params = &OutboxRepositoryMockMarkFinalFailedParams{ctx, id}
	mmMarkFinalFailed.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmMarkFinalFailed.expectations {
		if minimock.Equal(e.params, mmMarkFinalFailed.defaultExpectation.params) {
			mmMarkFinalFailed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMarkFinalFailed.defaultExpectation.params)
		}
	}

	return mmMarkFinalFailed
}

// ExpectCtxParam1 sets up expected param ctx for OutboxRepository.MarkFinalFailed
func (mmMarkFinalFailed *mOutboxRepositoryMockMarkFinalFailed) ExpectCtxParam1(ctx context.Context) *mOutboxRepositoryMockMarkFinalFailed {
	if mmMarkFinalFailed.mock.funcMarkFinalFailed != nil {
		mmMarkFinalFailed.mock.t.Fatalf("OutboxRepositoryMock.MarkFinalFailed mock is already set by Set")
	}

	if mmMarkFinalFailed.defaultExpectation == nil {
		mmMarkFinalFailed.defaultExpectation = &OutboxRepositoryMockMarkFinalFailedExpectation{}
	}

	if mmMarkFinalFailed.defaultExpectation.params != nil {
		mmMarkFinalFailed.mock.t.Fatalf("OutboxRepositoryMock.MarkFinalFailed mock is already set by Expect")
	}

	if mmMarkFinalFailed.defaultExpectation.paramPtrs == nil {
		mmMarkFinalFailed.defaultExpectation.paramPtrs = &OutboxRepositoryMockMarkFinalFailedParamPtrs{}
	}
	mmMarkFinalFailed.defaultExpectation.paramPtrs.ctx = &ctx
	mmMarkFinalFailed.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmMarkFinalFailed
}

// ExpectIdParam2 sets up expected param id for OutboxRepository.MarkFinalFailed
func (mmMarkFinalFailed *mOutboxRepositoryMockMarkFinalFailed) ExpectIdParam2(id uuid.UUID) *mOutboxRepositoryMockMarkFinalFailed {
	if mmMarkFinalFailed.mock.funcMarkFinalFailed != nil {
		mmMarkFinalFailed.mock.t.Fatalf("OutboxRepositoryMock.MarkFinalFailed mock is already set by Set")
	}

	if mmMarkFinalFailed.defaultExpectation == nil {
		mmMarkFinalFailed.defaultExpectation = &OutboxRepositoryMockMarkFinalFailedExpectation{}
	}

	if mmMarkFinalFailed.defaultExpectation.params != nil {
		mmMarkFinalFailed.mock.t.Fatalf("OutboxRepositoryMock.MarkFinalFailed mock is already set by Expect")
	}

	if mmMarkFinalFailed.defaultExpectation.paramPtrs == nil {
		mmMarkFinalFailed.defaultExpectation.paramPtrs = &OutboxRepositoryMockMarkFinalFailedParamPtrs{}
	}
	mmMarkFinalFailed.defaultExpectation.paramPtrs.id = &id
	mmMarkFinalFailed.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmMarkFinalFailed
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepository.MarkFinalFailed
func (mmMarkFinalFailed *mOutboxRepositoryMockMarkFinalFailed) Inspect(f func(ctx context.Context, id uuid.UUID)) *mOutboxRepositoryMockMarkFinalFailed {
	if mmMarkFinalFailed.mock.inspectFuncMarkFinalFailed != nil {
		mmMarkFinalFailed.mock.t.Fatalf("Inspect function is already set for OutboxRepositoryMock.MarkFinalFailed")
	}

	mmMarkFinalFailed.mock.inspectFuncMarkFinalFailed = f

	return mmMarkFinalFailed
}

// Return sets up results that will be returned by OutboxRepository.MarkFinalFailed
func (mmMarkFinalFailed *mOutboxRepositoryMockMarkFinalFailed) Return(err error) *OutboxRepositoryMock {
	if mmMarkFinalFailed.mock.funcMarkFinalFailed != nil {
		mmMarkFinalFailed.mock.t.Fatalf("OutboxRepositoryMock.MarkFinalFailed mock is already set by Set")
	}

	if mmMarkFinalFailed.defaultExpectation == nil {
		mmMarkFinalFailed.defaultExpectation = &OutboxRepositoryMockMarkFinalFailedExpectation{mock: mmMarkFinalFailed.mock}
	}
	mmMarkFinalFailed.defaultExpectation.results = &OutboxRepositoryMockMarkFinalFailedResults{err}
	mmMarkFinalFailed.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMarkFinalFailed.mock
}

// Set uses given function f to mock the OutboxRepository.MarkFinalFailed method
func (mmMarkFinalFailed *mOutboxRepositoryMockMarkFinalFailed) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *OutboxRepositoryMock {
	if mmMarkFinalFailed.defaultExpectation != nil {
		mmMarkFinalFailed.mock.t.Fatalf("Default expectation is already set for the OutboxRepository.MarkFinalFailed method")
	}

	if len(mmMarkFinalFailed.expectations) > 0 {
		mmMarkFinalFailed.mock.t.Fatalf("Some expectations are already set for the OutboxRepository.MarkFinalFailed method")
	}

	mmMarkFinalFailed.mock.funcMarkFinalFailed = f
	mmMarkFinalFailed.mock.funcMarkFinalFailedOrigin = minimock.CallerInfo(1)
	return mmMarkFinalFailed.mock
}

// When sets expectation for the OutboxRepository.MarkFinalFailed which will trigger the result defined by the following
// Then helper
func (mmMarkFinalFailed *mOutboxRepositoryMockMarkFinalFailed) When(ctx context.Context, id uuid.UUID) *OutboxRepositoryMockMarkFinalFailedExpectation {
	if mmMarkFinalFailed.mock.funcMarkFinalFailed != nil {
		mmMarkFinalFailed.mock.t.Fatalf("OutboxRepositoryMock.MarkFinalFailed mock is already set by Set")
	}

	expectation := &OutboxRepositoryMockMarkFinalFailedExpectation{
		mock:               mmMarkFinalFailed.mock,
		params:             &OutboxRepositoryMockMarkFinalFailedParams{ctx, id},
		expectationOrigins: OutboxRepositoryMockMarkFinalFailedExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmMarkFinalFailed.expectations = append(mmMarkFinalFailed.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepository.MarkFinalFailed return parameters for the expectation previously defined by the When method
func (e *OutboxRepositoryMockMarkFinalFailedExpectation) Then(err error) *OutboxRepositoryMock {
	e.results = &OutboxRepositoryMockMarkFinalFailedResults{err}
	return e.mock
}

// Times sets number of times OutboxRepository.MarkFinalFailed should be invoked
func (mmMarkFinalFailed *mOutboxRepositoryMockMarkFinalFailed) Times(n uint64) *mOutboxRepositoryMockMarkFinalFailed {
	if n == 0 {
		mmMarkFinalFailed.mock.t.Fatalf("Times of OutboxRepositoryMock.MarkFinalFailed mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMarkFinalFailed.expectedInvocations, n)
	mmMarkFinalFailed.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMarkFinalFailed
}

func (mmMarkFinalFailed *mOutboxRepositoryMockMarkFinalFailed) invocationsDone() bool {
	if len(mmMarkFinalFailed.expectations) == 0 && mmMarkFinalFailed.defaultExpectation == nil && mmMarkFinalFailed.mock.funcMarkFinalFailed == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMarkFinalFailed.mock.afterMarkFinalFailedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMarkFinalFailed.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MarkFinalFailed implements mm_usecase.OutboxRepository
func (mmMarkFinalFailed *OutboxRepositoryMock) MarkFinalFailed(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmMarkFinalFailed.beforeMarkFinalFailedCounter, 1)
	defer mm_atomic.AddUint64(&mmMarkFinalFailed.afterMarkFinalFailedCounter, 1)

	mmMarkFinalFailed.t.Helper()

	if mmMarkFinalFailed.inspectFuncMarkFinalFailed != nil {
		mmMarkFinalFailed.inspectFuncMarkFinalFailed(ctx, id)
	}

	mm_params := OutboxRepositoryMockMarkFinalFailedParams{ctx, id}

	// Record call args
	mmMarkFinalFailed.MarkFinalFailedMock.mutex.Lock()
	mmMarkFinalFailed.MarkFinalFailedMock.callArgs = append(mmMarkFinalFailed.MarkFinalFailedMock.callArgs, &mm_params)
	mmMarkFinalFailed.MarkFinalFailedMock.mutex.Unlock()

	for _, e := range mmMarkFinalFailed.MarkFinalFailedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMarkFinalFailed.MarkFinalFailedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMarkFinalFailed.MarkFinalFailedMock.defaultExpectation.Counter, 1)
		mm_want := mmMarkFinalFailed.MarkFinalFailedMock.defaultExpectation.params
		mm_want_ptrs := mmMarkFinalFailed.MarkFinalFailedMock.defaultExpectation.paramPtrs

		mm_got := OutboxRepositoryMockMarkFinalFailedParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmMarkFinalFailed.t.Errorf("OutboxRepositoryMock.MarkFinalFailed got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkFinalFailed.MarkFinalFailedMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmMarkFinalFailed.t.Errorf("OutboxRepositoryMock.MarkFinalFailed got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkFinalFailed.MarkFinalFailedMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMarkFinalFailed.t.Errorf("OutboxRepositoryMock.MarkFinalFailed got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmMarkFinalFailed.MarkFinalFailedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMarkFinalFailed.MarkFinalFailedMock.defaultExpectation.results
		if mm_results == nil {
			mmMarkFinalFailed.t.Fatal("No results are set for the OutboxRepositoryMock.MarkFinalFailed")
		}
		return (*mm_results).err
	}
	if mmMarkFinalFailed.funcMarkFinalFailed != nil {
		return mmMarkFinalFailed.funcMarkFinalFailed(ctx, id)
	}
	mmMarkFinalFailed.t.Fatalf("Unexpected call to OutboxRepositoryMock.MarkFinalFailed. %v %v", ctx, id)
	return
}

// MarkFinalFailedAfterCounter returns a count of finished OutboxRepositoryMock.MarkFinalFailed invocations
func (mmMarkFinalFailed *OutboxRepositoryMock) MarkFinalFailedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkFinalFailed.afterMarkFinalFailedCounter)
}

// MarkFinalFailedBeforeCounter returns a count of OutboxRepositoryMock.MarkFinalFailed invocations
func (mmMarkFinalFailed *OutboxRepositoryMock) MarkFinalFailedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkFinalFailed.beforeMarkFinalFailedCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepositoryMock.MarkFinalFailed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMarkFinalFailed *mOutboxRepositoryMockMarkFinalFailed) Calls() []*OutboxRepositoryMockMarkFinalFailedParams {
	mmMarkFinalFailed.mutex.RLock()

	argCopy := make([]*OutboxRepositoryMockMarkFinalFailedParams, len(mmMarkFinalFailed.callArgs))
	copy(argCopy, mmMarkFinalFailed.callArgs)

	mmMarkFinalFailed.mutex.RUnlock()

	return argCopy
}

// MinimockMarkFinalFailedDone returns true if the count of the MarkFinalFailed invocations corresponds
// the number of defined expectations
func (m *OutboxRepositoryMock) MinimockMarkFinalFailedDone() bool {
	if m.MarkFinalFailedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MarkFinalFailedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MarkFinalFailedMock.invocationsDone()
}

// MinimockMarkFinalFailedInspect logs each unmet expectation
func (m *OutboxRepositoryMock) MinimockMarkFinalFailedInspect() {
	for _, e := range m.MarkFinalFailedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepositoryMock.MarkFinalFailed at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterMarkFinalFailedCounter := mm_atomic.LoadUint64(&m.afterMarkFinalFailedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MarkFinalFailedMock.defaultExpectation != nil && afterMarkFinalFailedCounter < 1 {
		if m.MarkFinalFailedMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutboxRepositoryMock.MarkFinalFailed at\n%s", m.MarkFinalFailedMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutboxRepositoryMock.MarkFinalFailed at\n%s with params: %#v", m.MarkFinalFailedMock.defaultExpectation.expectationOrigins.origin, *m.MarkFinalFailedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarkFinalFailed != nil && afterMarkFinalFailedCounter < 1 {
		m.t.Errorf("Expected call to OutboxRepositoryMock.MarkFinalFailed at\n%s", m.funcMarkFinalFailedOrigin)
	}

	if !m.MarkFinalFailedMock.invocationsDone() && afterMarkFinalFailedCounter > 0 {
		m.t.Errorf("Expected %d calls to OutboxRepositoryMock.MarkFinalFailed at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MarkFinalFailedMock.expectedInvocations), m.MarkFinalFailedMock.expectedInvocationsOrigin, afterMarkFinalFailedCounter)
	}
}

type mOutboxRepositoryMockMarkProcessing struct {
	optional           bool
	mock               *OutboxRepositoryMock
	defaultExpectation *OutboxRepositoryMockMarkProcessingExpectation
	expectations       []*OutboxRepositoryMockMarkProcessingExpectation

	callArgs []*OutboxRepositoryMockMarkProcessingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutboxRepositoryMockMarkProcessingExpectation specifies expectation struct of the OutboxRepository.MarkProcessing
type OutboxRepositoryMockMarkProcessingExpectation struct {
	mock               *OutboxRepositoryMock
	params             *OutboxRepositoryMockMarkProcessingParams
	paramPtrs          *OutboxRepositoryMockMarkProcessingParamPtrs
	expectationOrigins OutboxRepositoryMockMarkProcessingExpectationOrigins
	results            *OutboxRepositoryMockMarkProcessingResults
	returnOrigin       string
	Counter            uint64
}

// OutboxRepositoryMockMarkProcessingParams contains parameters of the OutboxRepository.MarkProcessing
type OutboxRepositoryMockMarkProcessingParams struct {
	ctx context.Context
	ids []uuid.UUID
}

// OutboxRepositoryMockMarkProcessingParamPtrs contains pointers to parameters of the OutboxRepository.MarkProcessing
type OutboxRepositoryMockMarkProcessingParamPtrs struct {
	ctx *context.Context
	ids *[]uuid.UUID
}

// OutboxRepositoryMockMarkProcessingResults contains results of the OutboxRepository.MarkProcessing
type OutboxRepositoryMockMarkProcessingResults struct {
	err error
}

// OutboxRepositoryMockMarkProcessingOrigins contains origins of expectations of the OutboxRepository.MarkProcessing
type OutboxRepositoryMockMarkProcessingExpectationOrigins struct {
	origin    string
	originCtx string
	originIds string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMarkProcessing *mOutboxRepositoryMockMarkProcessing) Optional() *mOutboxRepositoryMockMarkProcessing {
	mmMarkProcessing.optional = true
	return mmMarkProcessing
}

// Expect sets up expected params for OutboxRepository.MarkProcessing
func (mmMarkProcessing *mOutboxRepositoryMockMarkProcessing) Expect(ctx context.Context, ids []uuid.UUID) *mOutboxRepositoryMockMarkProcessing {
	if mmMarkProcessing.mock.funcMarkProcessing != nil {
		mmMarkProcessing.mock.t.Fatalf("OutboxRepositoryMock.MarkProcessing mock is already set by Set")
	}

	if mmMarkProcessing.defaultExpectation == nil {
		mmMarkProcessing.defaultExpectation = &OutboxRepositoryMockMarkProcessingExpectation{}
	}

	if mmMarkProcessing.defaultExpectation.paramPtrs != nil {
		mmMarkProcessing.mock.t.Fatalf("OutboxRepositoryMock.MarkProcessing mock is already set by ExpectParams functions")
	}

	mmMarkProcessing.defaultExpectation.params = &OutboxRepositoryMockMarkProcessingParams{ctx, ids}
	mmMarkProcessing.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmMarkProcessing.expectations {
		if minimock.Equal(e.params, mmMarkProcessing.defaultExpectation.params) {
			mmMarkProcessing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMarkProcessing.defaultExpectation.params)
		}
	}

	return mmMarkProcessing
}

// ExpectCtxParam1 sets up expected param ctx for OutboxRepository.MarkProcessing
func (mmMarkProcessing *mOutboxRepositoryMockMarkProcessing) ExpectCtxParam1(ctx context.Context) *mOutboxRepositoryMockMarkProcessing {
	if mmMarkProcessing.mock.funcMarkProcessing != nil {
		mmMarkProcessing.mock.t.Fatalf("OutboxRepositoryMock.MarkProcessing mock is already set by Set")
	}

	if mmMarkProcessing.defaultExpectation == nil {
		mmMarkProcessing.defaultExpectation = &OutboxRepositoryMockMarkProcessingExpectation{}
	}

	if mmMarkProcessing.defaultExpectation.params != nil {
		mmMarkProcessing.mock.t.Fatalf("OutboxRepositoryMock.MarkProcessing mock is already set by Expect")
	}

	if mmMarkProcessing.defaultExpectation.paramPtrs == nil {
		mmMarkProcessing.defaultExpectation.paramPtrs = &OutboxRepositoryMockMarkProcessingParamPtrs{}
	}
	mmMarkProcessing.defaultExpectation.paramPtrs.ctx = &ctx
	mmMarkProcessing.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmMarkProcessing
}

// ExpectIdsParam2 sets up expected param ids for OutboxRepository.MarkProcessing
func (mmMarkProcessing *mOutboxRepositoryMockMarkProcessing) ExpectIdsParam2(ids []uuid.UUID) *mOutboxRepositoryMockMarkProcessing {
	if mmMarkProcessing.mock.funcMarkProcessing != nil {
		mmMarkProcessing.mock.t.Fatalf("OutboxRepositoryMock.MarkProcessing mock is already set by Set")
	}

	if mmMarkProcessing.defaultExpectation == nil {
		mmMarkProcessing.defaultExpectation = &OutboxRepositoryMockMarkProcessingExpectation{}
	}

	if mmMarkProcessing.defaultExpectation.params != nil {
		mmMarkProcessing.mock.t.Fatalf("OutboxRepositoryMock.MarkProcessing mock is already set by Expect")
	}

	if mmMarkProcessing.defaultExpectation.paramPtrs == nil {
		mmMarkProcessing.defaultExpectation.paramPtrs = &OutboxRepositoryMockMarkProcessingParamPtrs{}
	}
	mmMarkProcessing.defaultExpectation.paramPtrs.ids = &ids
	mmMarkProcessing.defaultExpectation.expectationOrigins.originIds = minimock.CallerInfo(1)

	return mmMarkProcessing
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepository.MarkProcessing
func (mmMarkProcessing *mOutboxRepositoryMockMarkProcessing) Inspect(f func(ctx context.Context, ids []uuid.UUID)) *mOutboxRepositoryMockMarkProcessing {
	if mmMarkProcessing.mock.inspectFuncMarkProcessing != nil {
		mmMarkProcessing.mock.t.Fatalf("Inspect function is already set for OutboxRepositoryMock.MarkProcessing")
	}

	mmMarkProcessing.mock.inspectFuncMarkProcessing = f

	return mmMarkProcessing
}

// Return sets up results that will be returned by OutboxRepository.MarkProcessing
func (mmMarkProcessing *mOutboxRepositoryMockMarkProcessing) Return(err error) *OutboxRepositoryMock {
	if mmMarkProcessing.mock.funcMarkProcessing != nil {
		mmMarkProcessing.mock.t.Fatalf("OutboxRepositoryMock.MarkProcessing mock is already set by Set")
	}

	if mmMarkProcessing.defaultExpectation == nil {
		mmMarkProcessing.defaultExpectation = &OutboxRepositoryMockMarkProcessingExpectation{mock: mmMarkProcessing.mock}
	}
	mmMarkProcessing.defaultExpectation.results = &OutboxRepositoryMockMarkProcessingResults{err}
	mmMarkProcessing.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMarkProcessing.mock
}

// Set uses given function f to mock the OutboxRepository.MarkProcessing method
func (mmMarkProcessing *mOutboxRepositoryMockMarkProcessing) Set(f func(ctx context.Context, ids []uuid.UUID) (err error)) *OutboxRepositoryMock {
	if mmMarkProcessing.defaultExpectation != nil {
		mmMarkProcessing.mock.t.Fatalf("Default expectation is already set for the OutboxRepository.MarkProcessing method")
	}

	if len(mmMarkProcessing.expectations) > 0 {
		mmMarkProcessing.mock.t.Fatalf("Some expectations are already set for the OutboxRepository.MarkProcessing method")
	}

	mmMarkProcessing.mock.funcMarkProcessing = f
	mmMarkProcessing.mock.funcMarkProcessingOrigin = minimock.CallerInfo(1)
	return mmMarkProcessing.mock
}

// When sets expectation for the OutboxRepository.MarkProcessing which will trigger the result defined by the following
// Then helper
func (mmMarkProcessing *mOutboxRepositoryMockMarkProcessing) When(ctx context.Context, ids []uuid.UUID) *OutboxRepositoryMockMarkProcessingExpectation {
	if mmMarkProcessing.mock.funcMarkProcessing != nil {
		mmMarkProcessing.mock.t.Fatalf("OutboxRepositoryMock.MarkProcessing mock is already set by Set")
	}

	expectation := &OutboxRepositoryMockMarkProcessingExpectation{
		mock:               mmMarkProcessing.mock,
		params:             &OutboxRepositoryMockMarkProcessingParams{ctx, ids},
		expectationOrigins: OutboxRepositoryMockMarkProcessingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmMarkProcessing.expectations = append(mmMarkProcessing.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepository.MarkProcessing return parameters for the expectation previously defined by the When method
func (e *OutboxRepositoryMockMarkProcessingExpectation) Then(err error) *OutboxRepositoryMock {
	e.results = &OutboxRepositoryMockMarkProcessingResults{err}
	return e.mock
}

// Times sets number of times OutboxRepository.MarkProcessing should be invoked
func (mmMarkProcessing *mOutboxRepositoryMockMarkProcessing) Times(n uint64) *mOutboxRepositoryMockMarkProcessing {
	if n == 0 {
		mmMarkProcessing.mock.t.Fatalf("Times of OutboxRepositoryMock.MarkProcessing mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMarkProcessing.expectedInvocations, n)
	mmMarkProcessing.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMarkProcessing
}

func (mmMarkProcessing *mOutboxRepositoryMockMarkProcessing) invocationsDone() bool {
	if len(mmMarkProcessing.expectations) == 0 && mmMarkProcessing.defaultExpectation == nil && mmMarkProcessing.mock.funcMarkProcessing == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMarkProcessing.mock.afterMarkProcessingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMarkProcessing.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MarkProcessing implements mm_usecase.OutboxRepository
func (mmMarkProcessing *OutboxRepositoryMock) MarkProcessing(ctx context.Context, ids []uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmMarkProcessing.beforeMarkProcessingCounter, 1)
	defer mm_atomic.AddUint64(&mmMarkProcessing.afterMarkProcessingCounter, 1)

	mmMarkProcessing.t.Helper()

	if mmMarkProcessing.inspectFuncMarkProcessing != nil {
		mmMarkProcessing.inspectFuncMarkProcessing(ctx, ids)
	}

	mm_params := OutboxRepositoryMockMarkProcessingParams{ctx, ids}

	// Record call args
	mmMarkProcessing.MarkProcessingMock.mutex.Lock()
	mmMarkProcessing.MarkProcessingMock.callArgs = append(mmMarkProcessing.MarkProcessingMock.callArgs, &mm_params)
	mmMarkProcessing.MarkProcessingMock.mutex.Unlock()

	for _, e := range mmMarkProcessing.MarkProcessingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMarkProcessing.MarkProcessingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMarkProcessing.MarkProcessingMock.defaultExpectation.Counter, 1)
		mm_want := mmMarkProcessing.MarkProcessingMock.defaultExpectation.params
		mm_want_ptrs := mmMarkProcessing.MarkProcessingMock.defaultExpectation.paramPtrs

		mm_got := OutboxRepositoryMockMarkProcessingParams{ctx, ids}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmMarkProcessing.t.Errorf("OutboxRepositoryMock.MarkProcessing got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkProcessing.MarkProcessingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ids != nil && !minimock.Equal(*mm_want_ptrs.ids, mm_got.ids) {
				mmMarkProcessing.t.Errorf("OutboxRepositoryMock.MarkProcessing got unexpected parameter ids, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkProcessing.MarkProcessingMock.defaultExpectation.expectationOrigins.originIds, *mm_want_ptrs.ids, mm_got.ids, minimock.Diff(*mm_want_ptrs.ids, mm_got.ids))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMarkProcessing.t.Errorf("OutboxRepositoryMock.MarkProcessing got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmMarkProcessing.MarkProcessingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMarkProcessing.MarkProcessingMock.defaultExpectation.results
		if mm_results == nil {
			mmMarkProcessing.t.Fatal("No results are set for the OutboxRepositoryMock.MarkProcessing")
		}
		return (*mm_results).err
	}
	if mmMarkProcessing.funcMarkProcessing != nil {
		return mmMarkProcessing.funcMarkProcessing(ctx, ids)
	}
	mmMarkProcessing.t.Fatalf("Unexpected call to OutboxRepositoryMock.MarkProcessing. %v %v", ctx, ids)
	return
}

// MarkProcessingAfterCounter returns a count of finished OutboxRepositoryMock.MarkProcessing invocations
func (mmMarkProcessing *OutboxRepositoryMock) MarkProcessingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkProcessing.afterMarkProcessingCounter)
}

// MarkProcessingBeforeCounter returns a count of OutboxRepositoryMock.MarkProcessing invocations
func (mmMarkProcessing *OutboxRepositoryMock) MarkProcessingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkProcessing.beforeMarkProcessingCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepositoryMock.MarkProcessing.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMarkProcessing *mOutboxRepositoryMockMarkProcessing) Calls() []*OutboxRepositoryMockMarkProcessingParams {
	mmMarkProcessing.mutex.RLock()

	argCopy := make([]*OutboxRepositoryMockMarkProcessingParams, len(mmMarkProcessing.callArgs))
	copy(argCopy, mmMarkProcessing.callArgs)

	mmMarkProcessing.mutex.RUnlock()

	return argCopy
}

// MinimockMarkProcessingDone returns true if the count of the MarkProcessing invocations corresponds
// the number of defined expectations
func (m *OutboxRepositoryMock) MinimockMarkProcessingDone() bool {
	if m.MarkProcessingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MarkProcessingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MarkProcessingMock.invocationsDone()
}

// MinimockMarkProcessingInspect logs each unmet expectation
func (m *OutboxRepositoryMock) MinimockMarkProcessingInspect() {
	for _, e := range m.MarkProcessingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepositoryMock.MarkProcessing at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterMarkProcessingCounter := mm_atomic.LoadUint64(&m.afterMarkProcessingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MarkProcessingMock.defaultExpectation != nil && afterMarkProcessingCounter < 1 {
		if m.MarkProcessingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutboxRepositoryMock.MarkProcessing at\n%s", m.MarkProcessingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutboxRepositoryMock.MarkProcessing at\n%s with params: %#v", m.MarkProcessingMock.defaultExpectation.expectationOrigins.origin, *m.MarkProcessingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarkProcessing != nil && afterMarkProcessingCounter < 1 {
		m.t.Errorf("Expected call to OutboxRepositoryMock.MarkProcessing at\n%s", m.funcMarkProcessingOrigin)
	}

	if !m.MarkProcessingMock.invocationsDone() && afterMarkProcessingCounter > 0 {
		m.t.Errorf("Expected %d calls to OutboxRepositoryMock.MarkProcessing at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MarkProcessingMock.expectedInvocations), m.MarkProcessingMock.expectedInvocationsOrigin, afterMarkProcessingCounter)
	}
}

type mOutboxRepositoryMockMarkRetry struct {
	optional           bool
	mock               *OutboxRepositoryMock
	defaultExpectation *OutboxRepositoryMockMarkRetryExpectation
	expectations       []*OutboxRepositoryMockMarkRetryExpectation

	callArgs []*OutboxRepositoryMockMarkRetryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutboxRepositoryMockMarkRetryExpectation specifies expectation struct of the OutboxRepository.MarkRetry
type OutboxRepositoryMockMarkRetryExpectation struct {
	mock               *OutboxRepositoryMock
	params             *OutboxRepositoryMockMarkRetryParams
	paramPtrs          *OutboxRepositoryMockMarkRetryParamPtrs
	expectationOrigins OutboxRepositoryMockMarkRetryExpectationOrigins
	results            *OutboxRepositoryMockMarkRetryResults
	returnOrigin       string
	Counter            uint64
}

// OutboxRepositoryMockMarkRetryParams contains parameters of the OutboxRepository.MarkRetry
type OutboxRepositoryMockMarkRetryParams struct {
	ctx    context.Context
	id     uuid.UUID
	errMsg string
}

// OutboxRepositoryMockMarkRetryParamPtrs contains pointers to parameters of the OutboxRepository.MarkRetry
type OutboxRepositoryMockMarkRetryParamPtrs struct {
	ctx    *context.Context
	id     *uuid.UUID
	errMsg *string
}

// OutboxRepositoryMockMarkRetryResults contains results of the OutboxRepository.MarkRetry
type OutboxRepositoryMockMarkRetryResults struct {
	err error
}

// OutboxRepositoryMockMarkRetryOrigins contains origins of expectations of the OutboxRepository.MarkRetry
type OutboxRepositoryMockMarkRetryExpectationOrigins struct {
	origin       string
	originCtx    string
	originId     string
	originErrMsg string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMarkRetry *mOutboxRepositoryMockMarkRetry) Optional() *mOutboxRepositoryMockMarkRetry {
	mmMarkRetry.optional = true
	return mmMarkRetry
}

// Expect sets up expected params for OutboxRepository.MarkRetry
func (mmMarkRetry *mOutboxRepositoryMockMarkRetry) Expect(ctx context.Context, id uuid.UUID, errMsg string) *mOutboxRepositoryMockMarkRetry {
	if mmMarkRetry.mock.funcMarkRetry != nil {
		mmMarkRetry.mock.t.Fatalf("OutboxRepositoryMock.MarkRetry mock is already set by Set")
	}

	if mmMarkRetry.defaultExpectation == nil {
		mmMarkRetry.defaultExpectation = &OutboxRepositoryMockMarkRetryExpectation{}
	}

	if mmMarkRetry.defaultExpectation.paramPtrs != nil {
		mmMarkRetry.mock.t.Fatalf("OutboxRepositoryMock.MarkRetry mock is already set by ExpectParams functions")
	}

	mmMarkRetry.defaultExpectation.params = &OutboxRepositoryMockMarkRetryParams{ctx, id, errMsg}
	mmMarkRetry.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmMarkRetry.expectations {
		if minimock.Equal(e.params, mmMarkRetry.defaultExpectation.params) {
			mmMarkRetry.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMarkRetry.defaultExpectation.params)
		}
	}

	return mmMarkRetry
}

// ExpectCtxParam1 sets up expected param ctx for OutboxRepository.MarkRetry
func (mmMarkRetry *mOutboxRepositoryMockMarkRetry) ExpectCtxParam1(ctx context.Context) *mOutboxRepositoryMockMarkRetry {
	if mmMarkRetry.mock.funcMarkRetry != nil {
		mmMarkRetry.mock.t.Fatalf("OutboxRepositoryMock.MarkRetry mock is already set by Set")
	}

	if mmMarkRetry.defaultExpectation == nil {
		mmMarkRetry.defaultExpectation = &OutboxRepositoryMockMarkRetryExpectation{}
	}

	if mmMarkRetry.defaultExpectation.params != nil {
		mmMarkRetry.mock.t.Fatalf("OutboxRepositoryMock.MarkRetry mock is already set by Expect")
	}

	if mmMarkRetry.defaultExpectation.paramPtrs == nil {
		mmMarkRetry.defaultExpectation.paramPtrs = &OutboxRepositoryMockMarkRetryParamPtrs{}
	}
	mmMarkRetry.defaultExpectation.paramPtrs.ctx = &ctx
	mmMarkRetry.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmMarkRetry
}

// ExpectIdParam2 sets up expected param id for OutboxRepository.MarkRetry
func (mmMarkRetry *mOutboxRepositoryMockMarkRetry) ExpectIdParam2(id uuid.UUID) *mOutboxRepositoryMockMarkRetry {
	if mmMarkRetry.mock.funcMarkRetry != nil {
		mmMarkRetry.mock.t.Fatalf("OutboxRepositoryMock.MarkRetry mock is already set by Set")
	}

	if mmMarkRetry.defaultExpectation == nil {
		mmMarkRetry.defaultExpectation = &OutboxRepositoryMockMarkRetryExpectation{}
	}

	if mmMarkRetry.defaultExpectation.params != nil {
		mmMarkRetry.mock.t.Fatalf("OutboxRepositoryMock.MarkRetry mock is already set by Expect")
	}

	if mmMarkRetry.defaultExpectation.paramPtrs == nil {
		mmMarkRetry.defaultExpectation.paramPtrs = &OutboxRepositoryMockMarkRetryParamPtrs{}
	}
	mmMarkRetry.defaultExpectation.paramPtrs.id = &id
	mmMarkRetry.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmMarkRetry
}

// ExpectErrMsgParam3 sets up expected param errMsg for OutboxRepository.MarkRetry
func (mmMarkRetry *mOutboxRepositoryMockMarkRetry) ExpectErrMsgParam3(errMsg string) *mOutboxRepositoryMockMarkRetry {
	if mmMarkRetry.mock.funcMarkRetry != nil {
		mmMarkRetry.mock.t.Fatalf("OutboxRepositoryMock.MarkRetry mock is already set by Set")
	}

	if mmMarkRetry.defaultExpectation == nil {
		mmMarkRetry.defaultExpectation = &OutboxRepositoryMockMarkRetryExpectation{}
	}

	if mmMarkRetry.defaultExpectation.params != nil {
		mmMarkRetry.mock.t.Fatalf("OutboxRepositoryMock.MarkRetry mock is already set by Expect")
	}

	if mmMarkRetry.defaultExpectation.paramPtrs == nil {
		mmMarkRetry.defaultExpectation.paramPtrs = &OutboxRepositoryMockMarkRetryParamPtrs{}
	}
	mmMarkRetry.defaultExpectation.paramPtrs.errMsg = &errMsg
	mmMarkRetry.defaultExpectation.expectationOrigins.originErrMsg = minimock.CallerInfo(1)

	return mmMarkRetry
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepository.MarkRetry
func (mmMarkRetry *mOutboxRepositoryMockMarkRetry) Inspect(f func(ctx context.Context, id uuid.UUID, errMsg string)) *mOutboxRepositoryMockMarkRetry {
	if mmMarkRetry.mock.inspectFuncMarkRetry != nil {
		mmMarkRetry.mock.t.Fatalf("Inspect function is already set for OutboxRepositoryMock.MarkRetry")
	}

	mmMarkRetry.mock.inspectFuncMarkRetry = f

	return mmMarkRetry
}

// Return sets up results that will be returned by OutboxRepository.MarkRetry
func (mmMarkRetry *mOutboxRepositoryMockMarkRetry) Return(err error) *OutboxRepositoryMock {
	if mmMarkRetry.mock.funcMarkRetry != nil {
		mmMarkRetry.mock.t.Fatalf("OutboxRepositoryMock.MarkRetry mock is already set by Set")
	}

	if mmMarkRetry.defaultExpectation == nil {
		mmMarkRetry.defaultExpectation = &OutboxRepositoryMockMarkRetryExpectation{mock: mmMarkRetry.mock}
	}
	mmMarkRetry.defaultExpectation.results = &OutboxRepositoryMockMarkRetryResults{err}
	mmMarkRetry.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMarkRetry.mock
}

// Set uses given function f to mock the OutboxRepository.MarkRetry method
func (mmMarkRetry *mOutboxRepositoryMockMarkRetry) Set(f func(ctx context.Context, id uuid.UUID, errMsg string) (err error)) *OutboxRepositoryMock {
	if mmMarkRetry.defaultExpectation != nil {
		mmMarkRetry.mock.t.Fatalf("Default expectation is already set for the OutboxRepository.MarkRetry method")
	}

	if len(mmMarkRetry.expectations) > 0 {
		mmMarkRetry.mock.t.Fatalf("Some expectations are already set for the OutboxRepository.MarkRetry method")
	}

	mmMarkRetry.mock.funcMarkRetry = f
	mmMarkRetry.mock.funcMarkRetryOrigin = minimock.CallerInfo(1)
	return mmMarkRetry.mock
}

// When sets expectation for the OutboxRepository.MarkRetry which will trigger the result defined by the following
// Then helper
func (mmMarkRetry *mOutboxRepositoryMockMarkRetry) When(ctx context.Context, id uuid.UUID, errMsg string) *OutboxRepositoryMockMarkRetryExpectation {
	if mmMarkRetry.mock.funcMarkRetry != nil {
		mmMarkRetry.mock.t.Fatalf("OutboxRepositoryMock.MarkRetry mock is already set by Set")
	}

	expectation := &OutboxRepositoryMockMarkRetryExpectation{
		mock:               mmMarkRetry.mock,
		params:             &OutboxRepositoryMockMarkRetryParams{ctx, id, errMsg},
		expectationOrigins: OutboxRepositoryMockMarkRetryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmMarkRetry.expectations = append(mmMarkRetry.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepository.MarkRetry return parameters for the expectation previously defined by the When method
func (e *OutboxRepositoryMockMarkRetryExpectation) Then(err error) *OutboxRepositoryMock {
	e.results = &OutboxRepositoryMockMarkRetryResults{err}
	return e.mock
}

// Times sets number of times OutboxRepository.MarkRetry should be invoked
func (mmMarkRetry *mOutboxRepositoryMockMarkRetry) Times(n uint64) *mOutboxRepositoryMockMarkRetry {
	if n == 0 {
		mmMarkRetry.mock.t.Fatalf("Times of OutboxRepositoryMock.MarkRetry mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMarkRetry.expectedInvocations, n)
	mmMarkRetry.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMarkRetry
}

func (mmMarkRetry *mOutboxRepositoryMockMarkRetry) invocationsDone() bool {
	if len(mmMarkRetry.expectations) == 0 && mmMarkRetry.defaultExpectation == nil && mmMarkRetry.mock.funcMarkRetry == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMarkRetry.mock.afterMarkRetryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMarkRetry.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MarkRetry implements mm_usecase.OutboxRepository
func (mmMarkRetry *OutboxRepositoryMock) MarkRetry(ctx context.Context, id uuid.UUID, errMsg string) (err error) {
	mm_atomic.AddUint64(&mmMarkRetry.beforeMarkRetryCounter, 1)
	defer mm_atomic.AddUint64(&mmMarkRetry.afterMarkRetryCounter, 1)

	mmMarkRetry.t.Helper()

	if mmMarkRetry.inspectFuncMarkRetry != nil {
		mmMarkRetry.inspectFuncMarkRetry(ctx, id, errMsg)
	}

	mm_params := OutboxRepositoryMockMarkRetryParams{ctx, id, errMsg}

	// Record call args
	mmMarkRetry.MarkRetryMock.mutex.Lock()
	mmMarkRetry.MarkRetryMock.callArgs = append(mmMarkRetry.MarkRetryMock.callArgs, &mm_params)
	mmMarkRetry.MarkRetryMock.mutex.Unlock()

	for _, e := range mmMarkRetry.MarkRetryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMarkRetry.MarkRetryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMarkRetry.MarkRetryMock.defaultExpectation.Counter, 1)
		mm_want := mmMarkRetry.MarkRetryMock.defaultExpectation.params
		mm_want_ptrs := mmMarkRetry.MarkRetryMock.defaultExpectation.paramPtrs

		mm_got := OutboxRepositoryMockMarkRetryParams{ctx, id, errMsg}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmMarkRetry.t.Errorf("OutboxRepositoryMock.MarkRetry got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkRetry.MarkRetryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmMarkRetry.t.Errorf("OutboxRepositoryMock.MarkRetry got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkRetry.MarkRetryMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.errMsg != nil && !minimock.Equal(*mm_want_ptrs.errMsg, mm_got.errMsg) {
				mmMarkRetry.t.Errorf("OutboxRepositoryMock.MarkRetry got unexpected parameter errMsg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkRetry.MarkRetryMock.defaultExpectation.expectationOrigins.originErrMsg, *mm_want_ptrs.errMsg, mm_got.errMsg, minimock.Diff(*mm_want_ptrs.errMsg, mm_got.errMsg))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMarkRetry.t.Errorf("OutboxRepositoryMock.MarkRetry got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmMarkRetry.MarkRetryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMarkRetry.MarkRetryMock.defaultExpectation.results
		if mm_results == nil {
			mmMarkRetry.t.Fatal("No results are set for the OutboxRepositoryMock.MarkRetry")
		}
		return (*mm_results).err
	}
	if mmMarkRetry.funcMarkRetry != nil {
		return mmMarkRetry.funcMarkRetry(ctx, id, errMsg)
	}
	mmMarkRetry.t.Fatalf("Unexpected call to OutboxRepositoryMock.MarkRetry. %v %v %v", ctx, id, errMsg)
	return
}

// MarkRetryAfterCounter returns a count of finished OutboxRepositoryMock.MarkRetry invocations
func (mmMarkRetry *OutboxRepositoryMock) MarkRetryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkRetry.afterMarkRetryCounter)
}

// MarkRetryBeforeCounter returns a count of OutboxRepositoryMock.MarkRetry invocations
func (mmMarkRetry *OutboxRepositoryMock) MarkRetryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkRetry.beforeMarkRetryCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepositoryMock.MarkRetry.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMarkRetry *mOutboxRepositoryMockMarkRetry) Calls() []*OutboxRepositoryMockMarkRetryParams {
	mmMarkRetry.mutex.RLock()

	argCopy := make([]*OutboxRepositoryMockMarkRetryParams, len(mmMarkRetry.callArgs))
	copy(argCopy, mmMarkRetry.callArgs)

	mmMarkRetry.mutex.RUnlock()

	return argCopy
}

// MinimockMarkRetryDone returns true if the count of the MarkRetry invocations corresponds
// the number of defined expectations
func (m *OutboxRepositoryMock) MinimockMarkRetryDone() bool {
	if m.MarkRetryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MarkRetryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MarkRetryMock.invocationsDone()
}

// MinimockMarkRetryInspect logs each unmet expectation
func (m *OutboxRepositoryMock) MinimockMarkRetryInspect() {
	for _, e := range m.MarkRetryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepositoryMock.MarkRetry at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterMarkRetryCounter := mm_atomic.LoadUint64(&m.afterMarkRetryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MarkRetryMock.defaultExpectation != nil && afterMarkRetryCounter < 1 {
		if m.MarkRetryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutboxRepositoryMock.MarkRetry at\n%s", m.MarkRetryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutboxRepositoryMock.MarkRetry at\n%s with params: %#v", m.MarkRetryMock.defaultExpectation.expectationOrigins.origin, *m.MarkRetryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarkRetry != nil && afterMarkRetryCounter < 1 {
		m.t.Errorf("Expected call to OutboxRepositoryMock.MarkRetry at\n%s", m.funcMarkRetryOrigin)
	}

	if !m.MarkRetryMock.invocationsDone() && afterMarkRetryCounter > 0 {
		m.t.Errorf("Expected %d calls to OutboxRepositoryMock.MarkRetry at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MarkRetryMock.expectedInvocations), m.MarkRetryMock.expectedInvocationsOrigin, afterMarkRetryCounter)
	}
}

type mOutboxRepositoryMockPickReadyTx struct {
	optional           bool
	mock               *OutboxRepositoryMock
	defaultExpectation *OutboxRepositoryMockPickReadyTxExpectation
	expectations       []*OutboxRepositoryMockPickReadyTxExpectation

	callArgs []*OutboxRepositoryMockPickReadyTxParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutboxRepositoryMockPickReadyTxExpectation specifies expectation struct of the OutboxRepository.PickReadyTx
type OutboxRepositoryMockPickReadyTxExpectation struct {
	mock               *OutboxRepositoryMock
	params             *OutboxRepositoryMockPickReadyTxParams
	paramPtrs          *OutboxRepositoryMockPickReadyTxParamPtrs
	expectationOrigins OutboxRepositoryMockPickReadyTxExpectationOrigins
	results            *OutboxRepositoryMockPickReadyTxResults
	returnOrigin       string
	Counter            uint64
}

// OutboxRepositoryMockPickReadyTxParams contains parameters of the OutboxRepository.PickReadyTx
type OutboxRepositoryMockPickReadyTxParams struct {
	ctx   context.Context
	limit int
}

// OutboxRepositoryMockPickReadyTxParamPtrs contains pointers to parameters of the OutboxRepository.PickReadyTx
type OutboxRepositoryMockPickReadyTxParamPtrs struct {
	ctx   *context.Context
	limit *int
}

// OutboxRepositoryMockPickReadyTxResults contains results of the OutboxRepository.PickReadyTx
type OutboxRepositoryMockPickReadyTxResults struct {
	oa1 []models.OutboxRecord
	err error
}

// OutboxRepositoryMockPickReadyTxOrigins contains origins of expectations of the OutboxRepository.PickReadyTx
type OutboxRepositoryMockPickReadyTxExpectationOrigins struct {
	origin      string
	originCtx   string
	originLimit string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPickReadyTx *mOutboxRepositoryMockPickReadyTx) Optional() *mOutboxRepositoryMockPickReadyTx {
	mmPickReadyTx.optional = true
	return mmPickReadyTx
}

// Expect sets up expected params for OutboxRepository.PickReadyTx
func (mmPickReadyTx *mOutboxRepositoryMockPickReadyTx) Expect(ctx context.Context, limit int) *mOutboxRepositoryMockPickReadyTx {
	if mmPickReadyTx.mock.funcPickReadyTx != nil {
		mmPickReadyTx.mock.t.Fatalf("OutboxRepositoryMock.PickReadyTx mock is already set by Set")
	}

	if mmPickReadyTx.defaultExpectation == nil {
		mmPickReadyTx.defaultExpectation = &OutboxRepositoryMockPickReadyTxExpectation{}
	}

	if mmPickReadyTx.defaultExpectation.paramPtrs != nil {
		mmPickReadyTx.mock.t.Fatalf("OutboxRepositoryMock.PickReadyTx mock is already set by ExpectParams functions")
	}

	mmPickReadyTx.defaultExpectation.params = &OutboxRepositoryMockPickReadyTxParams{ctx, limit}
	mmPickReadyTx.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPickReadyTx.expectations {
		if minimock.Equal(e.params, mmPickReadyTx.defaultExpectation.params) {
			mmPickReadyTx.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPickReadyTx.defaultExpectation.params)
		}
	}

	return mmPickReadyTx
}

// ExpectCtxParam1 sets up expected param ctx for OutboxRepository.PickReadyTx
func (mmPickReadyTx *mOutboxRepositoryMockPickReadyTx) ExpectCtxParam1(ctx context.Context) *mOutboxRepositoryMockPickReadyTx {
	if mmPickReadyTx.mock.funcPickReadyTx != nil {
		mmPickReadyTx.mock.t.Fatalf("OutboxRepositoryMock.PickReadyTx mock is already set by Set")
	}

	if mmPickReadyTx.defaultExpectation == nil {
		mmPickReadyTx.defaultExpectation = &OutboxRepositoryMockPickReadyTxExpectation{}
	}

	if mmPickReadyTx.defaultExpectation.params != nil {
		mmPickReadyTx.mock.t.Fatalf("OutboxRepositoryMock.PickReadyTx mock is already set by Expect")
	}

	if mmPickReadyTx.defaultExpectation.paramPtrs == nil {
		mmPickReadyTx.defaultExpectation.paramPtrs = &OutboxRepositoryMockPickReadyTxParamPtrs{}
	}
	mmPickReadyTx.defaultExpectation.paramPtrs.ctx = &ctx
	mmPickReadyTx.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPickReadyTx
}

// ExpectLimitParam2 sets up expected param limit for OutboxRepository.PickReadyTx
func (mmPickReadyTx *mOutboxRepositoryMockPickReadyTx) ExpectLimitParam2(limit int) *mOutboxRepositoryMockPickReadyTx {
	if mmPickReadyTx.mock.funcPickReadyTx != nil {
		mmPickReadyTx.mock.t.Fatalf("OutboxRepositoryMock.PickReadyTx mock is already set by Set")
	}

	if mmPickReadyTx.defaultExpectation == nil {
		mmPickReadyTx.defaultExpectation = &OutboxRepositoryMockPickReadyTxExpectation{}
	}

	if mmPickReadyTx.defaultExpectation.params != nil {
		mmPickReadyTx.mock.t.Fatalf("OutboxRepositoryMock.PickReadyTx mock is already set by Expect")
	}

	if mmPickReadyTx.defaultExpectation.paramPtrs == nil {
		mmPickReadyTx.defaultExpectation.paramPtrs = &OutboxRepositoryMockPickReadyTxParamPtrs{}
	}
	mmPickReadyTx.defaultExpectation.paramPtrs.limit = &limit
	mmPickReadyTx.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmPickReadyTx
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepository.PickReadyTx
func (mmPickReadyTx *mOutboxRepositoryMockPickReadyTx) Inspect(f func(ctx context.Context, limit int)) *mOutboxRepositoryMockPickReadyTx {
	if mmPickReadyTx.mock.inspectFuncPickReadyTx != nil {
		mmPickReadyTx.mock.t.Fatalf("Inspect function is already set for OutboxRepositoryMock.PickReadyTx")
	}

	mmPickReadyTx.mock.inspectFuncPickReadyTx = f

	return mmPickReadyTx
}

// Return sets up results that will be returned by OutboxRepository.PickReadyTx
func (mmPickReadyTx *mOutboxRepositoryMockPickReadyTx) Return(oa1 []models.OutboxRecord, err error) *OutboxRepositoryMock {
	if mmPickReadyTx.mock.funcPickReadyTx != nil {
		mmPickReadyTx.mock.t.Fatalf("OutboxRepositoryMock.PickReadyTx mock is already set by Set")
	}

	if mmPickReadyTx.defaultExpectation == nil {
		mmPickReadyTx.defaultExpectation = &OutboxRepositoryMockPickReadyTxExpectation{mock: mmPickReadyTx.mock}
	}
	mmPickReadyTx.defaultExpectation.results = &OutboxRepositoryMockPickReadyTxResults{oa1, err}
	mmPickReadyTx.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPickReadyTx.mock
}

// Set uses given function f to mock the OutboxRepository.PickReadyTx method
func (mmPickReadyTx *mOutboxRepositoryMockPickReadyTx) Set(f func(ctx context.Context, limit int) (oa1 []models.OutboxRecord, err error)) *OutboxRepositoryMock {
	if mmPickReadyTx.defaultExpectation != nil {
		mmPickReadyTx.mock.t.Fatalf("Default expectation is already set for the OutboxRepository.PickReadyTx method")
	}

	if len(mmPickReadyTx.expectations) > 0 {
		mmPickReadyTx.mock.t.Fatalf("Some expectations are already set for the OutboxRepository.PickReadyTx method")
	}

	mmPickReadyTx.mock.funcPickReadyTx = f
	mmPickReadyTx.mock.funcPickReadyTxOrigin = minimock.CallerInfo(1)
	return mmPickReadyTx.mock
}

// When sets expectation for the OutboxRepository.PickReadyTx which will trigger the result defined by the following
// Then helper
func (mmPickReadyTx *mOutboxRepositoryMockPickReadyTx) When(ctx context.Context, limit int) *OutboxRepositoryMockPickReadyTxExpectation {
	if mmPickReadyTx.mock.funcPickReadyTx != nil {
		mmPickReadyTx.mock.t.Fatalf("OutboxRepositoryMock.PickReadyTx mock is already set by Set")
	}

	expectation := &OutboxRepositoryMockPickReadyTxExpectation{
		mock:               mmPickReadyTx.mock,
		params:             &OutboxRepositoryMockPickReadyTxParams{ctx, limit},
		expectationOrigins: OutboxRepositoryMockPickReadyTxExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPickReadyTx.expectations = append(mmPickReadyTx.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepository.PickReadyTx return parameters for the expectation previously defined by the When method
func (e *OutboxRepositoryMockPickReadyTxExpectation) Then(oa1 []models.OutboxRecord, err error) *OutboxRepositoryMock {
	e.results = &OutboxRepositoryMockPickReadyTxResults{oa1, err}
	return e.mock
}

// Times sets number of times OutboxRepository.PickReadyTx should be invoked
func (mmPickReadyTx *mOutboxRepositoryMockPickReadyTx) Times(n uint64) *mOutboxRepositoryMockPickReadyTx {
	if n == 0 {
		mmPickReadyTx.mock.t.Fatalf("Times of OutboxRepositoryMock.PickReadyTx mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPickReadyTx.expectedInvocations, n)
	mmPickReadyTx.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPickReadyTx
}

func (mmPickReadyTx *mOutboxRepositoryMockPickReadyTx) invocationsDone() bool {
	if len(mmPickReadyTx.expectations) == 0 && mmPickReadyTx.defaultExpectation == nil && mmPickReadyTx.mock.funcPickReadyTx == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPickReadyTx.mock.afterPickReadyTxCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPickReadyTx.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PickReadyTx implements mm_usecase.OutboxRepository
func (mmPickReadyTx *OutboxRepositoryMock) PickReadyTx(ctx context.Context, limit int) (oa1 []models.OutboxRecord, err error) {
	mm_atomic.AddUint64(&mmPickReadyTx.beforePickReadyTxCounter, 1)
	defer mm_atomic.AddUint64(&mmPickReadyTx.afterPickReadyTxCounter, 1)

	mmPickReadyTx.t.Helper()

	if mmPickReadyTx.inspectFuncPickReadyTx != nil {
		mmPickReadyTx.inspectFuncPickReadyTx(ctx, limit)
	}

	mm_params := OutboxRepositoryMockPickReadyTxParams{ctx, limit}

	// Record call args
	mmPickReadyTx.PickReadyTxMock.mutex.Lock()
	mmPickReadyTx.PickReadyTxMock.callArgs = append(mmPickReadyTx.PickReadyTxMock.callArgs, &mm_params)
	mmPickReadyTx.PickReadyTxMock.mutex.Unlock()

	for _, e := range mmPickReadyTx.PickReadyTxMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmPickReadyTx.PickReadyTxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPickReadyTx.PickReadyTxMock.defaultExpectation.Counter, 1)
		mm_want := mmPickReadyTx.PickReadyTxMock.defaultExpectation.params
		mm_want_ptrs := mmPickReadyTx.PickReadyTxMock.defaultExpectation.paramPtrs

		mm_got := OutboxRepositoryMockPickReadyTxParams{ctx, limit}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPickReadyTx.t.Errorf("OutboxRepositoryMock.PickReadyTx got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPickReadyTx.PickReadyTxMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmPickReadyTx.t.Errorf("OutboxRepositoryMock.PickReadyTx got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPickReadyTx.PickReadyTxMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPickReadyTx.t.Errorf("OutboxRepositoryMock.PickReadyTx got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPickReadyTx.PickReadyTxMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPickReadyTx.PickReadyTxMock.defaultExpectation.results
		if mm_results == nil {
			mmPickReadyTx.t.Fatal("No results are set for the OutboxRepositoryMock.PickReadyTx")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmPickReadyTx.funcPickReadyTx != nil {
		return mmPickReadyTx.funcPickReadyTx(ctx, limit)
	}
	mmPickReadyTx.t.Fatalf("Unexpected call to OutboxRepositoryMock.PickReadyTx. %v %v", ctx, limit)
	return
}

// PickReadyTxAfterCounter returns a count of finished OutboxRepositoryMock.PickReadyTx invocations
func (mmPickReadyTx *OutboxRepositoryMock) PickReadyTxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPickReadyTx.afterPickReadyTxCounter)
}

// PickReadyTxBeforeCounter returns a count of OutboxRepositoryMock.PickReadyTx invocations
func (mmPickReadyTx *OutboxRepositoryMock) PickReadyTxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPickReadyTx.beforePickReadyTxCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepositoryMock.PickReadyTx.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPickReadyTx *mOutboxRepositoryMockPickReadyTx) Calls() []*OutboxRepositoryMockPickReadyTxParams {
	mmPickReadyTx.mutex.RLock()

	argCopy := make([]*OutboxRepositoryMockPickReadyTxParams, len(mmPickReadyTx.callArgs))
	copy(argCopy, mmPickReadyTx.callArgs)

	mmPickReadyTx.mutex.RUnlock()

	return argCopy
}

// MinimockPickReadyTxDone returns true if the count of the PickReadyTx invocations corresponds
// the number of defined expectations
func (m *OutboxRepositoryMock) MinimockPickReadyTxDone() bool {
	if m.PickReadyTxMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PickReadyTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PickReadyTxMock.invocationsDone()
}

// MinimockPickReadyTxInspect logs each unmet expectation
func (m *OutboxRepositoryMock) MinimockPickReadyTxInspect() {
	for _, e := range m.PickReadyTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepositoryMock.PickReadyTx at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPickReadyTxCounter := mm_atomic.LoadUint64(&m.afterPickReadyTxCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PickReadyTxMock.defaultExpectation != nil && afterPickReadyTxCounter < 1 {
		if m.PickReadyTxMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutboxRepositoryMock.PickReadyTx at\n%s", m.PickReadyTxMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutboxRepositoryMock.PickReadyTx at\n%s with params: %#v", m.PickReadyTxMock.defaultExpectation.expectationOrigins.origin, *m.PickReadyTxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPickReadyTx != nil && afterPickReadyTxCounter < 1 {
		m.t.Errorf("Expected call to OutboxRepositoryMock.PickReadyTx at\n%s", m.funcPickReadyTxOrigin)
	}

	if !m.PickReadyTxMock.invocationsDone() && afterPickReadyTxCounter > 0 {
		m.t.Errorf("Expected %d calls to OutboxRepositoryMock.PickReadyTx at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PickReadyTxMock.expectedInvocations), m.PickReadyTxMock.expectedInvocationsOrigin, afterPickReadyTxCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OutboxRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddInspect()

			m.MinimockMarkCompletedInspect()

			m.MinimockMarkFinalFailedInspect()

			m.MinimockMarkProcessingInspect()

			m.MinimockMarkRetryInspect()

			m.MinimockPickReadyTxInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OutboxRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OutboxRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDone() &&
		m.MinimockMarkCompletedDone() &&
		m.MinimockMarkFinalFailedDone() &&
		m.MinimockMarkProcessingDone() &&
		m.MinimockMarkRetryDone() &&
		m.MinimockPickReadyTxDone()
}
