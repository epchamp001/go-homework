// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i pvz-cli/pkg/cache.EvictStrategy -o evict_strategy_mock.go -n EvictStrategyMock -p mock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// EvictStrategyMock implements mm_cache.EvictStrategy
type EvictStrategyMock[K comparable] struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcRecordAccess          func(k1 K)
	funcRecordAccessOrigin    string
	inspectFuncRecordAccess   func(k1 K)
	afterRecordAccessCounter  uint64
	beforeRecordAccessCounter uint64
	RecordAccessMock          mEvictStrategyMockRecordAccess[K]

	funcRecordDeletion          func(k1 K)
	funcRecordDeletionOrigin    string
	inspectFuncRecordDeletion   func(k1 K)
	afterRecordDeletionCounter  uint64
	beforeRecordDeletionCounter uint64
	RecordDeletionMock          mEvictStrategyMockRecordDeletion[K]

	funcRecordInsertion          func(k1 K) (evictK K, shouldEvict bool)
	funcRecordInsertionOrigin    string
	inspectFuncRecordInsertion   func(k1 K)
	afterRecordInsertionCounter  uint64
	beforeRecordInsertionCounter uint64
	RecordInsertionMock          mEvictStrategyMockRecordInsertion[K]
}

// NewEvictStrategyMock returns a mock for mm_cache.EvictStrategy
func NewEvictStrategyMock[K comparable](t minimock.Tester) *EvictStrategyMock[K] {
	m := &EvictStrategyMock[K]{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.RecordAccessMock = mEvictStrategyMockRecordAccess[K]{mock: m}
	m.RecordAccessMock.callArgs = []*EvictStrategyMockRecordAccessParams[K]{}

	m.RecordDeletionMock = mEvictStrategyMockRecordDeletion[K]{mock: m}
	m.RecordDeletionMock.callArgs = []*EvictStrategyMockRecordDeletionParams[K]{}

	m.RecordInsertionMock = mEvictStrategyMockRecordInsertion[K]{mock: m}
	m.RecordInsertionMock.callArgs = []*EvictStrategyMockRecordInsertionParams[K]{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mEvictStrategyMockRecordAccess[K comparable] struct {
	optional           bool
	mock               *EvictStrategyMock[K]
	defaultExpectation *EvictStrategyMockRecordAccessExpectation[K]
	expectations       []*EvictStrategyMockRecordAccessExpectation[K]

	callArgs []*EvictStrategyMockRecordAccessParams[K]
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EvictStrategyMockRecordAccessExpectation specifies expectation struct of the EvictStrategy.RecordAccess
type EvictStrategyMockRecordAccessExpectation[K comparable] struct {
	mock               *EvictStrategyMock[K]
	params             *EvictStrategyMockRecordAccessParams[K]
	paramPtrs          *EvictStrategyMockRecordAccessParamPtrs[K]
	expectationOrigins EvictStrategyMockRecordAccessExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EvictStrategyMockRecordAccessParams contains parameters of the EvictStrategy.RecordAccess
type EvictStrategyMockRecordAccessParams[K comparable] struct {
	k1 K
}

// EvictStrategyMockRecordAccessParamPtrs contains pointers to parameters of the EvictStrategy.RecordAccess
type EvictStrategyMockRecordAccessParamPtrs[K comparable] struct {
	k1 *K
}

// EvictStrategyMockRecordAccessOrigins contains origins of expectations of the EvictStrategy.RecordAccess
type EvictStrategyMockRecordAccessExpectationOrigins struct {
	origin   string
	originK1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRecordAccess *mEvictStrategyMockRecordAccess[K]) Optional() *mEvictStrategyMockRecordAccess[K] {
	mmRecordAccess.optional = true
	return mmRecordAccess
}

// Expect sets up expected params for EvictStrategy.RecordAccess
func (mmRecordAccess *mEvictStrategyMockRecordAccess[K]) Expect(k1 K) *mEvictStrategyMockRecordAccess[K] {
	if mmRecordAccess.mock.funcRecordAccess != nil {
		mmRecordAccess.mock.t.Fatalf("EvictStrategyMock.RecordAccess mock is already set by Set")
	}

	if mmRecordAccess.defaultExpectation == nil {
		mmRecordAccess.defaultExpectation = &EvictStrategyMockRecordAccessExpectation[K]{}
	}

	if mmRecordAccess.defaultExpectation.paramPtrs != nil {
		mmRecordAccess.mock.t.Fatalf("EvictStrategyMock.RecordAccess mock is already set by ExpectParams functions")
	}

	mmRecordAccess.defaultExpectation.params = &EvictStrategyMockRecordAccessParams[K]{k1}
	mmRecordAccess.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRecordAccess.expectations {
		if minimock.Equal(e.params, mmRecordAccess.defaultExpectation.params) {
			mmRecordAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRecordAccess.defaultExpectation.params)
		}
	}

	return mmRecordAccess
}

// ExpectK1Param1 sets up expected param k1 for EvictStrategy.RecordAccess
func (mmRecordAccess *mEvictStrategyMockRecordAccess[K]) ExpectK1Param1(k1 K) *mEvictStrategyMockRecordAccess[K] {
	if mmRecordAccess.mock.funcRecordAccess != nil {
		mmRecordAccess.mock.t.Fatalf("EvictStrategyMock.RecordAccess mock is already set by Set")
	}

	if mmRecordAccess.defaultExpectation == nil {
		mmRecordAccess.defaultExpectation = &EvictStrategyMockRecordAccessExpectation[K]{}
	}

	if mmRecordAccess.defaultExpectation.params != nil {
		mmRecordAccess.mock.t.Fatalf("EvictStrategyMock.RecordAccess mock is already set by Expect")
	}

	if mmRecordAccess.defaultExpectation.paramPtrs == nil {
		mmRecordAccess.defaultExpectation.paramPtrs = &EvictStrategyMockRecordAccessParamPtrs[K]{}
	}
	mmRecordAccess.defaultExpectation.paramPtrs.k1 = &k1
	mmRecordAccess.defaultExpectation.expectationOrigins.originK1 = minimock.CallerInfo(1)

	return mmRecordAccess
}

// Inspect accepts an inspector function that has same arguments as the EvictStrategy.RecordAccess
func (mmRecordAccess *mEvictStrategyMockRecordAccess[K]) Inspect(f func(k1 K)) *mEvictStrategyMockRecordAccess[K] {
	if mmRecordAccess.mock.inspectFuncRecordAccess != nil {
		mmRecordAccess.mock.t.Fatalf("Inspect function is already set for EvictStrategyMock.RecordAccess")
	}

	mmRecordAccess.mock.inspectFuncRecordAccess = f

	return mmRecordAccess
}

// Return sets up results that will be returned by EvictStrategy.RecordAccess
func (mmRecordAccess *mEvictStrategyMockRecordAccess[K]) Return() *EvictStrategyMock[K] {
	if mmRecordAccess.mock.funcRecordAccess != nil {
		mmRecordAccess.mock.t.Fatalf("EvictStrategyMock.RecordAccess mock is already set by Set")
	}

	if mmRecordAccess.defaultExpectation == nil {
		mmRecordAccess.defaultExpectation = &EvictStrategyMockRecordAccessExpectation[K]{mock: mmRecordAccess.mock}
	}

	mmRecordAccess.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRecordAccess.mock
}

// Set uses given function f to mock the EvictStrategy.RecordAccess method
func (mmRecordAccess *mEvictStrategyMockRecordAccess[K]) Set(f func(k1 K)) *EvictStrategyMock[K] {
	if mmRecordAccess.defaultExpectation != nil {
		mmRecordAccess.mock.t.Fatalf("Default expectation is already set for the EvictStrategy.RecordAccess method")
	}

	if len(mmRecordAccess.expectations) > 0 {
		mmRecordAccess.mock.t.Fatalf("Some expectations are already set for the EvictStrategy.RecordAccess method")
	}

	mmRecordAccess.mock.funcRecordAccess = f
	mmRecordAccess.mock.funcRecordAccessOrigin = minimock.CallerInfo(1)
	return mmRecordAccess.mock
}

// When sets expectation for the EvictStrategy.RecordAccess which will trigger the result defined by the following
// Then helper
func (mmRecordAccess *mEvictStrategyMockRecordAccess[K]) When(k1 K) *EvictStrategyMockRecordAccessExpectation[K] {
	if mmRecordAccess.mock.funcRecordAccess != nil {
		mmRecordAccess.mock.t.Fatalf("EvictStrategyMock.RecordAccess mock is already set by Set")
	}

	expectation := &EvictStrategyMockRecordAccessExpectation[K]{
		mock:               mmRecordAccess.mock,
		params:             &EvictStrategyMockRecordAccessParams[K]{k1},
		expectationOrigins: EvictStrategyMockRecordAccessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRecordAccess.expectations = append(mmRecordAccess.expectations, expectation)
	return expectation
}

// Then sets up EvictStrategy.RecordAccess return parameters for the expectation previously defined by the When method

func (e *EvictStrategyMockRecordAccessExpectation[K]) Then() *EvictStrategyMock[K] {
	return e.mock
}

// Times sets number of times EvictStrategy.RecordAccess should be invoked
func (mmRecordAccess *mEvictStrategyMockRecordAccess[K]) Times(n uint64) *mEvictStrategyMockRecordAccess[K] {
	if n == 0 {
		mmRecordAccess.mock.t.Fatalf("Times of EvictStrategyMock.RecordAccess mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRecordAccess.expectedInvocations, n)
	mmRecordAccess.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRecordAccess
}

func (mmRecordAccess *mEvictStrategyMockRecordAccess[K]) invocationsDone() bool {
	if len(mmRecordAccess.expectations) == 0 && mmRecordAccess.defaultExpectation == nil && mmRecordAccess.mock.funcRecordAccess == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRecordAccess.mock.afterRecordAccessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRecordAccess.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RecordAccess implements mm_cache.EvictStrategy
func (mmRecordAccess *EvictStrategyMock[K]) RecordAccess(k1 K) {
	mm_atomic.AddUint64(&mmRecordAccess.beforeRecordAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmRecordAccess.afterRecordAccessCounter, 1)

	mmRecordAccess.t.Helper()

	if mmRecordAccess.inspectFuncRecordAccess != nil {
		mmRecordAccess.inspectFuncRecordAccess(k1)
	}

	mm_params := EvictStrategyMockRecordAccessParams[K]{k1}

	// Record call args
	mmRecordAccess.RecordAccessMock.mutex.Lock()
	mmRecordAccess.RecordAccessMock.callArgs = append(mmRecordAccess.RecordAccessMock.callArgs, &mm_params)
	mmRecordAccess.RecordAccessMock.mutex.Unlock()

	for _, e := range mmRecordAccess.RecordAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRecordAccess.RecordAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecordAccess.RecordAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmRecordAccess.RecordAccessMock.defaultExpectation.params
		mm_want_ptrs := mmRecordAccess.RecordAccessMock.defaultExpectation.paramPtrs

		mm_got := EvictStrategyMockRecordAccessParams[K]{k1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.k1 != nil && !minimock.Equal(*mm_want_ptrs.k1, mm_got.k1) {
				mmRecordAccess.t.Errorf("EvictStrategyMock.RecordAccess got unexpected parameter k1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRecordAccess.RecordAccessMock.defaultExpectation.expectationOrigins.originK1, *mm_want_ptrs.k1, mm_got.k1, minimock.Diff(*mm_want_ptrs.k1, mm_got.k1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRecordAccess.t.Errorf("EvictStrategyMock.RecordAccess got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRecordAccess.RecordAccessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmRecordAccess.funcRecordAccess != nil {
		mmRecordAccess.funcRecordAccess(k1)
		return
	}
	mmRecordAccess.t.Fatalf("Unexpected call to EvictStrategyMock.RecordAccess. %v", k1)

}

// RecordAccessAfterCounter returns a count of finished EvictStrategyMock.RecordAccess invocations
func (mmRecordAccess *EvictStrategyMock[K]) RecordAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecordAccess.afterRecordAccessCounter)
}

// RecordAccessBeforeCounter returns a count of EvictStrategyMock.RecordAccess invocations
func (mmRecordAccess *EvictStrategyMock[K]) RecordAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecordAccess.beforeRecordAccessCounter)
}

// Calls returns a list of arguments used in each call to EvictStrategyMock.RecordAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRecordAccess *mEvictStrategyMockRecordAccess[K]) Calls() []*EvictStrategyMockRecordAccessParams[K] {
	mmRecordAccess.mutex.RLock()

	argCopy := make([]*EvictStrategyMockRecordAccessParams[K], len(mmRecordAccess.callArgs))
	copy(argCopy, mmRecordAccess.callArgs)

	mmRecordAccess.mutex.RUnlock()

	return argCopy
}

// MinimockRecordAccessDone returns true if the count of the RecordAccess invocations corresponds
// the number of defined expectations
func (m *EvictStrategyMock[K]) MinimockRecordAccessDone() bool {
	if m.RecordAccessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RecordAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RecordAccessMock.invocationsDone()
}

// MinimockRecordAccessInspect logs each unmet expectation
func (m *EvictStrategyMock[K]) MinimockRecordAccessInspect() {
	for _, e := range m.RecordAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EvictStrategyMock.RecordAccess at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRecordAccessCounter := mm_atomic.LoadUint64(&m.afterRecordAccessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RecordAccessMock.defaultExpectation != nil && afterRecordAccessCounter < 1 {
		if m.RecordAccessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EvictStrategyMock.RecordAccess at\n%s", m.RecordAccessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EvictStrategyMock.RecordAccess at\n%s with params: %#v", m.RecordAccessMock.defaultExpectation.expectationOrigins.origin, *m.RecordAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecordAccess != nil && afterRecordAccessCounter < 1 {
		m.t.Errorf("Expected call to EvictStrategyMock.RecordAccess at\n%s", m.funcRecordAccessOrigin)
	}

	if !m.RecordAccessMock.invocationsDone() && afterRecordAccessCounter > 0 {
		m.t.Errorf("Expected %d calls to EvictStrategyMock.RecordAccess at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RecordAccessMock.expectedInvocations), m.RecordAccessMock.expectedInvocationsOrigin, afterRecordAccessCounter)
	}
}

type mEvictStrategyMockRecordDeletion[K comparable] struct {
	optional           bool
	mock               *EvictStrategyMock[K]
	defaultExpectation *EvictStrategyMockRecordDeletionExpectation[K]
	expectations       []*EvictStrategyMockRecordDeletionExpectation[K]

	callArgs []*EvictStrategyMockRecordDeletionParams[K]
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EvictStrategyMockRecordDeletionExpectation specifies expectation struct of the EvictStrategy.RecordDeletion
type EvictStrategyMockRecordDeletionExpectation[K comparable] struct {
	mock               *EvictStrategyMock[K]
	params             *EvictStrategyMockRecordDeletionParams[K]
	paramPtrs          *EvictStrategyMockRecordDeletionParamPtrs[K]
	expectationOrigins EvictStrategyMockRecordDeletionExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EvictStrategyMockRecordDeletionParams contains parameters of the EvictStrategy.RecordDeletion
type EvictStrategyMockRecordDeletionParams[K comparable] struct {
	k1 K
}

// EvictStrategyMockRecordDeletionParamPtrs contains pointers to parameters of the EvictStrategy.RecordDeletion
type EvictStrategyMockRecordDeletionParamPtrs[K comparable] struct {
	k1 *K
}

// EvictStrategyMockRecordDeletionOrigins contains origins of expectations of the EvictStrategy.RecordDeletion
type EvictStrategyMockRecordDeletionExpectationOrigins struct {
	origin   string
	originK1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRecordDeletion *mEvictStrategyMockRecordDeletion[K]) Optional() *mEvictStrategyMockRecordDeletion[K] {
	mmRecordDeletion.optional = true
	return mmRecordDeletion
}

// Expect sets up expected params for EvictStrategy.RecordDeletion
func (mmRecordDeletion *mEvictStrategyMockRecordDeletion[K]) Expect(k1 K) *mEvictStrategyMockRecordDeletion[K] {
	if mmRecordDeletion.mock.funcRecordDeletion != nil {
		mmRecordDeletion.mock.t.Fatalf("EvictStrategyMock.RecordDeletion mock is already set by Set")
	}

	if mmRecordDeletion.defaultExpectation == nil {
		mmRecordDeletion.defaultExpectation = &EvictStrategyMockRecordDeletionExpectation[K]{}
	}

	if mmRecordDeletion.defaultExpectation.paramPtrs != nil {
		mmRecordDeletion.mock.t.Fatalf("EvictStrategyMock.RecordDeletion mock is already set by ExpectParams functions")
	}

	mmRecordDeletion.defaultExpectation.params = &EvictStrategyMockRecordDeletionParams[K]{k1}
	mmRecordDeletion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRecordDeletion.expectations {
		if minimock.Equal(e.params, mmRecordDeletion.defaultExpectation.params) {
			mmRecordDeletion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRecordDeletion.defaultExpectation.params)
		}
	}

	return mmRecordDeletion
}

// ExpectK1Param1 sets up expected param k1 for EvictStrategy.RecordDeletion
func (mmRecordDeletion *mEvictStrategyMockRecordDeletion[K]) ExpectK1Param1(k1 K) *mEvictStrategyMockRecordDeletion[K] {
	if mmRecordDeletion.mock.funcRecordDeletion != nil {
		mmRecordDeletion.mock.t.Fatalf("EvictStrategyMock.RecordDeletion mock is already set by Set")
	}

	if mmRecordDeletion.defaultExpectation == nil {
		mmRecordDeletion.defaultExpectation = &EvictStrategyMockRecordDeletionExpectation[K]{}
	}

	if mmRecordDeletion.defaultExpectation.params != nil {
		mmRecordDeletion.mock.t.Fatalf("EvictStrategyMock.RecordDeletion mock is already set by Expect")
	}

	if mmRecordDeletion.defaultExpectation.paramPtrs == nil {
		mmRecordDeletion.defaultExpectation.paramPtrs = &EvictStrategyMockRecordDeletionParamPtrs[K]{}
	}
	mmRecordDeletion.defaultExpectation.paramPtrs.k1 = &k1
	mmRecordDeletion.defaultExpectation.expectationOrigins.originK1 = minimock.CallerInfo(1)

	return mmRecordDeletion
}

// Inspect accepts an inspector function that has same arguments as the EvictStrategy.RecordDeletion
func (mmRecordDeletion *mEvictStrategyMockRecordDeletion[K]) Inspect(f func(k1 K)) *mEvictStrategyMockRecordDeletion[K] {
	if mmRecordDeletion.mock.inspectFuncRecordDeletion != nil {
		mmRecordDeletion.mock.t.Fatalf("Inspect function is already set for EvictStrategyMock.RecordDeletion")
	}

	mmRecordDeletion.mock.inspectFuncRecordDeletion = f

	return mmRecordDeletion
}

// Return sets up results that will be returned by EvictStrategy.RecordDeletion
func (mmRecordDeletion *mEvictStrategyMockRecordDeletion[K]) Return() *EvictStrategyMock[K] {
	if mmRecordDeletion.mock.funcRecordDeletion != nil {
		mmRecordDeletion.mock.t.Fatalf("EvictStrategyMock.RecordDeletion mock is already set by Set")
	}

	if mmRecordDeletion.defaultExpectation == nil {
		mmRecordDeletion.defaultExpectation = &EvictStrategyMockRecordDeletionExpectation[K]{mock: mmRecordDeletion.mock}
	}

	mmRecordDeletion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRecordDeletion.mock
}

// Set uses given function f to mock the EvictStrategy.RecordDeletion method
func (mmRecordDeletion *mEvictStrategyMockRecordDeletion[K]) Set(f func(k1 K)) *EvictStrategyMock[K] {
	if mmRecordDeletion.defaultExpectation != nil {
		mmRecordDeletion.mock.t.Fatalf("Default expectation is already set for the EvictStrategy.RecordDeletion method")
	}

	if len(mmRecordDeletion.expectations) > 0 {
		mmRecordDeletion.mock.t.Fatalf("Some expectations are already set for the EvictStrategy.RecordDeletion method")
	}

	mmRecordDeletion.mock.funcRecordDeletion = f
	mmRecordDeletion.mock.funcRecordDeletionOrigin = minimock.CallerInfo(1)
	return mmRecordDeletion.mock
}

// When sets expectation for the EvictStrategy.RecordDeletion which will trigger the result defined by the following
// Then helper
func (mmRecordDeletion *mEvictStrategyMockRecordDeletion[K]) When(k1 K) *EvictStrategyMockRecordDeletionExpectation[K] {
	if mmRecordDeletion.mock.funcRecordDeletion != nil {
		mmRecordDeletion.mock.t.Fatalf("EvictStrategyMock.RecordDeletion mock is already set by Set")
	}

	expectation := &EvictStrategyMockRecordDeletionExpectation[K]{
		mock:               mmRecordDeletion.mock,
		params:             &EvictStrategyMockRecordDeletionParams[K]{k1},
		expectationOrigins: EvictStrategyMockRecordDeletionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRecordDeletion.expectations = append(mmRecordDeletion.expectations, expectation)
	return expectation
}

// Then sets up EvictStrategy.RecordDeletion return parameters for the expectation previously defined by the When method

func (e *EvictStrategyMockRecordDeletionExpectation[K]) Then() *EvictStrategyMock[K] {
	return e.mock
}

// Times sets number of times EvictStrategy.RecordDeletion should be invoked
func (mmRecordDeletion *mEvictStrategyMockRecordDeletion[K]) Times(n uint64) *mEvictStrategyMockRecordDeletion[K] {
	if n == 0 {
		mmRecordDeletion.mock.t.Fatalf("Times of EvictStrategyMock.RecordDeletion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRecordDeletion.expectedInvocations, n)
	mmRecordDeletion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRecordDeletion
}

func (mmRecordDeletion *mEvictStrategyMockRecordDeletion[K]) invocationsDone() bool {
	if len(mmRecordDeletion.expectations) == 0 && mmRecordDeletion.defaultExpectation == nil && mmRecordDeletion.mock.funcRecordDeletion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRecordDeletion.mock.afterRecordDeletionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRecordDeletion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RecordDeletion implements mm_cache.EvictStrategy
func (mmRecordDeletion *EvictStrategyMock[K]) RecordDeletion(k1 K) {
	mm_atomic.AddUint64(&mmRecordDeletion.beforeRecordDeletionCounter, 1)
	defer mm_atomic.AddUint64(&mmRecordDeletion.afterRecordDeletionCounter, 1)

	mmRecordDeletion.t.Helper()

	if mmRecordDeletion.inspectFuncRecordDeletion != nil {
		mmRecordDeletion.inspectFuncRecordDeletion(k1)
	}

	mm_params := EvictStrategyMockRecordDeletionParams[K]{k1}

	// Record call args
	mmRecordDeletion.RecordDeletionMock.mutex.Lock()
	mmRecordDeletion.RecordDeletionMock.callArgs = append(mmRecordDeletion.RecordDeletionMock.callArgs, &mm_params)
	mmRecordDeletion.RecordDeletionMock.mutex.Unlock()

	for _, e := range mmRecordDeletion.RecordDeletionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRecordDeletion.RecordDeletionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecordDeletion.RecordDeletionMock.defaultExpectation.Counter, 1)
		mm_want := mmRecordDeletion.RecordDeletionMock.defaultExpectation.params
		mm_want_ptrs := mmRecordDeletion.RecordDeletionMock.defaultExpectation.paramPtrs

		mm_got := EvictStrategyMockRecordDeletionParams[K]{k1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.k1 != nil && !minimock.Equal(*mm_want_ptrs.k1, mm_got.k1) {
				mmRecordDeletion.t.Errorf("EvictStrategyMock.RecordDeletion got unexpected parameter k1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRecordDeletion.RecordDeletionMock.defaultExpectation.expectationOrigins.originK1, *mm_want_ptrs.k1, mm_got.k1, minimock.Diff(*mm_want_ptrs.k1, mm_got.k1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRecordDeletion.t.Errorf("EvictStrategyMock.RecordDeletion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRecordDeletion.RecordDeletionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmRecordDeletion.funcRecordDeletion != nil {
		mmRecordDeletion.funcRecordDeletion(k1)
		return
	}
	mmRecordDeletion.t.Fatalf("Unexpected call to EvictStrategyMock.RecordDeletion. %v", k1)

}

// RecordDeletionAfterCounter returns a count of finished EvictStrategyMock.RecordDeletion invocations
func (mmRecordDeletion *EvictStrategyMock[K]) RecordDeletionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecordDeletion.afterRecordDeletionCounter)
}

// RecordDeletionBeforeCounter returns a count of EvictStrategyMock.RecordDeletion invocations
func (mmRecordDeletion *EvictStrategyMock[K]) RecordDeletionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecordDeletion.beforeRecordDeletionCounter)
}

// Calls returns a list of arguments used in each call to EvictStrategyMock.RecordDeletion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRecordDeletion *mEvictStrategyMockRecordDeletion[K]) Calls() []*EvictStrategyMockRecordDeletionParams[K] {
	mmRecordDeletion.mutex.RLock()

	argCopy := make([]*EvictStrategyMockRecordDeletionParams[K], len(mmRecordDeletion.callArgs))
	copy(argCopy, mmRecordDeletion.callArgs)

	mmRecordDeletion.mutex.RUnlock()

	return argCopy
}

// MinimockRecordDeletionDone returns true if the count of the RecordDeletion invocations corresponds
// the number of defined expectations
func (m *EvictStrategyMock[K]) MinimockRecordDeletionDone() bool {
	if m.RecordDeletionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RecordDeletionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RecordDeletionMock.invocationsDone()
}

// MinimockRecordDeletionInspect logs each unmet expectation
func (m *EvictStrategyMock[K]) MinimockRecordDeletionInspect() {
	for _, e := range m.RecordDeletionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EvictStrategyMock.RecordDeletion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRecordDeletionCounter := mm_atomic.LoadUint64(&m.afterRecordDeletionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RecordDeletionMock.defaultExpectation != nil && afterRecordDeletionCounter < 1 {
		if m.RecordDeletionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EvictStrategyMock.RecordDeletion at\n%s", m.RecordDeletionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EvictStrategyMock.RecordDeletion at\n%s with params: %#v", m.RecordDeletionMock.defaultExpectation.expectationOrigins.origin, *m.RecordDeletionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecordDeletion != nil && afterRecordDeletionCounter < 1 {
		m.t.Errorf("Expected call to EvictStrategyMock.RecordDeletion at\n%s", m.funcRecordDeletionOrigin)
	}

	if !m.RecordDeletionMock.invocationsDone() && afterRecordDeletionCounter > 0 {
		m.t.Errorf("Expected %d calls to EvictStrategyMock.RecordDeletion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RecordDeletionMock.expectedInvocations), m.RecordDeletionMock.expectedInvocationsOrigin, afterRecordDeletionCounter)
	}
}

type mEvictStrategyMockRecordInsertion[K comparable] struct {
	optional           bool
	mock               *EvictStrategyMock[K]
	defaultExpectation *EvictStrategyMockRecordInsertionExpectation[K]
	expectations       []*EvictStrategyMockRecordInsertionExpectation[K]

	callArgs []*EvictStrategyMockRecordInsertionParams[K]
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EvictStrategyMockRecordInsertionExpectation specifies expectation struct of the EvictStrategy.RecordInsertion
type EvictStrategyMockRecordInsertionExpectation[K comparable] struct {
	mock               *EvictStrategyMock[K]
	params             *EvictStrategyMockRecordInsertionParams[K]
	paramPtrs          *EvictStrategyMockRecordInsertionParamPtrs[K]
	expectationOrigins EvictStrategyMockRecordInsertionExpectationOrigins
	results            *EvictStrategyMockRecordInsertionResults[K]
	returnOrigin       string
	Counter            uint64
}

// EvictStrategyMockRecordInsertionParams contains parameters of the EvictStrategy.RecordInsertion
type EvictStrategyMockRecordInsertionParams[K comparable] struct {
	k1 K
}

// EvictStrategyMockRecordInsertionParamPtrs contains pointers to parameters of the EvictStrategy.RecordInsertion
type EvictStrategyMockRecordInsertionParamPtrs[K comparable] struct {
	k1 *K
}

// EvictStrategyMockRecordInsertionResults contains results of the EvictStrategy.RecordInsertion
type EvictStrategyMockRecordInsertionResults[K comparable] struct {
	evictK      K
	shouldEvict bool
}

// EvictStrategyMockRecordInsertionOrigins contains origins of expectations of the EvictStrategy.RecordInsertion
type EvictStrategyMockRecordInsertionExpectationOrigins struct {
	origin   string
	originK1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRecordInsertion *mEvictStrategyMockRecordInsertion[K]) Optional() *mEvictStrategyMockRecordInsertion[K] {
	mmRecordInsertion.optional = true
	return mmRecordInsertion
}

// Expect sets up expected params for EvictStrategy.RecordInsertion
func (mmRecordInsertion *mEvictStrategyMockRecordInsertion[K]) Expect(k1 K) *mEvictStrategyMockRecordInsertion[K] {
	if mmRecordInsertion.mock.funcRecordInsertion != nil {
		mmRecordInsertion.mock.t.Fatalf("EvictStrategyMock.RecordInsertion mock is already set by Set")
	}

	if mmRecordInsertion.defaultExpectation == nil {
		mmRecordInsertion.defaultExpectation = &EvictStrategyMockRecordInsertionExpectation[K]{}
	}

	if mmRecordInsertion.defaultExpectation.paramPtrs != nil {
		mmRecordInsertion.mock.t.Fatalf("EvictStrategyMock.RecordInsertion mock is already set by ExpectParams functions")
	}

	mmRecordInsertion.defaultExpectation.params = &EvictStrategyMockRecordInsertionParams[K]{k1}
	mmRecordInsertion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRecordInsertion.expectations {
		if minimock.Equal(e.params, mmRecordInsertion.defaultExpectation.params) {
			mmRecordInsertion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRecordInsertion.defaultExpectation.params)
		}
	}

	return mmRecordInsertion
}

// ExpectK1Param1 sets up expected param k1 for EvictStrategy.RecordInsertion
func (mmRecordInsertion *mEvictStrategyMockRecordInsertion[K]) ExpectK1Param1(k1 K) *mEvictStrategyMockRecordInsertion[K] {
	if mmRecordInsertion.mock.funcRecordInsertion != nil {
		mmRecordInsertion.mock.t.Fatalf("EvictStrategyMock.RecordInsertion mock is already set by Set")
	}

	if mmRecordInsertion.defaultExpectation == nil {
		mmRecordInsertion.defaultExpectation = &EvictStrategyMockRecordInsertionExpectation[K]{}
	}

	if mmRecordInsertion.defaultExpectation.params != nil {
		mmRecordInsertion.mock.t.Fatalf("EvictStrategyMock.RecordInsertion mock is already set by Expect")
	}

	if mmRecordInsertion.defaultExpectation.paramPtrs == nil {
		mmRecordInsertion.defaultExpectation.paramPtrs = &EvictStrategyMockRecordInsertionParamPtrs[K]{}
	}
	mmRecordInsertion.defaultExpectation.paramPtrs.k1 = &k1
	mmRecordInsertion.defaultExpectation.expectationOrigins.originK1 = minimock.CallerInfo(1)

	return mmRecordInsertion
}

// Inspect accepts an inspector function that has same arguments as the EvictStrategy.RecordInsertion
func (mmRecordInsertion *mEvictStrategyMockRecordInsertion[K]) Inspect(f func(k1 K)) *mEvictStrategyMockRecordInsertion[K] {
	if mmRecordInsertion.mock.inspectFuncRecordInsertion != nil {
		mmRecordInsertion.mock.t.Fatalf("Inspect function is already set for EvictStrategyMock.RecordInsertion")
	}

	mmRecordInsertion.mock.inspectFuncRecordInsertion = f

	return mmRecordInsertion
}

// Return sets up results that will be returned by EvictStrategy.RecordInsertion
func (mmRecordInsertion *mEvictStrategyMockRecordInsertion[K]) Return(evictK K, shouldEvict bool) *EvictStrategyMock[K] {
	if mmRecordInsertion.mock.funcRecordInsertion != nil {
		mmRecordInsertion.mock.t.Fatalf("EvictStrategyMock.RecordInsertion mock is already set by Set")
	}

	if mmRecordInsertion.defaultExpectation == nil {
		mmRecordInsertion.defaultExpectation = &EvictStrategyMockRecordInsertionExpectation[K]{mock: mmRecordInsertion.mock}
	}
	mmRecordInsertion.defaultExpectation.results = &EvictStrategyMockRecordInsertionResults[K]{evictK, shouldEvict}
	mmRecordInsertion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRecordInsertion.mock
}

// Set uses given function f to mock the EvictStrategy.RecordInsertion method
func (mmRecordInsertion *mEvictStrategyMockRecordInsertion[K]) Set(f func(k1 K) (evictK K, shouldEvict bool)) *EvictStrategyMock[K] {
	if mmRecordInsertion.defaultExpectation != nil {
		mmRecordInsertion.mock.t.Fatalf("Default expectation is already set for the EvictStrategy.RecordInsertion method")
	}

	if len(mmRecordInsertion.expectations) > 0 {
		mmRecordInsertion.mock.t.Fatalf("Some expectations are already set for the EvictStrategy.RecordInsertion method")
	}

	mmRecordInsertion.mock.funcRecordInsertion = f
	mmRecordInsertion.mock.funcRecordInsertionOrigin = minimock.CallerInfo(1)
	return mmRecordInsertion.mock
}

// When sets expectation for the EvictStrategy.RecordInsertion which will trigger the result defined by the following
// Then helper
func (mmRecordInsertion *mEvictStrategyMockRecordInsertion[K]) When(k1 K) *EvictStrategyMockRecordInsertionExpectation[K] {
	if mmRecordInsertion.mock.funcRecordInsertion != nil {
		mmRecordInsertion.mock.t.Fatalf("EvictStrategyMock.RecordInsertion mock is already set by Set")
	}

	expectation := &EvictStrategyMockRecordInsertionExpectation[K]{
		mock:               mmRecordInsertion.mock,
		params:             &EvictStrategyMockRecordInsertionParams[K]{k1},
		expectationOrigins: EvictStrategyMockRecordInsertionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRecordInsertion.expectations = append(mmRecordInsertion.expectations, expectation)
	return expectation
}

// Then sets up EvictStrategy.RecordInsertion return parameters for the expectation previously defined by the When method
func (e *EvictStrategyMockRecordInsertionExpectation[K]) Then(evictK K, shouldEvict bool) *EvictStrategyMock[K] {
	e.results = &EvictStrategyMockRecordInsertionResults[K]{evictK, shouldEvict}
	return e.mock
}

// Times sets number of times EvictStrategy.RecordInsertion should be invoked
func (mmRecordInsertion *mEvictStrategyMockRecordInsertion[K]) Times(n uint64) *mEvictStrategyMockRecordInsertion[K] {
	if n == 0 {
		mmRecordInsertion.mock.t.Fatalf("Times of EvictStrategyMock.RecordInsertion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRecordInsertion.expectedInvocations, n)
	mmRecordInsertion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRecordInsertion
}

func (mmRecordInsertion *mEvictStrategyMockRecordInsertion[K]) invocationsDone() bool {
	if len(mmRecordInsertion.expectations) == 0 && mmRecordInsertion.defaultExpectation == nil && mmRecordInsertion.mock.funcRecordInsertion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRecordInsertion.mock.afterRecordInsertionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRecordInsertion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RecordInsertion implements mm_cache.EvictStrategy
func (mmRecordInsertion *EvictStrategyMock[K]) RecordInsertion(k1 K) (evictK K, shouldEvict bool) {
	mm_atomic.AddUint64(&mmRecordInsertion.beforeRecordInsertionCounter, 1)
	defer mm_atomic.AddUint64(&mmRecordInsertion.afterRecordInsertionCounter, 1)

	mmRecordInsertion.t.Helper()

	if mmRecordInsertion.inspectFuncRecordInsertion != nil {
		mmRecordInsertion.inspectFuncRecordInsertion(k1)
	}

	mm_params := EvictStrategyMockRecordInsertionParams[K]{k1}

	// Record call args
	mmRecordInsertion.RecordInsertionMock.mutex.Lock()
	mmRecordInsertion.RecordInsertionMock.callArgs = append(mmRecordInsertion.RecordInsertionMock.callArgs, &mm_params)
	mmRecordInsertion.RecordInsertionMock.mutex.Unlock()

	for _, e := range mmRecordInsertion.RecordInsertionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.evictK, e.results.shouldEvict
		}
	}

	if mmRecordInsertion.RecordInsertionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecordInsertion.RecordInsertionMock.defaultExpectation.Counter, 1)
		mm_want := mmRecordInsertion.RecordInsertionMock.defaultExpectation.params
		mm_want_ptrs := mmRecordInsertion.RecordInsertionMock.defaultExpectation.paramPtrs

		mm_got := EvictStrategyMockRecordInsertionParams[K]{k1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.k1 != nil && !minimock.Equal(*mm_want_ptrs.k1, mm_got.k1) {
				mmRecordInsertion.t.Errorf("EvictStrategyMock.RecordInsertion got unexpected parameter k1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRecordInsertion.RecordInsertionMock.defaultExpectation.expectationOrigins.originK1, *mm_want_ptrs.k1, mm_got.k1, minimock.Diff(*mm_want_ptrs.k1, mm_got.k1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRecordInsertion.t.Errorf("EvictStrategyMock.RecordInsertion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRecordInsertion.RecordInsertionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRecordInsertion.RecordInsertionMock.defaultExpectation.results
		if mm_results == nil {
			mmRecordInsertion.t.Fatal("No results are set for the EvictStrategyMock.RecordInsertion")
		}
		return (*mm_results).evictK, (*mm_results).shouldEvict
	}
	if mmRecordInsertion.funcRecordInsertion != nil {
		return mmRecordInsertion.funcRecordInsertion(k1)
	}
	mmRecordInsertion.t.Fatalf("Unexpected call to EvictStrategyMock.RecordInsertion. %v", k1)
	return
}

// RecordInsertionAfterCounter returns a count of finished EvictStrategyMock.RecordInsertion invocations
func (mmRecordInsertion *EvictStrategyMock[K]) RecordInsertionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecordInsertion.afterRecordInsertionCounter)
}

// RecordInsertionBeforeCounter returns a count of EvictStrategyMock.RecordInsertion invocations
func (mmRecordInsertion *EvictStrategyMock[K]) RecordInsertionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecordInsertion.beforeRecordInsertionCounter)
}

// Calls returns a list of arguments used in each call to EvictStrategyMock.RecordInsertion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRecordInsertion *mEvictStrategyMockRecordInsertion[K]) Calls() []*EvictStrategyMockRecordInsertionParams[K] {
	mmRecordInsertion.mutex.RLock()

	argCopy := make([]*EvictStrategyMockRecordInsertionParams[K], len(mmRecordInsertion.callArgs))
	copy(argCopy, mmRecordInsertion.callArgs)

	mmRecordInsertion.mutex.RUnlock()

	return argCopy
}

// MinimockRecordInsertionDone returns true if the count of the RecordInsertion invocations corresponds
// the number of defined expectations
func (m *EvictStrategyMock[K]) MinimockRecordInsertionDone() bool {
	if m.RecordInsertionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RecordInsertionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RecordInsertionMock.invocationsDone()
}

// MinimockRecordInsertionInspect logs each unmet expectation
func (m *EvictStrategyMock[K]) MinimockRecordInsertionInspect() {
	for _, e := range m.RecordInsertionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EvictStrategyMock.RecordInsertion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRecordInsertionCounter := mm_atomic.LoadUint64(&m.afterRecordInsertionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RecordInsertionMock.defaultExpectation != nil && afterRecordInsertionCounter < 1 {
		if m.RecordInsertionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EvictStrategyMock.RecordInsertion at\n%s", m.RecordInsertionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EvictStrategyMock.RecordInsertion at\n%s with params: %#v", m.RecordInsertionMock.defaultExpectation.expectationOrigins.origin, *m.RecordInsertionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecordInsertion != nil && afterRecordInsertionCounter < 1 {
		m.t.Errorf("Expected call to EvictStrategyMock.RecordInsertion at\n%s", m.funcRecordInsertionOrigin)
	}

	if !m.RecordInsertionMock.invocationsDone() && afterRecordInsertionCounter > 0 {
		m.t.Errorf("Expected %d calls to EvictStrategyMock.RecordInsertion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RecordInsertionMock.expectedInvocations), m.RecordInsertionMock.expectedInvocationsOrigin, afterRecordInsertionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *EvictStrategyMock[K]) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockRecordAccessInspect()

			m.MinimockRecordDeletionInspect()

			m.MinimockRecordInsertionInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *EvictStrategyMock[K]) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *EvictStrategyMock[K]) minimockDone() bool {
	done := true
	return done &&
		m.MinimockRecordAccessDone() &&
		m.MinimockRecordDeletionDone() &&
		m.MinimockRecordInsertionDone()
}
