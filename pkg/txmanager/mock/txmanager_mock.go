// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i pvz-cli/pkg/txmanager.TxManager -o txmanager_mock.go -n TxManagerMock -p mock

import (
	"context"
	mm_txmanager "pvz-cli/pkg/txmanager"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgx/v5"
)

// TxManagerMock implements mm_txmanager.TxManager
type TxManagerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetExecutor          func(ctx context.Context) (e1 mm_txmanager.Executor)
	funcGetExecutorOrigin    string
	inspectFuncGetExecutor   func(ctx context.Context)
	afterGetExecutorCounter  uint64
	beforeGetExecutorCounter uint64
	GetExecutorMock          mTxManagerMockGetExecutor

	funcWithReadOnly          func(ctx context.Context) (c2 context.Context)
	funcWithReadOnlyOrigin    string
	inspectFuncWithReadOnly   func(ctx context.Context)
	afterWithReadOnlyCounter  uint64
	beforeWithReadOnlyCounter uint64
	WithReadOnlyMock          mTxManagerMockWithReadOnly

	funcWithTx          func(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error) (err error)
	funcWithTxOrigin    string
	inspectFuncWithTx   func(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error)
	afterWithTxCounter  uint64
	beforeWithTxCounter uint64
	WithTxMock          mTxManagerMockWithTx
}

// NewTxManagerMock returns a mock for mm_txmanager.TxManager
func NewTxManagerMock(t minimock.Tester) *TxManagerMock {
	m := &TxManagerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetExecutorMock = mTxManagerMockGetExecutor{mock: m}
	m.GetExecutorMock.callArgs = []*TxManagerMockGetExecutorParams{}

	m.WithReadOnlyMock = mTxManagerMockWithReadOnly{mock: m}
	m.WithReadOnlyMock.callArgs = []*TxManagerMockWithReadOnlyParams{}

	m.WithTxMock = mTxManagerMockWithTx{mock: m}
	m.WithTxMock.callArgs = []*TxManagerMockWithTxParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTxManagerMockGetExecutor struct {
	optional           bool
	mock               *TxManagerMock
	defaultExpectation *TxManagerMockGetExecutorExpectation
	expectations       []*TxManagerMockGetExecutorExpectation

	callArgs []*TxManagerMockGetExecutorParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TxManagerMockGetExecutorExpectation specifies expectation struct of the TxManager.GetExecutor
type TxManagerMockGetExecutorExpectation struct {
	mock               *TxManagerMock
	params             *TxManagerMockGetExecutorParams
	paramPtrs          *TxManagerMockGetExecutorParamPtrs
	expectationOrigins TxManagerMockGetExecutorExpectationOrigins
	results            *TxManagerMockGetExecutorResults
	returnOrigin       string
	Counter            uint64
}

// TxManagerMockGetExecutorParams contains parameters of the TxManager.GetExecutor
type TxManagerMockGetExecutorParams struct {
	ctx context.Context
}

// TxManagerMockGetExecutorParamPtrs contains pointers to parameters of the TxManager.GetExecutor
type TxManagerMockGetExecutorParamPtrs struct {
	ctx *context.Context
}

// TxManagerMockGetExecutorResults contains results of the TxManager.GetExecutor
type TxManagerMockGetExecutorResults struct {
	e1 mm_txmanager.Executor
}

// TxManagerMockGetExecutorOrigins contains origins of expectations of the TxManager.GetExecutor
type TxManagerMockGetExecutorExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetExecutor *mTxManagerMockGetExecutor) Optional() *mTxManagerMockGetExecutor {
	mmGetExecutor.optional = true
	return mmGetExecutor
}

// Expect sets up expected params for TxManager.GetExecutor
func (mmGetExecutor *mTxManagerMockGetExecutor) Expect(ctx context.Context) *mTxManagerMockGetExecutor {
	if mmGetExecutor.mock.funcGetExecutor != nil {
		mmGetExecutor.mock.t.Fatalf("TxManagerMock.GetExecutor mock is already set by Set")
	}

	if mmGetExecutor.defaultExpectation == nil {
		mmGetExecutor.defaultExpectation = &TxManagerMockGetExecutorExpectation{}
	}

	if mmGetExecutor.defaultExpectation.paramPtrs != nil {
		mmGetExecutor.mock.t.Fatalf("TxManagerMock.GetExecutor mock is already set by ExpectParams functions")
	}

	mmGetExecutor.defaultExpectation.params = &TxManagerMockGetExecutorParams{ctx}
	mmGetExecutor.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetExecutor.expectations {
		if minimock.Equal(e.params, mmGetExecutor.defaultExpectation.params) {
			mmGetExecutor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetExecutor.defaultExpectation.params)
		}
	}

	return mmGetExecutor
}

// ExpectCtxParam1 sets up expected param ctx for TxManager.GetExecutor
func (mmGetExecutor *mTxManagerMockGetExecutor) ExpectCtxParam1(ctx context.Context) *mTxManagerMockGetExecutor {
	if mmGetExecutor.mock.funcGetExecutor != nil {
		mmGetExecutor.mock.t.Fatalf("TxManagerMock.GetExecutor mock is already set by Set")
	}

	if mmGetExecutor.defaultExpectation == nil {
		mmGetExecutor.defaultExpectation = &TxManagerMockGetExecutorExpectation{}
	}

	if mmGetExecutor.defaultExpectation.params != nil {
		mmGetExecutor.mock.t.Fatalf("TxManagerMock.GetExecutor mock is already set by Expect")
	}

	if mmGetExecutor.defaultExpectation.paramPtrs == nil {
		mmGetExecutor.defaultExpectation.paramPtrs = &TxManagerMockGetExecutorParamPtrs{}
	}
	mmGetExecutor.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetExecutor.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetExecutor
}

// Inspect accepts an inspector function that has same arguments as the TxManager.GetExecutor
func (mmGetExecutor *mTxManagerMockGetExecutor) Inspect(f func(ctx context.Context)) *mTxManagerMockGetExecutor {
	if mmGetExecutor.mock.inspectFuncGetExecutor != nil {
		mmGetExecutor.mock.t.Fatalf("Inspect function is already set for TxManagerMock.GetExecutor")
	}

	mmGetExecutor.mock.inspectFuncGetExecutor = f

	return mmGetExecutor
}

// Return sets up results that will be returned by TxManager.GetExecutor
func (mmGetExecutor *mTxManagerMockGetExecutor) Return(e1 mm_txmanager.Executor) *TxManagerMock {
	if mmGetExecutor.mock.funcGetExecutor != nil {
		mmGetExecutor.mock.t.Fatalf("TxManagerMock.GetExecutor mock is already set by Set")
	}

	if mmGetExecutor.defaultExpectation == nil {
		mmGetExecutor.defaultExpectation = &TxManagerMockGetExecutorExpectation{mock: mmGetExecutor.mock}
	}
	mmGetExecutor.defaultExpectation.results = &TxManagerMockGetExecutorResults{e1}
	mmGetExecutor.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetExecutor.mock
}

// Set uses given function f to mock the TxManager.GetExecutor method
func (mmGetExecutor *mTxManagerMockGetExecutor) Set(f func(ctx context.Context) (e1 mm_txmanager.Executor)) *TxManagerMock {
	if mmGetExecutor.defaultExpectation != nil {
		mmGetExecutor.mock.t.Fatalf("Default expectation is already set for the TxManager.GetExecutor method")
	}

	if len(mmGetExecutor.expectations) > 0 {
		mmGetExecutor.mock.t.Fatalf("Some expectations are already set for the TxManager.GetExecutor method")
	}

	mmGetExecutor.mock.funcGetExecutor = f
	mmGetExecutor.mock.funcGetExecutorOrigin = minimock.CallerInfo(1)
	return mmGetExecutor.mock
}

// When sets expectation for the TxManager.GetExecutor which will trigger the result defined by the following
// Then helper
func (mmGetExecutor *mTxManagerMockGetExecutor) When(ctx context.Context) *TxManagerMockGetExecutorExpectation {
	if mmGetExecutor.mock.funcGetExecutor != nil {
		mmGetExecutor.mock.t.Fatalf("TxManagerMock.GetExecutor mock is already set by Set")
	}

	expectation := &TxManagerMockGetExecutorExpectation{
		mock:               mmGetExecutor.mock,
		params:             &TxManagerMockGetExecutorParams{ctx},
		expectationOrigins: TxManagerMockGetExecutorExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetExecutor.expectations = append(mmGetExecutor.expectations, expectation)
	return expectation
}

// Then sets up TxManager.GetExecutor return parameters for the expectation previously defined by the When method
func (e *TxManagerMockGetExecutorExpectation) Then(e1 mm_txmanager.Executor) *TxManagerMock {
	e.results = &TxManagerMockGetExecutorResults{e1}
	return e.mock
}

// Times sets number of times TxManager.GetExecutor should be invoked
func (mmGetExecutor *mTxManagerMockGetExecutor) Times(n uint64) *mTxManagerMockGetExecutor {
	if n == 0 {
		mmGetExecutor.mock.t.Fatalf("Times of TxManagerMock.GetExecutor mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetExecutor.expectedInvocations, n)
	mmGetExecutor.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetExecutor
}

func (mmGetExecutor *mTxManagerMockGetExecutor) invocationsDone() bool {
	if len(mmGetExecutor.expectations) == 0 && mmGetExecutor.defaultExpectation == nil && mmGetExecutor.mock.funcGetExecutor == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetExecutor.mock.afterGetExecutorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetExecutor.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetExecutor implements mm_txmanager.TxManager
func (mmGetExecutor *TxManagerMock) GetExecutor(ctx context.Context) (e1 mm_txmanager.Executor) {
	mm_atomic.AddUint64(&mmGetExecutor.beforeGetExecutorCounter, 1)
	defer mm_atomic.AddUint64(&mmGetExecutor.afterGetExecutorCounter, 1)

	mmGetExecutor.t.Helper()

	if mmGetExecutor.inspectFuncGetExecutor != nil {
		mmGetExecutor.inspectFuncGetExecutor(ctx)
	}

	mm_params := TxManagerMockGetExecutorParams{ctx}

	// Record call args
	mmGetExecutor.GetExecutorMock.mutex.Lock()
	mmGetExecutor.GetExecutorMock.callArgs = append(mmGetExecutor.GetExecutorMock.callArgs, &mm_params)
	mmGetExecutor.GetExecutorMock.mutex.Unlock()

	for _, e := range mmGetExecutor.GetExecutorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1
		}
	}

	if mmGetExecutor.GetExecutorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetExecutor.GetExecutorMock.defaultExpectation.Counter, 1)
		mm_want := mmGetExecutor.GetExecutorMock.defaultExpectation.params
		mm_want_ptrs := mmGetExecutor.GetExecutorMock.defaultExpectation.paramPtrs

		mm_got := TxManagerMockGetExecutorParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetExecutor.t.Errorf("TxManagerMock.GetExecutor got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetExecutor.GetExecutorMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetExecutor.t.Errorf("TxManagerMock.GetExecutor got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetExecutor.GetExecutorMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetExecutor.GetExecutorMock.defaultExpectation.results
		if mm_results == nil {
			mmGetExecutor.t.Fatal("No results are set for the TxManagerMock.GetExecutor")
		}
		return (*mm_results).e1
	}
	if mmGetExecutor.funcGetExecutor != nil {
		return mmGetExecutor.funcGetExecutor(ctx)
	}
	mmGetExecutor.t.Fatalf("Unexpected call to TxManagerMock.GetExecutor. %v", ctx)
	return
}

// GetExecutorAfterCounter returns a count of finished TxManagerMock.GetExecutor invocations
func (mmGetExecutor *TxManagerMock) GetExecutorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExecutor.afterGetExecutorCounter)
}

// GetExecutorBeforeCounter returns a count of TxManagerMock.GetExecutor invocations
func (mmGetExecutor *TxManagerMock) GetExecutorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExecutor.beforeGetExecutorCounter)
}

// Calls returns a list of arguments used in each call to TxManagerMock.GetExecutor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetExecutor *mTxManagerMockGetExecutor) Calls() []*TxManagerMockGetExecutorParams {
	mmGetExecutor.mutex.RLock()

	argCopy := make([]*TxManagerMockGetExecutorParams, len(mmGetExecutor.callArgs))
	copy(argCopy, mmGetExecutor.callArgs)

	mmGetExecutor.mutex.RUnlock()

	return argCopy
}

// MinimockGetExecutorDone returns true if the count of the GetExecutor invocations corresponds
// the number of defined expectations
func (m *TxManagerMock) MinimockGetExecutorDone() bool {
	if m.GetExecutorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetExecutorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetExecutorMock.invocationsDone()
}

// MinimockGetExecutorInspect logs each unmet expectation
func (m *TxManagerMock) MinimockGetExecutorInspect() {
	for _, e := range m.GetExecutorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxManagerMock.GetExecutor at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetExecutorCounter := mm_atomic.LoadUint64(&m.afterGetExecutorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetExecutorMock.defaultExpectation != nil && afterGetExecutorCounter < 1 {
		if m.GetExecutorMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TxManagerMock.GetExecutor at\n%s", m.GetExecutorMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TxManagerMock.GetExecutor at\n%s with params: %#v", m.GetExecutorMock.defaultExpectation.expectationOrigins.origin, *m.GetExecutorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExecutor != nil && afterGetExecutorCounter < 1 {
		m.t.Errorf("Expected call to TxManagerMock.GetExecutor at\n%s", m.funcGetExecutorOrigin)
	}

	if !m.GetExecutorMock.invocationsDone() && afterGetExecutorCounter > 0 {
		m.t.Errorf("Expected %d calls to TxManagerMock.GetExecutor at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetExecutorMock.expectedInvocations), m.GetExecutorMock.expectedInvocationsOrigin, afterGetExecutorCounter)
	}
}

type mTxManagerMockWithReadOnly struct {
	optional           bool
	mock               *TxManagerMock
	defaultExpectation *TxManagerMockWithReadOnlyExpectation
	expectations       []*TxManagerMockWithReadOnlyExpectation

	callArgs []*TxManagerMockWithReadOnlyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TxManagerMockWithReadOnlyExpectation specifies expectation struct of the TxManager.WithReadOnly
type TxManagerMockWithReadOnlyExpectation struct {
	mock               *TxManagerMock
	params             *TxManagerMockWithReadOnlyParams
	paramPtrs          *TxManagerMockWithReadOnlyParamPtrs
	expectationOrigins TxManagerMockWithReadOnlyExpectationOrigins
	results            *TxManagerMockWithReadOnlyResults
	returnOrigin       string
	Counter            uint64
}

// TxManagerMockWithReadOnlyParams contains parameters of the TxManager.WithReadOnly
type TxManagerMockWithReadOnlyParams struct {
	ctx context.Context
}

// TxManagerMockWithReadOnlyParamPtrs contains pointers to parameters of the TxManager.WithReadOnly
type TxManagerMockWithReadOnlyParamPtrs struct {
	ctx *context.Context
}

// TxManagerMockWithReadOnlyResults contains results of the TxManager.WithReadOnly
type TxManagerMockWithReadOnlyResults struct {
	c2 context.Context
}

// TxManagerMockWithReadOnlyOrigins contains origins of expectations of the TxManager.WithReadOnly
type TxManagerMockWithReadOnlyExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWithReadOnly *mTxManagerMockWithReadOnly) Optional() *mTxManagerMockWithReadOnly {
	mmWithReadOnly.optional = true
	return mmWithReadOnly
}

// Expect sets up expected params for TxManager.WithReadOnly
func (mmWithReadOnly *mTxManagerMockWithReadOnly) Expect(ctx context.Context) *mTxManagerMockWithReadOnly {
	if mmWithReadOnly.mock.funcWithReadOnly != nil {
		mmWithReadOnly.mock.t.Fatalf("TxManagerMock.WithReadOnly mock is already set by Set")
	}

	if mmWithReadOnly.defaultExpectation == nil {
		mmWithReadOnly.defaultExpectation = &TxManagerMockWithReadOnlyExpectation{}
	}

	if mmWithReadOnly.defaultExpectation.paramPtrs != nil {
		mmWithReadOnly.mock.t.Fatalf("TxManagerMock.WithReadOnly mock is already set by ExpectParams functions")
	}

	mmWithReadOnly.defaultExpectation.params = &TxManagerMockWithReadOnlyParams{ctx}
	mmWithReadOnly.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWithReadOnly.expectations {
		if minimock.Equal(e.params, mmWithReadOnly.defaultExpectation.params) {
			mmWithReadOnly.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithReadOnly.defaultExpectation.params)
		}
	}

	return mmWithReadOnly
}

// ExpectCtxParam1 sets up expected param ctx for TxManager.WithReadOnly
func (mmWithReadOnly *mTxManagerMockWithReadOnly) ExpectCtxParam1(ctx context.Context) *mTxManagerMockWithReadOnly {
	if mmWithReadOnly.mock.funcWithReadOnly != nil {
		mmWithReadOnly.mock.t.Fatalf("TxManagerMock.WithReadOnly mock is already set by Set")
	}

	if mmWithReadOnly.defaultExpectation == nil {
		mmWithReadOnly.defaultExpectation = &TxManagerMockWithReadOnlyExpectation{}
	}

	if mmWithReadOnly.defaultExpectation.params != nil {
		mmWithReadOnly.mock.t.Fatalf("TxManagerMock.WithReadOnly mock is already set by Expect")
	}

	if mmWithReadOnly.defaultExpectation.paramPtrs == nil {
		mmWithReadOnly.defaultExpectation.paramPtrs = &TxManagerMockWithReadOnlyParamPtrs{}
	}
	mmWithReadOnly.defaultExpectation.paramPtrs.ctx = &ctx
	mmWithReadOnly.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWithReadOnly
}

// Inspect accepts an inspector function that has same arguments as the TxManager.WithReadOnly
func (mmWithReadOnly *mTxManagerMockWithReadOnly) Inspect(f func(ctx context.Context)) *mTxManagerMockWithReadOnly {
	if mmWithReadOnly.mock.inspectFuncWithReadOnly != nil {
		mmWithReadOnly.mock.t.Fatalf("Inspect function is already set for TxManagerMock.WithReadOnly")
	}

	mmWithReadOnly.mock.inspectFuncWithReadOnly = f

	return mmWithReadOnly
}

// Return sets up results that will be returned by TxManager.WithReadOnly
func (mmWithReadOnly *mTxManagerMockWithReadOnly) Return(c2 context.Context) *TxManagerMock {
	if mmWithReadOnly.mock.funcWithReadOnly != nil {
		mmWithReadOnly.mock.t.Fatalf("TxManagerMock.WithReadOnly mock is already set by Set")
	}

	if mmWithReadOnly.defaultExpectation == nil {
		mmWithReadOnly.defaultExpectation = &TxManagerMockWithReadOnlyExpectation{mock: mmWithReadOnly.mock}
	}
	mmWithReadOnly.defaultExpectation.results = &TxManagerMockWithReadOnlyResults{c2}
	mmWithReadOnly.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWithReadOnly.mock
}

// Set uses given function f to mock the TxManager.WithReadOnly method
func (mmWithReadOnly *mTxManagerMockWithReadOnly) Set(f func(ctx context.Context) (c2 context.Context)) *TxManagerMock {
	if mmWithReadOnly.defaultExpectation != nil {
		mmWithReadOnly.mock.t.Fatalf("Default expectation is already set for the TxManager.WithReadOnly method")
	}

	if len(mmWithReadOnly.expectations) > 0 {
		mmWithReadOnly.mock.t.Fatalf("Some expectations are already set for the TxManager.WithReadOnly method")
	}

	mmWithReadOnly.mock.funcWithReadOnly = f
	mmWithReadOnly.mock.funcWithReadOnlyOrigin = minimock.CallerInfo(1)
	return mmWithReadOnly.mock
}

// When sets expectation for the TxManager.WithReadOnly which will trigger the result defined by the following
// Then helper
func (mmWithReadOnly *mTxManagerMockWithReadOnly) When(ctx context.Context) *TxManagerMockWithReadOnlyExpectation {
	if mmWithReadOnly.mock.funcWithReadOnly != nil {
		mmWithReadOnly.mock.t.Fatalf("TxManagerMock.WithReadOnly mock is already set by Set")
	}

	expectation := &TxManagerMockWithReadOnlyExpectation{
		mock:               mmWithReadOnly.mock,
		params:             &TxManagerMockWithReadOnlyParams{ctx},
		expectationOrigins: TxManagerMockWithReadOnlyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWithReadOnly.expectations = append(mmWithReadOnly.expectations, expectation)
	return expectation
}

// Then sets up TxManager.WithReadOnly return parameters for the expectation previously defined by the When method
func (e *TxManagerMockWithReadOnlyExpectation) Then(c2 context.Context) *TxManagerMock {
	e.results = &TxManagerMockWithReadOnlyResults{c2}
	return e.mock
}

// Times sets number of times TxManager.WithReadOnly should be invoked
func (mmWithReadOnly *mTxManagerMockWithReadOnly) Times(n uint64) *mTxManagerMockWithReadOnly {
	if n == 0 {
		mmWithReadOnly.mock.t.Fatalf("Times of TxManagerMock.WithReadOnly mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWithReadOnly.expectedInvocations, n)
	mmWithReadOnly.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWithReadOnly
}

func (mmWithReadOnly *mTxManagerMockWithReadOnly) invocationsDone() bool {
	if len(mmWithReadOnly.expectations) == 0 && mmWithReadOnly.defaultExpectation == nil && mmWithReadOnly.mock.funcWithReadOnly == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWithReadOnly.mock.afterWithReadOnlyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWithReadOnly.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WithReadOnly implements mm_txmanager.TxManager
func (mmWithReadOnly *TxManagerMock) WithReadOnly(ctx context.Context) (c2 context.Context) {
	mm_atomic.AddUint64(&mmWithReadOnly.beforeWithReadOnlyCounter, 1)
	defer mm_atomic.AddUint64(&mmWithReadOnly.afterWithReadOnlyCounter, 1)

	mmWithReadOnly.t.Helper()

	if mmWithReadOnly.inspectFuncWithReadOnly != nil {
		mmWithReadOnly.inspectFuncWithReadOnly(ctx)
	}

	mm_params := TxManagerMockWithReadOnlyParams{ctx}

	// Record call args
	mmWithReadOnly.WithReadOnlyMock.mutex.Lock()
	mmWithReadOnly.WithReadOnlyMock.callArgs = append(mmWithReadOnly.WithReadOnlyMock.callArgs, &mm_params)
	mmWithReadOnly.WithReadOnlyMock.mutex.Unlock()

	for _, e := range mmWithReadOnly.WithReadOnlyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2
		}
	}

	if mmWithReadOnly.WithReadOnlyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithReadOnly.WithReadOnlyMock.defaultExpectation.Counter, 1)
		mm_want := mmWithReadOnly.WithReadOnlyMock.defaultExpectation.params
		mm_want_ptrs := mmWithReadOnly.WithReadOnlyMock.defaultExpectation.paramPtrs

		mm_got := TxManagerMockWithReadOnlyParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWithReadOnly.t.Errorf("TxManagerMock.WithReadOnly got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWithReadOnly.WithReadOnlyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithReadOnly.t.Errorf("TxManagerMock.WithReadOnly got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWithReadOnly.WithReadOnlyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithReadOnly.WithReadOnlyMock.defaultExpectation.results
		if mm_results == nil {
			mmWithReadOnly.t.Fatal("No results are set for the TxManagerMock.WithReadOnly")
		}
		return (*mm_results).c2
	}
	if mmWithReadOnly.funcWithReadOnly != nil {
		return mmWithReadOnly.funcWithReadOnly(ctx)
	}
	mmWithReadOnly.t.Fatalf("Unexpected call to TxManagerMock.WithReadOnly. %v", ctx)
	return
}

// WithReadOnlyAfterCounter returns a count of finished TxManagerMock.WithReadOnly invocations
func (mmWithReadOnly *TxManagerMock) WithReadOnlyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithReadOnly.afterWithReadOnlyCounter)
}

// WithReadOnlyBeforeCounter returns a count of TxManagerMock.WithReadOnly invocations
func (mmWithReadOnly *TxManagerMock) WithReadOnlyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithReadOnly.beforeWithReadOnlyCounter)
}

// Calls returns a list of arguments used in each call to TxManagerMock.WithReadOnly.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithReadOnly *mTxManagerMockWithReadOnly) Calls() []*TxManagerMockWithReadOnlyParams {
	mmWithReadOnly.mutex.RLock()

	argCopy := make([]*TxManagerMockWithReadOnlyParams, len(mmWithReadOnly.callArgs))
	copy(argCopy, mmWithReadOnly.callArgs)

	mmWithReadOnly.mutex.RUnlock()

	return argCopy
}

// MinimockWithReadOnlyDone returns true if the count of the WithReadOnly invocations corresponds
// the number of defined expectations
func (m *TxManagerMock) MinimockWithReadOnlyDone() bool {
	if m.WithReadOnlyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WithReadOnlyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WithReadOnlyMock.invocationsDone()
}

// MinimockWithReadOnlyInspect logs each unmet expectation
func (m *TxManagerMock) MinimockWithReadOnlyInspect() {
	for _, e := range m.WithReadOnlyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxManagerMock.WithReadOnly at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWithReadOnlyCounter := mm_atomic.LoadUint64(&m.afterWithReadOnlyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WithReadOnlyMock.defaultExpectation != nil && afterWithReadOnlyCounter < 1 {
		if m.WithReadOnlyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TxManagerMock.WithReadOnly at\n%s", m.WithReadOnlyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TxManagerMock.WithReadOnly at\n%s with params: %#v", m.WithReadOnlyMock.defaultExpectation.expectationOrigins.origin, *m.WithReadOnlyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithReadOnly != nil && afterWithReadOnlyCounter < 1 {
		m.t.Errorf("Expected call to TxManagerMock.WithReadOnly at\n%s", m.funcWithReadOnlyOrigin)
	}

	if !m.WithReadOnlyMock.invocationsDone() && afterWithReadOnlyCounter > 0 {
		m.t.Errorf("Expected %d calls to TxManagerMock.WithReadOnly at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WithReadOnlyMock.expectedInvocations), m.WithReadOnlyMock.expectedInvocationsOrigin, afterWithReadOnlyCounter)
	}
}

type mTxManagerMockWithTx struct {
	optional           bool
	mock               *TxManagerMock
	defaultExpectation *TxManagerMockWithTxExpectation
	expectations       []*TxManagerMockWithTxExpectation

	callArgs []*TxManagerMockWithTxParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TxManagerMockWithTxExpectation specifies expectation struct of the TxManager.WithTx
type TxManagerMockWithTxExpectation struct {
	mock               *TxManagerMock
	params             *TxManagerMockWithTxParams
	paramPtrs          *TxManagerMockWithTxParamPtrs
	expectationOrigins TxManagerMockWithTxExpectationOrigins
	results            *TxManagerMockWithTxResults
	returnOrigin       string
	Counter            uint64
}

// TxManagerMockWithTxParams contains parameters of the TxManager.WithTx
type TxManagerMockWithTxParams struct {
	ctx        context.Context
	isoLevel   pgx.TxIsoLevel
	accessMode pgx.TxAccessMode
	fn         func(ctx context.Context) error
}

// TxManagerMockWithTxParamPtrs contains pointers to parameters of the TxManager.WithTx
type TxManagerMockWithTxParamPtrs struct {
	ctx        *context.Context
	isoLevel   *pgx.TxIsoLevel
	accessMode *pgx.TxAccessMode
	fn         *func(ctx context.Context) error
}

// TxManagerMockWithTxResults contains results of the TxManager.WithTx
type TxManagerMockWithTxResults struct {
	err error
}

// TxManagerMockWithTxOrigins contains origins of expectations of the TxManager.WithTx
type TxManagerMockWithTxExpectationOrigins struct {
	origin           string
	originCtx        string
	originIsoLevel   string
	originAccessMode string
	originFn         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWithTx *mTxManagerMockWithTx) Optional() *mTxManagerMockWithTx {
	mmWithTx.optional = true
	return mmWithTx
}

// Expect sets up expected params for TxManager.WithTx
func (mmWithTx *mTxManagerMockWithTx) Expect(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error) *mTxManagerMockWithTx {
	if mmWithTx.mock.funcWithTx != nil {
		mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Set")
	}

	if mmWithTx.defaultExpectation == nil {
		mmWithTx.defaultExpectation = &TxManagerMockWithTxExpectation{}
	}

	if mmWithTx.defaultExpectation.paramPtrs != nil {
		mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by ExpectParams functions")
	}

	mmWithTx.defaultExpectation.params = &TxManagerMockWithTxParams{ctx, isoLevel, accessMode, fn}
	mmWithTx.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWithTx.expectations {
		if minimock.Equal(e.params, mmWithTx.defaultExpectation.params) {
			mmWithTx.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithTx.defaultExpectation.params)
		}
	}

	return mmWithTx
}

// ExpectCtxParam1 sets up expected param ctx for TxManager.WithTx
func (mmWithTx *mTxManagerMockWithTx) ExpectCtxParam1(ctx context.Context) *mTxManagerMockWithTx {
	if mmWithTx.mock.funcWithTx != nil {
		mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Set")
	}

	if mmWithTx.defaultExpectation == nil {
		mmWithTx.defaultExpectation = &TxManagerMockWithTxExpectation{}
	}

	if mmWithTx.defaultExpectation.params != nil {
		mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Expect")
	}

	if mmWithTx.defaultExpectation.paramPtrs == nil {
		mmWithTx.defaultExpectation.paramPtrs = &TxManagerMockWithTxParamPtrs{}
	}
	mmWithTx.defaultExpectation.paramPtrs.ctx = &ctx
	mmWithTx.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWithTx
}

// ExpectIsoLevelParam2 sets up expected param isoLevel for TxManager.WithTx
func (mmWithTx *mTxManagerMockWithTx) ExpectIsoLevelParam2(isoLevel pgx.TxIsoLevel) *mTxManagerMockWithTx {
	if mmWithTx.mock.funcWithTx != nil {
		mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Set")
	}

	if mmWithTx.defaultExpectation == nil {
		mmWithTx.defaultExpectation = &TxManagerMockWithTxExpectation{}
	}

	if mmWithTx.defaultExpectation.params != nil {
		mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Expect")
	}

	if mmWithTx.defaultExpectation.paramPtrs == nil {
		mmWithTx.defaultExpectation.paramPtrs = &TxManagerMockWithTxParamPtrs{}
	}
	mmWithTx.defaultExpectation.paramPtrs.isoLevel = &isoLevel
	mmWithTx.defaultExpectation.expectationOrigins.originIsoLevel = minimock.CallerInfo(1)

	return mmWithTx
}

// ExpectAccessModeParam3 sets up expected param accessMode for TxManager.WithTx
func (mmWithTx *mTxManagerMockWithTx) ExpectAccessModeParam3(accessMode pgx.TxAccessMode) *mTxManagerMockWithTx {
	if mmWithTx.mock.funcWithTx != nil {
		mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Set")
	}

	if mmWithTx.defaultExpectation == nil {
		mmWithTx.defaultExpectation = &TxManagerMockWithTxExpectation{}
	}

	if mmWithTx.defaultExpectation.params != nil {
		mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Expect")
	}

	if mmWithTx.defaultExpectation.paramPtrs == nil {
		mmWithTx.defaultExpectation.paramPtrs = &TxManagerMockWithTxParamPtrs{}
	}
	mmWithTx.defaultExpectation.paramPtrs.accessMode = &accessMode
	mmWithTx.defaultExpectation.expectationOrigins.originAccessMode = minimock.CallerInfo(1)

	return mmWithTx
}

// ExpectFnParam4 sets up expected param fn for TxManager.WithTx
func (mmWithTx *mTxManagerMockWithTx) ExpectFnParam4(fn func(ctx context.Context) error) *mTxManagerMockWithTx {
	if mmWithTx.mock.funcWithTx != nil {
		mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Set")
	}

	if mmWithTx.defaultExpectation == nil {
		mmWithTx.defaultExpectation = &TxManagerMockWithTxExpectation{}
	}

	if mmWithTx.defaultExpectation.params != nil {
		mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Expect")
	}

	if mmWithTx.defaultExpectation.paramPtrs == nil {
		mmWithTx.defaultExpectation.paramPtrs = &TxManagerMockWithTxParamPtrs{}
	}
	mmWithTx.defaultExpectation.paramPtrs.fn = &fn
	mmWithTx.defaultExpectation.expectationOrigins.originFn = minimock.CallerInfo(1)

	return mmWithTx
}

// Inspect accepts an inspector function that has same arguments as the TxManager.WithTx
func (mmWithTx *mTxManagerMockWithTx) Inspect(f func(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error)) *mTxManagerMockWithTx {
	if mmWithTx.mock.inspectFuncWithTx != nil {
		mmWithTx.mock.t.Fatalf("Inspect function is already set for TxManagerMock.WithTx")
	}

	mmWithTx.mock.inspectFuncWithTx = f

	return mmWithTx
}

// Return sets up results that will be returned by TxManager.WithTx
func (mmWithTx *mTxManagerMockWithTx) Return(err error) *TxManagerMock {
	if mmWithTx.mock.funcWithTx != nil {
		mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Set")
	}

	if mmWithTx.defaultExpectation == nil {
		mmWithTx.defaultExpectation = &TxManagerMockWithTxExpectation{mock: mmWithTx.mock}
	}
	mmWithTx.defaultExpectation.results = &TxManagerMockWithTxResults{err}
	mmWithTx.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWithTx.mock
}

// Set uses given function f to mock the TxManager.WithTx method
func (mmWithTx *mTxManagerMockWithTx) Set(f func(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error) (err error)) *TxManagerMock {
	if mmWithTx.defaultExpectation != nil {
		mmWithTx.mock.t.Fatalf("Default expectation is already set for the TxManager.WithTx method")
	}

	if len(mmWithTx.expectations) > 0 {
		mmWithTx.mock.t.Fatalf("Some expectations are already set for the TxManager.WithTx method")
	}

	mmWithTx.mock.funcWithTx = f
	mmWithTx.mock.funcWithTxOrigin = minimock.CallerInfo(1)
	return mmWithTx.mock
}

// When sets expectation for the TxManager.WithTx which will trigger the result defined by the following
// Then helper
func (mmWithTx *mTxManagerMockWithTx) When(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error) *TxManagerMockWithTxExpectation {
	if mmWithTx.mock.funcWithTx != nil {
		mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Set")
	}

	expectation := &TxManagerMockWithTxExpectation{
		mock:               mmWithTx.mock,
		params:             &TxManagerMockWithTxParams{ctx, isoLevel, accessMode, fn},
		expectationOrigins: TxManagerMockWithTxExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWithTx.expectations = append(mmWithTx.expectations, expectation)
	return expectation
}

// Then sets up TxManager.WithTx return parameters for the expectation previously defined by the When method
func (e *TxManagerMockWithTxExpectation) Then(err error) *TxManagerMock {
	e.results = &TxManagerMockWithTxResults{err}
	return e.mock
}

// Times sets number of times TxManager.WithTx should be invoked
func (mmWithTx *mTxManagerMockWithTx) Times(n uint64) *mTxManagerMockWithTx {
	if n == 0 {
		mmWithTx.mock.t.Fatalf("Times of TxManagerMock.WithTx mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWithTx.expectedInvocations, n)
	mmWithTx.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWithTx
}

func (mmWithTx *mTxManagerMockWithTx) invocationsDone() bool {
	if len(mmWithTx.expectations) == 0 && mmWithTx.defaultExpectation == nil && mmWithTx.mock.funcWithTx == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWithTx.mock.afterWithTxCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWithTx.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WithTx implements mm_txmanager.TxManager
func (mmWithTx *TxManagerMock) WithTx(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error) (err error) {
	mm_atomic.AddUint64(&mmWithTx.beforeWithTxCounter, 1)
	defer mm_atomic.AddUint64(&mmWithTx.afterWithTxCounter, 1)

	mmWithTx.t.Helper()

	if mmWithTx.inspectFuncWithTx != nil {
		mmWithTx.inspectFuncWithTx(ctx, isoLevel, accessMode, fn)
	}

	mm_params := TxManagerMockWithTxParams{ctx, isoLevel, accessMode, fn}

	// Record call args
	mmWithTx.WithTxMock.mutex.Lock()
	mmWithTx.WithTxMock.callArgs = append(mmWithTx.WithTxMock.callArgs, &mm_params)
	mmWithTx.WithTxMock.mutex.Unlock()

	for _, e := range mmWithTx.WithTxMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWithTx.WithTxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithTx.WithTxMock.defaultExpectation.Counter, 1)
		mm_want := mmWithTx.WithTxMock.defaultExpectation.params
		mm_want_ptrs := mmWithTx.WithTxMock.defaultExpectation.paramPtrs

		mm_got := TxManagerMockWithTxParams{ctx, isoLevel, accessMode, fn}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWithTx.t.Errorf("TxManagerMock.WithTx got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWithTx.WithTxMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.isoLevel != nil && !minimock.Equal(*mm_want_ptrs.isoLevel, mm_got.isoLevel) {
				mmWithTx.t.Errorf("TxManagerMock.WithTx got unexpected parameter isoLevel, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWithTx.WithTxMock.defaultExpectation.expectationOrigins.originIsoLevel, *mm_want_ptrs.isoLevel, mm_got.isoLevel, minimock.Diff(*mm_want_ptrs.isoLevel, mm_got.isoLevel))
			}

			if mm_want_ptrs.accessMode != nil && !minimock.Equal(*mm_want_ptrs.accessMode, mm_got.accessMode) {
				mmWithTx.t.Errorf("TxManagerMock.WithTx got unexpected parameter accessMode, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWithTx.WithTxMock.defaultExpectation.expectationOrigins.originAccessMode, *mm_want_ptrs.accessMode, mm_got.accessMode, minimock.Diff(*mm_want_ptrs.accessMode, mm_got.accessMode))
			}

			if mm_want_ptrs.fn != nil && !minimock.Equal(*mm_want_ptrs.fn, mm_got.fn) {
				mmWithTx.t.Errorf("TxManagerMock.WithTx got unexpected parameter fn, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWithTx.WithTxMock.defaultExpectation.expectationOrigins.originFn, *mm_want_ptrs.fn, mm_got.fn, minimock.Diff(*mm_want_ptrs.fn, mm_got.fn))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithTx.t.Errorf("TxManagerMock.WithTx got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWithTx.WithTxMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithTx.WithTxMock.defaultExpectation.results
		if mm_results == nil {
			mmWithTx.t.Fatal("No results are set for the TxManagerMock.WithTx")
		}
		return (*mm_results).err
	}
	if mmWithTx.funcWithTx != nil {
		return mmWithTx.funcWithTx(ctx, isoLevel, accessMode, fn)
	}
	mmWithTx.t.Fatalf("Unexpected call to TxManagerMock.WithTx. %v %v %v %v", ctx, isoLevel, accessMode, fn)
	return
}

// WithTxAfterCounter returns a count of finished TxManagerMock.WithTx invocations
func (mmWithTx *TxManagerMock) WithTxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithTx.afterWithTxCounter)
}

// WithTxBeforeCounter returns a count of TxManagerMock.WithTx invocations
func (mmWithTx *TxManagerMock) WithTxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithTx.beforeWithTxCounter)
}

// Calls returns a list of arguments used in each call to TxManagerMock.WithTx.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithTx *mTxManagerMockWithTx) Calls() []*TxManagerMockWithTxParams {
	mmWithTx.mutex.RLock()

	argCopy := make([]*TxManagerMockWithTxParams, len(mmWithTx.callArgs))
	copy(argCopy, mmWithTx.callArgs)

	mmWithTx.mutex.RUnlock()

	return argCopy
}

// MinimockWithTxDone returns true if the count of the WithTx invocations corresponds
// the number of defined expectations
func (m *TxManagerMock) MinimockWithTxDone() bool {
	if m.WithTxMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WithTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WithTxMock.invocationsDone()
}

// MinimockWithTxInspect logs each unmet expectation
func (m *TxManagerMock) MinimockWithTxInspect() {
	for _, e := range m.WithTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxManagerMock.WithTx at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWithTxCounter := mm_atomic.LoadUint64(&m.afterWithTxCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WithTxMock.defaultExpectation != nil && afterWithTxCounter < 1 {
		if m.WithTxMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TxManagerMock.WithTx at\n%s", m.WithTxMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TxManagerMock.WithTx at\n%s with params: %#v", m.WithTxMock.defaultExpectation.expectationOrigins.origin, *m.WithTxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithTx != nil && afterWithTxCounter < 1 {
		m.t.Errorf("Expected call to TxManagerMock.WithTx at\n%s", m.funcWithTxOrigin)
	}

	if !m.WithTxMock.invocationsDone() && afterWithTxCounter > 0 {
		m.t.Errorf("Expected %d calls to TxManagerMock.WithTx at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WithTxMock.expectedInvocations), m.WithTxMock.expectedInvocationsOrigin, afterWithTxCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TxManagerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetExecutorInspect()

			m.MinimockWithReadOnlyInspect()

			m.MinimockWithTxInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TxManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TxManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetExecutorDone() &&
		m.MinimockWithReadOnlyDone() &&
		m.MinimockWithTxDone()
}
