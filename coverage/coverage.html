
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>pvz: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">pvz-cli/cmd/pvz/main.go (0.0%)</option>
				
				<option value="file1">pvz-cli/internal/app/app.go (0.0%)</option>
				
				<option value="file2">pvz-cli/internal/app/setup_logger.go (0.0%)</option>
				
				<option value="file3">pvz-cli/internal/config/config.go (0.0%)</option>
				
				<option value="file4">pvz-cli/internal/config/storage/postgres_config.go (0.0%)</option>
				
				<option value="file5">pvz-cli/internal/config/storage/storage.go (0.0%)</option>
				
				<option value="file6">pvz-cli/internal/handler/accept_order.go (0.0%)</option>
				
				<option value="file7">pvz-cli/internal/handler/get_history.go (0.0%)</option>
				
				<option value="file8">pvz-cli/internal/handler/import_orders.go (0.0%)</option>
				
				<option value="file9">pvz-cli/internal/handler/list_orders.go (0.0%)</option>
				
				<option value="file10">pvz-cli/internal/handler/list_returns.go (0.0%)</option>
				
				<option value="file11">pvz-cli/internal/handler/mappers/order.go (0.0%)</option>
				
				<option value="file12">pvz-cli/internal/handler/mappers/order_history.go (0.0%)</option>
				
				<option value="file13">pvz-cli/internal/handler/mappers/order_import.go (0.0%)</option>
				
				<option value="file14">pvz-cli/internal/handler/mappers/order_response.go (0.0%)</option>
				
				<option value="file15">pvz-cli/internal/handler/mappers/pagination.go (0.0%)</option>
				
				<option value="file16">pvz-cli/internal/handler/mappers/process_result.go (0.0%)</option>
				
				<option value="file17">pvz-cli/internal/handler/mappers/return_record.go (0.0%)</option>
				
				<option value="file18">pvz-cli/internal/handler/mappers/types.go (0.0%)</option>
				
				<option value="file19">pvz-cli/internal/handler/middleware/cors.go (0.0%)</option>
				
				<option value="file20">pvz-cli/internal/handler/middleware/rate_limit.go (0.0%)</option>
				
				<option value="file21">pvz-cli/internal/handler/order_server.go (0.0%)</option>
				
				<option value="file22">pvz-cli/internal/handler/process_orders.go (0.0%)</option>
				
				<option value="file23">pvz-cli/internal/handler/report_handler.go (0.0%)</option>
				
				<option value="file24">pvz-cli/internal/handler/return_order.go (0.0%)</option>
				
				<option value="file25">pvz-cli/internal/repository/storage/postgres/helpers.go (0.0%)</option>
				
				<option value="file26">pvz-cli/internal/repository/storage/postgres/history_and_returns_repo.go (0.0%)</option>
				
				<option value="file27">pvz-cli/internal/repository/storage/postgres/orders_repo.go (0.0%)</option>
				
				<option value="file28">pvz-cli/internal/usecase/mock/history_and_returns_repo_mock.go (0.0%)</option>
				
				<option value="file29">pvz-cli/internal/usecase/mock/orders_repo_mock.go (0.0%)</option>
				
				<option value="file30">pvz-cli/internal/usecase/packaging/bag.go (100.0%)</option>
				
				<option value="file31">pvz-cli/internal/usecase/packaging/box.go (100.0%)</option>
				
				<option value="file32">pvz-cli/internal/usecase/packaging/composite.go (100.0%)</option>
				
				<option value="file33">pvz-cli/internal/usecase/packaging/film.go (100.0%)</option>
				
				<option value="file34">pvz-cli/internal/usecase/packaging/mock/packaging_strategy_mock.go (0.0%)</option>
				
				<option value="file35">pvz-cli/internal/usecase/packaging/mock/provider_mock.go (0.0%)</option>
				
				<option value="file36">pvz-cli/internal/usecase/packaging/registry.go (100.0%)</option>
				
				<option value="file37">pvz-cli/internal/usecase/service/accept_order.go (100.0%)</option>
				
				<option value="file38">pvz-cli/internal/usecase/service/generate_client_report.go (95.7%)</option>
				
				<option value="file39">pvz-cli/internal/usecase/service/helpers.go (100.0%)</option>
				
				<option value="file40">pvz-cli/internal/usecase/service/import_orders.go (100.0%)</option>
				
				<option value="file41">pvz-cli/internal/usecase/service/issue_orders.go (100.0%)</option>
				
				<option value="file42">pvz-cli/internal/usecase/service/list_orders.go (100.0%)</option>
				
				<option value="file43">pvz-cli/internal/usecase/service/list_returns.go (100.0%)</option>
				
				<option value="file44">pvz-cli/internal/usecase/service/order_history.go (100.0%)</option>
				
				<option value="file45">pvz-cli/internal/usecase/service/return_order.go (100.0%)</option>
				
				<option value="file46">pvz-cli/internal/usecase/service/return_orders_by_user.go (100.0%)</option>
				
				<option value="file47">pvz-cli/internal/usecase/service/service.go (100.0%)</option>
				
				<option value="file48">pvz-cli/pkg/closer/closer.go (0.0%)</option>
				
				<option value="file49">pvz-cli/pkg/errs/errors.go (0.0%)</option>
				
				<option value="file50">pvz-cli/pkg/errs/helpers.go (0.0%)</option>
				
				<option value="file51">pvz-cli/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file52">pvz-cli/pkg/pvz/order_service.pb.go (0.0%)</option>
				
				<option value="file53">pvz-cli/pkg/pvz/order_service.pb.gw.go (0.0%)</option>
				
				<option value="file54">pvz-cli/pkg/pvz/order_service.pb.validate.go (0.0%)</option>
				
				<option value="file55">pvz-cli/pkg/pvz/order_service_grpc.pb.go (0.0%)</option>
				
				<option value="file56">pvz-cli/pkg/pvz/order_types.pb.go (0.0%)</option>
				
				<option value="file57">pvz-cli/pkg/txmanager/access_mode.go (0.0%)</option>
				
				<option value="file58">pvz-cli/pkg/txmanager/mock/txmanager_mock.go (0.0%)</option>
				
				<option value="file59">pvz-cli/pkg/txmanager/tx.go (0.0%)</option>
				
				<option value="file60">pvz-cli/vendor-proto/protoc-gen-openapiv2/options/annotations.pb.go (0.0%)</option>
				
				<option value="file61">pvz-cli/vendor-proto/protoc-gen-openapiv2/options/openapiv2.pb.go (0.0%)</option>
				
				<option value="file62">pvz-cli/vendor-proto/validate/validate.pb.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "pvz-cli/internal/app"
        "pvz-cli/internal/config"
        "syscall"
        "time"

        "github.com/spf13/pflag"
)

func main() <span class="cov0" title="0">{
        ctx, stop := signal.NotifyContext(context.Background(),
                os.Interrupt, syscall.SIGTERM, syscall.SIGQUIT)
        defer stop()

        var (
                cfgPath string
                envPath string
        )
        pflag.StringVar(&amp;cfgPath, "config", "", "path to config.yaml (or set $PVZ_CONFIG)")
        pflag.StringVar(&amp;envPath, "env", "", "path to .env file (or set $PVZ_ENV)")
        pflag.Parse()

        // config path
        if cfgPath == "" </span><span class="cov0" title="0">{
                cfgPath = os.Getenv("PVZ_CONFIG")
        }</span>
        <span class="cov0" title="0">if cfgPath == "" </span><span class="cov0" title="0">{
                cfgPath = "configs/default_config.yaml"
                fmt.Fprintf(os.Stdout,
                        "No config specified; using default: %s\n"+
                                "Override with --config or $PVZ_CONFIG\n\n",
                        cfgPath,
                )
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprintf(os.Stdout, "Using config file: %s\n\n", cfgPath)
        }</span>

        // env path (optional)
        <span class="cov0" title="0">if envPath == "" </span><span class="cov0" title="0">{
                envPath = os.Getenv("PVZ_ENV")
        }</span>
        <span class="cov0" title="0">if envPath != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stdout, "Loading environment from: %s\n\n", envPath)
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprintf(os.Stdout, "No .env file specified; skipping env load\n")
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadConfig(cfgPath, envPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to load config: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">log, err := app.SetupLogger(cfg.Logging)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Logger init error: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer log.Sync()

        server := app.NewServer(cfg, log)

        if err := server.Run(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalw("Failed to start server", "error", err)
        }</span>

        <span class="cov0" title="0">&lt;-ctx.Done()

        shutdownCtx, cancel := context.WithTimeout(
                context.Background(),
                time.Duration(cfg.GRPCServer.ShutdownTimeout)*time.Second,
        )
        defer cancel()

        if err := server.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                log.Errorw("Shutdown failed", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">log.Info("Application stopped gracefully")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package app инициализирует и запускает основное приложение,
// включая конфигурацию, зависимости, маршруты и graceful shutdown.
//
// Этот пакет связывает все модули проекта и является точкой входа при запуске бинарника.
package app

import (
        "context"
        "errors"
        "fmt"
        "net"
        "net/http"
        "pvz-cli/internal/config"
        "pvz-cli/internal/handler"
        "pvz-cli/internal/handler/middleware"
        "pvz-cli/internal/repository/storage/postgres"
        "pvz-cli/internal/usecase/packaging"
        "pvz-cli/internal/usecase/service"
        "pvz-cli/pkg/closer"
        "pvz-cli/pkg/errs"
        "pvz-cli/pkg/logger"
        pvzpb "pvz-cli/pkg/pvz"
        "pvz-cli/pkg/txmanager"

        "github.com/gin-gonic/gin"
        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "github.com/jackc/pgx/v5/pgxpool"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
        "golang.org/x/time/rate"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/reflection"
        "google.golang.org/protobuf/encoding/protojson"
)

// Server позволяет удобно и аккуратно поднимать весь проект и его зависимости.
type Server struct {
        closer     *closer.Closer
        grpcServer *grpc.Server
        log        logger.Logger
        cfg        *config.Config
        hndl       handler.ReportsHandler
        txMgr      txmanager.TxManager
}

// NewServer создаёт новое приложение с инициализацией хранилища, бизнес-логики и REPL.
func NewServer(cfg *config.Config, log logger.Logger) *Server <span class="cov0" title="0">{
        c := closer.NewCloser()

        limiter := rate.NewLimiter(rate.Limit(5), 5)

        masterPool, err := cfg.Storage.ConnectMaster(log)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalw("connect to master postgres",
                        "error", err)
        }</span>
        <span class="cov0" title="0">c.Add(func(ctx context.Context) error </span><span class="cov0" title="0">{
                log.Infow("Closing Master PostgreSQL pool")
                masterPool.Close()
                return nil
        }</span>)

        <span class="cov0" title="0">replPool1, err := cfg.Storage.ConnectReplica(1, log)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalw("connect to replica1 postgres",
                        "error", err)
        }</span>
        <span class="cov0" title="0">c.Add(func(ctx context.Context) error </span><span class="cov0" title="0">{
                log.Infow("Closing Replica 1 PostgreSQL pool")
                replPool1.Close()
                return nil
        }</span>)

        <span class="cov0" title="0">replPool2, err := cfg.Storage.ConnectReplica(1, log)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalw("connect to replica2 postgres",
                        "error", err)
        }</span>
        <span class="cov0" title="0">c.Add(func(ctx context.Context) error </span><span class="cov0" title="0">{
                log.Infow("Closing Replica 2 PostgreSQL pool")
                replPool2.Close()
                return nil
        }</span>)

        <span class="cov0" title="0">tx := txmanager.NewTransactor(masterPool, []*pgxpool.Pool{replPool1, replPool2}, log)

        grpcSrv := grpc.NewServer(
                grpc.UnaryInterceptor(middleware.RateLimitInterceptor(limiter)),
        )
        reflection.Register(grpcSrv)

        s := &amp;Server{
                closer:     c,
                grpcServer: grpcSrv,
                log:        log,
                cfg:        cfg,
                txMgr:      tx,
        }

        s.setupGRPC()

        return s</span>
}

func (s *Server) setupGRPC() <span class="cov0" title="0">{
        orderRepo := postgres.NewOrdersPostgresRepo(s.txMgr)
        hrRepo := postgres.NewHistoryAndReturnsPostgresRepo(s.txMgr)

        strategyProvider := packaging.NewDefaultProvider()

        svc := service.NewService(s.txMgr, orderRepo, hrRepo, strategyProvider)

        hndl := handler.NewReportsHandler(svc)

        s.hndl = hndl

        handler.RegisterOrderService(s.grpcServer, svc, s.log)
}</span>

// Run запускает REPL-приложение, обрабатывающее пользовательские команды.
func (s *Server) Run(ctx context.Context) error <span class="cov0" title="0">{
        if err := s.runGRPC(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := s.runGateway(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Server) runGRPC(ctx context.Context) error <span class="cov0" title="0">{
        grpcPort := s.cfg.GRPCServer.Port
        lis, err := net.Listen("tcp", fmt.Sprintf(":%d", grpcPort))
        if err != nil </span><span class="cov0" title="0">{
                return errs.Wrap(err, errs.CodeInternalError, fmt.Sprintf("failed to listen on port %d", grpcPort))
        }</span>

        <span class="cov0" title="0">s.closer.Add(func(ctx context.Context) error </span><span class="cov0" title="0">{
                s.log.Infow("Shutting down gRPC server")
                s.grpcServer.GracefulStop()
                return nil
        }</span>)

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                s.log.Infow("Starting gRPC server",
                        "address", lis.Addr().String(),
                )
                if err := s.grpcServer.Serve(lis); err != nil &amp;&amp; !errors.Is(err, grpc.ErrServerStopped) </span><span class="cov0" title="0">{
                        s.log.Fatalw("gRPC server error",
                                "error", err,
                        )
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

func (s *Server) runGateway(ctx context.Context) error <span class="cov0" title="0">{
        mux := runtime.NewServeMux(
                runtime.WithMarshalerOption(runtime.MIMEWildcard, &amp;runtime.JSONPb{
                        MarshalOptions: protojson.MarshalOptions{
                                UseProtoNames: true,
                        },
                        UnmarshalOptions: protojson.UnmarshalOptions{
                                DiscardUnknown: true,
                        },
                }),
        )

        endpoint := fmt.Sprintf("%s:%d", s.cfg.GRPCServer.Endpoint, s.cfg.GRPCServer.Port)

        // вместо grpc.DialContext использую grpc.NewClient, так как просит линтер и рекомендуют разрабы)
        conn, err := grpc.NewClient(
                endpoint,
                grpc.WithTransportCredentials(insecure.NewCredentials()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return errs.Wrap(err, errs.CodeInternalError, "failed to create gRPC client")
        }</span>

        <span class="cov0" title="0">s.closer.Add(func(ctx context.Context) error </span><span class="cov0" title="0">{
                s.log.Infow("Closing gRPC connection")
                return conn.Close()
        }</span>)

        <span class="cov0" title="0">if err := pvzpb.RegisterOrdersServiceHandler(ctx, mux, conn); err != nil </span><span class="cov0" title="0">{
                return errs.Wrap(err, errs.CodeInternalError, "failed to register PVZ service handler")
        }</span>

        <span class="cov0" title="0">gatewayRouter := s.setupRoutes(mux)

        gwAddr := fmt.Sprintf(":%d", s.cfg.Gateway.Port)
        gwServer := &amp;http.Server{
                Addr:    gwAddr,
                Handler: gatewayRouter,
        }

        s.closer.Add(func(ctx context.Context) error </span><span class="cov0" title="0">{
                s.log.Infow("Shutting down gRPC gateway")
                return gwServer.Shutdown(ctx)
        }</span>)

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                s.log.Infow("Starting gRPC gateway",
                        "address", gwAddr,
                )
                if err := gwServer.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        s.log.Fatalw("gRPC gateway error",
                                "error", err,
                        )
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

func (s *Server) setupRoutes(gw http.Handler) *gin.Engine <span class="cov0" title="0">{
        r := gin.New()
        r.Use(gin.Logger(), gin.Recovery())

        r.StaticFile(
                "/swagger/spec/http/swagger.json",
                "./api/swagger/apidocs.swagger.json",
        )

        r.GET(
                "/swagger/http/*any",
                ginSwagger.WrapHandler(
                        swaggerFiles.Handler,
                        ginSwagger.URL("/swagger/spec/http/swagger.json"),
                ),
        )

        corsHandler := middleware.EnableCORS(gw)

        // Принять заказ от курьера
        r.POST("/v1/orders/accept", gin.WrapH(corsHandler))

        // Вернуть заказ курьеру (динамический order_id)
        r.POST("/v1/orders/:order_id/return", gin.WrapH(corsHandler))

        // Выдать заказы или принять возврат клиента
        r.POST("/v1/orders/process", gin.WrapH(corsHandler))

        // Получить список заказов клиента
        r.GET("/v1/orders", gin.WrapH(corsHandler))

        // Получить список возвратов клиентов
        r.GET("/v1/orders/returns", gin.WrapH(corsHandler))

        // Получить историю изменения заказов
        r.GET("/v1/orders/history", gin.WrapH(corsHandler))

        // Импортировать заказы из JSON-файла
        r.POST("/v1/orders/import", gin.WrapH(corsHandler))

        r.GET("/v1/reports/clients", s.hndl.DownloadClientReport)

        return r
}</span>

func (s *Server) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        return s.closer.Close(ctx)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"

        "pvz-cli/internal/config"
        "pvz-cli/pkg/logger"
)

// SetupLogger настраивает и возвращает экземпляр логгера на основе конфигурации.
func SetupLogger(cfg config.LoggingConfig) (logger.Logger, error) <span class="cov0" title="0">{
        lvl, err := zapcore.ParseLevel(cfg.Level)
        if err != nil </span><span class="cov0" title="0">{
                lvl = zapcore.InfoLevel
        }</span>

        <span class="cov0" title="0">var sampling *zap.SamplingConfig
        if cfg.Sampling != nil </span><span class="cov0" title="0">{
                sampling = &amp;zap.SamplingConfig{
                        Initial:    cfg.Sampling.Initial,
                        Thereafter: cfg.Sampling.Thereafter,
                }
        }</span>

        <span class="cov0" title="0">opts := []logger.Option{
                logger.WithMode(cfg.Mode),
                logger.WithLevel(lvl),
                logger.WithEncoding(cfg.Encoding),
                logger.WithDisableCaller(cfg.DisableCaller),
                logger.WithDisableStacktrace(cfg.DisableStacktrace),
                logger.WithOutputPaths(cfg.OutputPaths...),
                logger.WithErrorOutputPaths(cfg.ErrorOutputPaths...),
                logger.WithEncoderConfig(func(ec *zapcore.EncoderConfig) </span><span class="cov0" title="0">{
                        ec.TimeKey = cfg.TimestampKey
                        if cfg.CapitalizeLevel </span><span class="cov0" title="0">{
                                ec.EncodeLevel = zapcore.CapitalColorLevelEncoder
                        }</span>
                }),
        }

        <span class="cov0" title="0">if sampling != nil </span><span class="cov0" title="0">{
                opts = append(opts, logger.WithSampling(sampling))
        }</span>

        <span class="cov0" title="0">if len(cfg.InitialFields) &gt; 0 </span><span class="cov0" title="0">{
                opts = append(opts, logger.WithInitialFields(cfg.InitialFields))
        }</span>

        <span class="cov0" title="0">return logger.NewLogger(opts...)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package config предоставляет функциональность для чтения и хранения
// конфигурационных параметров приложения.
package config

import (
        "fmt"
        "os"
        "strings"

        "github.com/spf13/viper"

        "path/filepath"
        strgCfg "pvz-cli/internal/config/storage"
        "pvz-cli/pkg/errs"

        "github.com/joho/godotenv"
)

// Config объединяет все конфигурации в одну структуру.
type Config struct {
        Logging    LoggingConfig         `mapstructure:"logging"`
        GRPCServer GRPCServerConfig      `mapstructure:"grpc_server"`
        Gateway    GatewayConfig         `mapstructure:"gateway"`
        Storage    strgCfg.StorageConfig `mapstructure:"storage"`
}

// LoadConfig загружает и распаковывает конфигурацию по указанному пути.
//
// Если путь содержит расширение (.yaml/.yml), используется полный путь к файлу.
// Иначе ожидается config.{yaml,yml,json,...} внутри директории.
func LoadConfig(configPath, envPath string) (*Config, error) <span class="cov0" title="0">{
        if err := godotenv.Load(envPath); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("WARNING: error loading .env from %s: %v\n", envPath, err)
        }</span>

        <span class="cov0" title="0">v := viper.New()
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        v.AutomaticEnv()

        // Хелпер для биндинга
        bind := func(key, env string) </span><span class="cov0" title="0">{
                if err := v.BindEnv(key, env); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("WARNING: BindEnv %s -&gt; %s failed: %v\n", key, env, err)
                }</span>
        }

        <span class="cov0" title="0">bind("storage.postgres.master.host", "PG_HOST")
        bind("storage.postgres.master.port", "PG_MASTER_PORT")
        bind("storage.postgres.database", "PG_DATABASE")
        bind("storage.postgres.username", "PG_SUPER_USER")
        bind("storage.postgres.password", "PG_SUPER_PASSWORD")

        bind("storage.postgres.replicas[0].username", "PG_REPL_USER")
        bind("storage.postgres.replicas[0].password", "PG_REPL_PASSWORD")
        bind("storage.postgres.replicas[1].username", "PG_REPL_USER")
        bind("storage.postgres.replicas[1].password", "PG_REPL_PASSWORD")

        if ext := filepath.Ext(configPath); ext == ".yaml" || ext == ".yml" </span><span class="cov0" title="0">{
                v.SetConfigFile(configPath)
        }</span> else<span class="cov0" title="0"> {
                v.AddConfigPath(configPath)
                v.SetConfigName("config")
                v.SetConfigType("yaml")
        }</span>
        <span class="cov0" title="0">if err := v.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return nil, errs.Wrap(
                        err,
                        errs.CodeConfigError,
                        "cannot read config file",
                        "path", configPath,
                )
        }</span>

        <span class="cov0" title="0">var cfg Config
        if err := v.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, errs.Wrap(
                        err,
                        errs.CodeInvalidConfiguration,
                        "cannot unmarshal config into struct",
                )
        }</span>

        <span class="cov0" title="0">if h := os.Getenv("PG_HOST"); h != "" </span><span class="cov0" title="0">{
                for i := range cfg.Storage.Postgres.Replicas </span><span class="cov0" title="0">{
                        cfg.Storage.Postgres.Replicas[i].Host = h
                }</span>
        }

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package storage

import (
        "context"
        "fmt"
        "pvz-cli/pkg/logger"
        "time"

        "github.com/jackc/pgx/v5/pgxpool"
)

type PostgresConfig struct {
        Master             PostgresEndpoint   `mapstructure:"master"`
        Replicas           []PostgresEndpoint `mapstructure:"replicas"`
        Database           string             `mapstructure:"database"`
        Username           string             `mapstructure:"username"`
        Password           string             `mapstructure:"password"`
        SSLMode            string             `mapstructure:"ssl_mode"`
        ConnectionAttempts int                `mapstructure:"connection_attempts"`
        Pool               PoolConfig         `mapstructure:"pool"`
}

func (pc *PostgresConfig) connect(ep PostgresEndpoint, log logger.Logger) (*pgxpool.Pool, error) <span class="cov0" title="0">{

        dsn := pc.buildDSN(ep)

        poolCfg, err := pgxpool.ParseConfig(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse DSN: %w", err)
        }</span>

        <span class="cov0" title="0">poolCfg.MaxConns = int32(pc.Pool.MaxConnections)
        poolCfg.MinConns = int32(pc.Pool.MinConnections)
        poolCfg.MaxConnLifetime = time.Duration(pc.Pool.MaxLifeTime) * time.Second
        poolCfg.MaxConnIdleTime = time.Duration(pc.Pool.MaxIdleTime) * time.Second
        poolCfg.HealthCheckPeriod = time.Duration(pc.Pool.HealthCheckPeriod) * time.Second

        pool, err := pgxpool.NewWithConfig(context.Background(), poolCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create pool: %w", err)
        }</span>

        // попытки подключиться
        <span class="cov0" title="0">for i := 0; i &lt; pc.ConnectionAttempts; i++ </span><span class="cov0" title="0">{
                if err := pool.Ping(context.Background()); err == nil </span><span class="cov0" title="0">{
                        log.Infow("Successfully connected to PostgreSQL",
                                "host", ep.Host,
                                "port", ep.Port,
                        )
                        return pool, nil // успех
                }</span>
                <span class="cov0" title="0">log.Warnw("PostgreSQL ping failed",
                        "host", ep.Host,
                        "port", ep.Port,
                        "attempt", i+1,
                        "error", err,
                )
                time.Sleep(2 * time.Second)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("could not connect after %d attempts", pc.ConnectionAttempts)</span>
}

func (pc *PostgresConfig) buildDSN(ep PostgresEndpoint) string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                ep.Host, ep.Port, pc.Username, pc.Password, pc.Database, pc.SSLMode,
        )
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package storage

import (
        "fmt"
        "pvz-cli/pkg/logger"

        "github.com/jackc/pgx/v5/pgxpool"
)

type StorageConfig struct {
        Postgres PostgresConfig `mapstructure:"postgres"`
}

// ConnectMaster возвращает пул к мастеру
func (s *StorageConfig) ConnectMaster(log logger.Logger) (*pgxpool.Pool, error) <span class="cov0" title="0">{
        return s.Postgres.connect(s.Postgres.Master, log)
}</span>

// ConnectReplica(idx) – пул к replica[idx] (0-based)
func (s *StorageConfig) ConnectReplica(idx int, log logger.Logger) (*pgxpool.Pool, error) <span class="cov0" title="0">{
        if idx &lt; 0 || idx &gt;= len(s.Postgres.Replicas) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("replica index %d out of range", idx)
        }</span>
        <span class="cov0" title="0">return s.Postgres.connect(s.Postgres.Replicas[idx], log)</span>
}

// GetDSN(0) → master; GetDSN(1) → первая реплика; 2 → вторая, и т.д.
func (s *StorageConfig) GetDSN(id int) (string, error) <span class="cov0" title="0">{
        switch id </span>{
        case 0:<span class="cov0" title="0">
                return s.Postgres.buildDSN(s.Postgres.Master), nil</span>
        default:<span class="cov0" title="0">
                idx := id - 1
                if idx &lt; 0 || idx &gt;= len(s.Postgres.Replicas) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("replica id %d not found", id)
                }</span>
                <span class="cov0" title="0">return s.Postgres.buildDSN(s.Postgres.Replicas[idx]), nil</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "context"
        "pvz-cli/internal/handler/mappers"
        "pvz-cli/pkg/errs"
        pvzpb "pvz-cli/pkg/pvz"

        "google.golang.org/grpc/codes"
        grpcstatus "google.golang.org/grpc/status"
)

func (s *OrderServiceServer) AcceptOrder(
        ctx context.Context,
        req *pvzpb.AcceptOrderRequest,
) (*pvzpb.OrderResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, grpcstatus.Error(codes.InvalidArgument, "AcceptOrderRequest is nil")
        }</span>
        <span class="cov0" title="0">if err := req.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, grpcstatus.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov0" title="0">domainOrder, err := mappers.ProtoToDomainOrderForImport(req)
        if err != nil </span><span class="cov0" title="0">{
                if grpcErr := errs.GrpcError(err); grpcErr != nil </span><span class="cov0" title="0">{
                        return nil, grpcErr
                }</span>
                <span class="cov0" title="0">return nil, grpcstatus.Error(codes.Internal, err.Error())</span>
        }

        <span class="cov0" title="0">_, err = s.svc.AcceptOrder(
                ctx,
                domainOrder.ID,
                domainOrder.UserID,
                domainOrder.ExpiresAt,
                domainOrder.Weight,
                domainOrder.Price,
                domainOrder.Package,
        )
        if err != nil </span><span class="cov0" title="0">{
                // логируем только ошибку svc
                s.log.Errorw("AcceptOrder service error",
                        "order_id", domainOrder.ID,
                        "error", err,
                )
                if grpcErr := errs.GrpcError(err); grpcErr != nil </span><span class="cov0" title="0">{
                        return nil, grpcErr
                }</span>
                <span class="cov0" title="0">cause := errs.ErrorCause(err)
                return nil, grpcstatus.Error(codes.Internal, cause)</span>
        }

        <span class="cov0" title="0">return &amp;pvzpb.OrderResponse{
                Status:  pvzpb.OrderStatus_ORDER_STATUS_EXPECTS,
                OrderId: req.OrderId,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

import (
        "context"
        "pvz-cli/internal/handler/mappers"
        "pvz-cli/pkg/errs"
        pvzpb "pvz-cli/pkg/pvz"

        "google.golang.org/grpc/codes"
        grpcstatus "google.golang.org/grpc/status"
)

func (s *OrderServiceServer) GetHistory(
        ctx context.Context,
        req *pvzpb.GetHistoryRequest,
) (*pvzpb.OrderHistoryList, error) <span class="cov0" title="0">{
        if req != nil </span><span class="cov0" title="0">{
                if err := req.Validate(); err != nil </span><span class="cov0" title="0">{
                        return nil, grpcstatus.Error(codes.InvalidArgument, err.Error())
                }</span>
        }

        <span class="cov0" title="0">pagination := mappers.ProtoToDomainPagination(req.Pagination)

        historyEvents, _, err := s.svc.OrderHistory(ctx, pagination)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorw("GetHistory service error",
                        "pagination", req.GetPagination(),
                        "error", err,
                )
                if grpcErr := errs.GrpcError(err); grpcErr != nil </span><span class="cov0" title="0">{
                        return nil, grpcErr
                }</span>
                <span class="cov0" title="0">cause := errs.ErrorCause(err)
                return nil, grpcstatus.Error(codes.Internal, cause)</span>
        }

        <span class="cov0" title="0">pbHistory := make([]*pvzpb.OrderHistory, 0, len(historyEvents))
        for _, h := range historyEvents </span><span class="cov0" title="0">{
                pbH, mapErr := mappers.DomainOrderHistoryToProtoOrderHistory(h)
                if mapErr != nil </span><span class="cov0" title="0">{
                        return nil, grpcstatus.Error(codes.Internal, mapErr.Error())
                }</span>
                <span class="cov0" title="0">pbHistory = append(pbHistory, pbH)</span>
        }

        <span class="cov0" title="0">return &amp;pvzpb.OrderHistoryList{
                History: pbHistory,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handler

import (
        "context"
        "pvz-cli/internal/domain/models"
        "pvz-cli/internal/handler/mappers"
        "pvz-cli/pkg/errs"
        pvzpb "pvz-cli/pkg/pvz"

        "google.golang.org/grpc/codes"
        grpcstatus "google.golang.org/grpc/status"
)

func (s *OrderServiceServer) ImportOrders(
        ctx context.Context,
        req *pvzpb.ImportOrdersRequest,
) (*pvzpb.ImportResult, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, grpcstatus.Error(codes.InvalidArgument, "ImportOrdersRequest is nil")
        }</span>
        <span class="cov0" title="0">if err := req.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, grpcstatus.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov0" title="0">importList := make([]*models.Order, 0, len(req.Orders))
        for _, o := range req.Orders </span><span class="cov0" title="0">{
                domainOrder, mapErr := mappers.ProtoToDomainOrderForImport(o)
                if mapErr != nil </span><span class="cov0" title="0">{
                        if grpcErr := errs.GrpcError(mapErr); grpcErr != nil </span><span class="cov0" title="0">{
                                return nil, grpcErr
                        }</span>
                        <span class="cov0" title="0">return nil, grpcstatus.Error(codes.Internal, mapErr.Error())</span>
                }
                <span class="cov0" title="0">importList = append(importList, domainOrder)</span>
        }

        <span class="cov0" title="0">count, err := s.svc.ImportOrders(ctx, importList)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorw("ImportOrders service error",
                        "num_requests", len(importList),
                        "error", err,
                )
                if grpcErr := errs.GrpcError(err); grpcErr != nil </span><span class="cov0" title="0">{
                        return nil, grpcErr
                }</span>
                <span class="cov0" title="0">cause := errs.ErrorCause(err)
                return nil, grpcstatus.Error(codes.Internal, cause)</span>
        }

        <span class="cov0" title="0">return &amp;pvzpb.ImportResult{
                Imported: int32(count),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handler

import (
        "context"
        "pvz-cli/internal/handler/mappers"
        "pvz-cli/pkg/errs"
        pvzpb "pvz-cli/pkg/pvz"
        "strconv"

        "google.golang.org/grpc/codes"
        grpcstatus "google.golang.org/grpc/status"
)

func (s *OrderServiceServer) ListOrders(
        ctx context.Context,
        req *pvzpb.ListOrdersRequest,
) (*pvzpb.OrdersList, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, grpcstatus.Error(codes.InvalidArgument, "ListOrdersRequest is nil")
        }</span>
        <span class="cov0" title="0">if err := req.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, grpcstatus.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov0" title="0">lastN := 0
        if req.LastN != nil </span><span class="cov0" title="0">{
                lastN = int(*req.LastN)
        }</span>
        <span class="cov0" title="0">pagination := mappers.ProtoToDomainPagination(req.Pagination)
        inPVZ := req.InPvz

        domainOrders, total, err := s.svc.ListOrders(
                ctx,
                strconv.FormatUint(req.UserId, 10),
                inPVZ,
                lastN,
                pagination,
        )
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorw("ListOrders service error",
                        "user_id", req.UserId,
                        "in_pvz", inPVZ,
                        "lastN", lastN,
                        "error", err,
                )
                cause := errs.ErrorCause(err)
                return nil, grpcstatus.Error(codes.Internal, cause)
        }</span>

        <span class="cov0" title="0">pbOrders := make([]*pvzpb.Order, 0, len(domainOrders))
        for _, o := range domainOrders </span><span class="cov0" title="0">{
                pbOrder, mapErr := mappers.DomainOrderToProtoOrder(o)
                if mapErr != nil </span><span class="cov0" title="0">{
                        return nil, grpcstatus.Error(codes.Internal, mapErr.Error())
                }</span>
                <span class="cov0" title="0">pbOrders = append(pbOrders, pbOrder)</span>
        }

        <span class="cov0" title="0">return &amp;pvzpb.OrdersList{
                Orders: pbOrders,
                Total:  int32(total),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handler

import (
        "context"
        "pvz-cli/internal/handler/mappers"
        "pvz-cli/pkg/errs"
        pvzpb "pvz-cli/pkg/pvz"

        "google.golang.org/grpc/codes"
        grpcstatus "google.golang.org/grpc/status"
)

func (s *OrderServiceServer) ListReturns(
        ctx context.Context,
        req *pvzpb.ListReturnsRequest,
) (*pvzpb.ReturnsList, error) <span class="cov0" title="0">{
        if req != nil </span><span class="cov0" title="0">{
                if err := req.Validate(); err != nil </span><span class="cov0" title="0">{
                        return nil, grpcstatus.Error(codes.InvalidArgument, err.Error())
                }</span>
        }

        <span class="cov0" title="0">pagination := mappers.ProtoToDomainPagination(req.Pagination)

        returnRecords, err := s.svc.ListReturns(ctx, pagination)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorw("ListReturns service error",
                        "pagination", req.GetPagination(),
                        "error", err,
                )
                if grpcErr := errs.GrpcError(err); grpcErr != nil </span><span class="cov0" title="0">{
                        return nil, grpcErr
                }</span>
                <span class="cov0" title="0">cause := errs.ErrorCause(err)
                return nil, grpcstatus.Error(codes.Internal, cause)</span>
        }

        <span class="cov0" title="0">pbReturns := make([]*pvzpb.ReturnRecord, 0, len(returnRecords))
        for _, r := range returnRecords </span><span class="cov0" title="0">{
                pbR, mapErr := mappers.DomainReturnRecordToProtoReturnRecord(r)
                if mapErr != nil </span><span class="cov0" title="0">{
                        return nil, grpcstatus.Error(codes.Internal, mapErr.Error())
                }</span>
                <span class="cov0" title="0">pbReturns = append(pbReturns, pbR)</span>
        }

        <span class="cov0" title="0">return &amp;pvzpb.ReturnsList{
                Returns: pbReturns,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package mappers

import (
        "pvz-cli/internal/domain/models"
        "pvz-cli/pkg/errs"
        pvzpb "pvz-cli/pkg/pvz"
        "strconv"

        "google.golang.org/protobuf/types/known/timestamppb"
)

func DomainOrderToProtoOrder(o *models.Order) (*pvzpb.Order, error) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, errs.New(errs.CodeMissingParameter, "models.Order is nil")
        }</span>

        <span class="cov0" title="0">orderID, err := strconv.ParseUint(o.ID, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Wrap(err, errs.CodeParsingError, "invalid Order.ID", "order_id", o.ID)
        }</span>
        <span class="cov0" title="0">userID, err := strconv.ParseUint(o.UserID, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Wrap(err, errs.CodeParsingError, "invalid Order.UserID", "user_id", o.UserID)
        }</span>

        <span class="cov0" title="0">pbStatus := DomainToProtoOrderStatus(o.Status)

        pbPkg := DomainToProtoPackage(o.Package)

        totalRubles := float32(o.Price) / 100.0

        return &amp;pvzpb.Order{
                OrderId:    orderID,
                UserId:     userID,
                Status:     pbStatus,
                ExpiresAt:  timestamppb.New(o.ExpiresAt),
                Weight:     float32(o.Weight),
                TotalPrice: totalRubles,
                Package:    &amp;pbPkg,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package mappers

import (
        "pvz-cli/internal/domain/models"
        "pvz-cli/pkg/errs"
        pvzpb "pvz-cli/pkg/pvz"
        "strconv"

        "google.golang.org/protobuf/types/known/timestamppb"
)

func DomainOrderHistoryToProtoOrderHistory(h *models.HistoryEvent) (*pvzpb.OrderHistory, error) <span class="cov0" title="0">{
        if h == nil </span><span class="cov0" title="0">{
                return nil, errs.New(errs.CodeMissingParameter, "models.OrderHistory is nil")
        }</span>

        <span class="cov0" title="0">orderID, err := strconv.ParseUint(h.OrderID, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Wrap(err, errs.CodeParsingError, "invalid OrderHistory.OrderID", "order_id", h.OrderID)
        }</span>

        <span class="cov0" title="0">pbStatus := DomainToProtoOrderStatus(h.Status)

        return &amp;pvzpb.OrderHistory{
                OrderId:   orderID,
                Status:    pbStatus,
                CreatedAt: timestamppb.New(h.Time),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package mappers

import (
        "pvz-cli/internal/domain/models"
        "pvz-cli/pkg/errs"
        pvzpb "pvz-cli/pkg/pvz"
        "strconv"
        "time"
)

func ProtoToDomainOrderForImport(req *pvzpb.AcceptOrderRequest) (*models.Order, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, errs.New(errs.CodeMissingParameter, "AcceptOrderRequest is nil")
        }</span>

        <span class="cov0" title="0">if req.OrderId == 0 </span><span class="cov0" title="0">{
                return nil, errs.New(errs.CodeMissingParameter, "order_id обязательный параметр")
        }</span>
        <span class="cov0" title="0">if req.UserId == 0 </span><span class="cov0" title="0">{
                return nil, errs.New(errs.CodeMissingParameter, "user_id обязательный параметр")
        }</span>
        <span class="cov0" title="0">if req.ExpiresAt == nil </span><span class="cov0" title="0">{
                return nil, errs.New(errs.CodeMissingParameter, "expires_at обязательный параметр")
        }</span>
        <span class="cov0" title="0">if req.Weight &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errs.New(errs.CodeInvalidParameter, "weight должно быть больше 0")
        }</span>
        <span class="cov0" title="0">if req.Price &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errs.New(errs.CodeInvalidParameter, "price должно быть больше 0")
        }</span>

        <span class="cov0" title="0">idStr := strconv.FormatUint(req.GetOrderId(), 10)
        userStr := strconv.FormatUint(req.GetUserId(), 10)

        status := models.StatusAccepted

        createdAt := time.Now()

        weight := float64(req.GetWeight())
        priceKopecks := models.PriceKopecks(int64(req.GetPrice() * 100))

        var pkg models.PackageType
        if req.Package != nil </span><span class="cov0" title="0">{
                pkg = ProtoToDomainPackage(*req.Package)
        }</span>

        <span class="cov0" title="0">expiresAt := req.ExpiresAt.AsTime()

        return &amp;models.Order{
                ID:        idStr,
                UserID:    userStr,
                Status:    status,
                ExpiresAt: expiresAt,
                CreatedAt: createdAt,
                Weight:    weight,
                Price:     priceKopecks,
                Package:   pkg,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package mappers

import (
        "pvz-cli/pkg/errs"
        pvzpb "pvz-cli/pkg/pvz"
        "strconv"
)

func DomainToProtoOrderResponse(status, orderID string) (*pvzpb.OrderResponse, error) <span class="cov0" title="0">{
        if orderID == "" </span><span class="cov0" title="0">{
                return nil, errs.New(errs.CodeMissingParameter, "orderID пустой")
        }</span>
        <span class="cov0" title="0">idUint, err := strconv.ParseUint(orderID, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Wrap(err, errs.CodeParsingError, "invalid orderID", "order_id", orderID)
        }</span>

        <span class="cov0" title="0">var pbStatus pvzpb.OrderStatus = pvzpb.OrderStatus_ORDER_STATUS_UNSPECIFIED
        if status != "" </span><span class="cov0" title="0">{
                if sVal, ok := pvzpb.OrderStatus_value[status]; ok </span><span class="cov0" title="0">{
                        pbStatus = pvzpb.OrderStatus(sVal)
                }</span> else<span class="cov0" title="0"> {
                        return nil, errs.New(errs.CodeInvalidParameter, "unknown order status", "status", status)
                }</span>
        }

        <span class="cov0" title="0">return &amp;pvzpb.OrderResponse{
                Status:  pbStatus,
                OrderId: idUint,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package mappers

import (
        "pvz-cli/internal/domain/vo"
        pvzpb "pvz-cli/pkg/pvz"
)

func ProtoToDomainPagination(p *pvzpb.Pagination) vo.Pagination <span class="cov0" title="0">{
        if p == nil </span><span class="cov0" title="0">{
                return vo.Pagination{}
        }</span>
        <span class="cov0" title="0">return vo.Pagination{
                Page:  int(p.Page),
                Limit: int(p.CountOnPage),
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package mappers

import (
        "pvz-cli/pkg/errs"
        pvzpb "pvz-cli/pkg/pvz"
        "strconv"
)

func DomainProcessResultToProtoProcessResult(result map[string]error) (*pvzpb.ProcessResult, error) <span class="cov0" title="0">{
        if result == nil </span><span class="cov0" title="0">{
                return &amp;pvzpb.ProcessResult{}, nil
        }</span>

        <span class="cov0" title="0">processed := make([]uint64, 0, len(result))
        errorsList := make([]uint64, 0, len(result))

        for idStr, entryErr := range result </span><span class="cov0" title="0">{
                idUint, err := strconv.ParseUint(idStr, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs.Wrap(err, errs.CodeParsingError, "invalid key in ProcessResult", "order_id", idStr)
                }</span>
                <span class="cov0" title="0">if entryErr != nil </span><span class="cov0" title="0">{
                        errorsList = append(errorsList, idUint)
                }</span> else<span class="cov0" title="0"> {
                        processed = append(processed, idUint)
                }</span>
        }

        <span class="cov0" title="0">return &amp;pvzpb.ProcessResult{
                Processed: processed,
                Errors:    errorsList,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package mappers

import (
        "pvz-cli/internal/domain/models"
        "pvz-cli/pkg/errs"
        pvzpb "pvz-cli/pkg/pvz"
        "strconv"

        "google.golang.org/protobuf/types/known/timestamppb"
)

func DomainReturnRecordToProtoReturnRecord(r *models.ReturnRecord) (*pvzpb.ReturnRecord, error) <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return nil, errs.New(errs.CodeMissingParameter, "models.ReturnRecord is nil")
        }</span>

        <span class="cov0" title="0">orderID, err := strconv.ParseUint(r.OrderID, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Wrap(err, errs.CodeParsingError, "invalid ReturnRecord.OrderID", "order_id", r.OrderID)
        }</span>
        <span class="cov0" title="0">userID, err := strconv.ParseUint(r.UserID, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Wrap(err, errs.CodeParsingError, "invalid ReturnRecord.UserID", "user_id", r.UserID)
        }</span>

        <span class="cov0" title="0">return &amp;pvzpb.ReturnRecord{
                OrderId:    orderID,
                UserId:     userID,
                ReturnedAt: timestamppb.New(r.ReturnedAt),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package mappers

import (
        "pvz-cli/internal/domain/models"
        pvzpb "pvz-cli/pkg/pvz"
)

func ProtoToDomainPackage(p pvzpb.PackageType) models.PackageType <span class="cov0" title="0">{
        switch p </span>{
        case pvzpb.PackageType_PACKAGE_TYPE_BAG:<span class="cov0" title="0">
                return models.PackageBag</span>
        case pvzpb.PackageType_PACKAGE_TYPE_BOX:<span class="cov0" title="0">
                return models.PackageBox</span>
        case pvzpb.PackageType_PACKAGE_TYPE_TAPE:<span class="cov0" title="0">
                return models.PackageFilm</span>
        case pvzpb.PackageType_PACKAGE_TYPE_BAG_TAPE:<span class="cov0" title="0">
                return models.PackageBagFilm</span>
        case pvzpb.PackageType_PACKAGE_TYPE_BOX_TAPE:<span class="cov0" title="0">
                return models.PackageBoxFilm</span>
        default:<span class="cov0" title="0">
                return models.PackageNone</span>
        }
}

func DomainToProtoPackage(p models.PackageType) pvzpb.PackageType <span class="cov0" title="0">{
        switch p </span>{
        case models.PackageBag:<span class="cov0" title="0">
                return pvzpb.PackageType_PACKAGE_TYPE_BAG</span>
        case models.PackageBox:<span class="cov0" title="0">
                return pvzpb.PackageType_PACKAGE_TYPE_BOX</span>
        case models.PackageFilm:<span class="cov0" title="0">
                return pvzpb.PackageType_PACKAGE_TYPE_TAPE</span>
        case models.PackageBagFilm:<span class="cov0" title="0">
                return pvzpb.PackageType_PACKAGE_TYPE_BAG_TAPE</span>
        case models.PackageBoxFilm:<span class="cov0" title="0">
                return pvzpb.PackageType_PACKAGE_TYPE_BOX_TAPE</span>
        default:<span class="cov0" title="0">
                return pvzpb.PackageType_PACKAGE_TYPE_UNSPECIFIED</span>
        }
}

func ProtoToDomainOrderStatus(s pvzpb.OrderStatus) models.OrderStatus <span class="cov0" title="0">{
        switch s </span>{
        case pvzpb.OrderStatus_ORDER_STATUS_EXPECTS:<span class="cov0" title="0">
                return models.StatusAccepted</span>
        case pvzpb.OrderStatus_ORDER_STATUS_ACCEPTED:<span class="cov0" title="0">
                return models.StatusIssued</span>
        case pvzpb.OrderStatus_ORDER_STATUS_RETURNED:<span class="cov0" title="0">
                return models.StatusReturned</span>
        case pvzpb.OrderStatus_ORDER_STATUS_DELETED:<span class="cov0" title="0">
                return models.StatusExpired</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func DomainToProtoOrderStatus(s models.OrderStatus) pvzpb.OrderStatus <span class="cov0" title="0">{
        switch s </span>{
        case models.StatusAccepted:<span class="cov0" title="0">
                return pvzpb.OrderStatus_ORDER_STATUS_EXPECTS</span>
        case models.StatusIssued:<span class="cov0" title="0">
                return pvzpb.OrderStatus_ORDER_STATUS_ACCEPTED</span>
        case models.StatusReturned:<span class="cov0" title="0">
                return pvzpb.OrderStatus_ORDER_STATUS_RETURNED</span>
        case models.StatusExpired:<span class="cov0" title="0">
                return pvzpb.OrderStatus_ORDER_STATUS_DELETED</span>
        default:<span class="cov0" title="0">
                return pvzpb.OrderStatus_ORDER_STATUS_UNSPECIFIED</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package middleware

import "net/http"

func EnableCORS(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
                if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package middleware

import (
        "context"

        "golang.org/x/time/rate"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func RateLimitInterceptor(limiter *rate.Limiter) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                req interface{},
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (interface{}, error) </span><span class="cov0" title="0">{
                if !limiter.Allow() </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.ResourceExhausted, "rate limited: %s", info.FullMethod)
                }</span>

                <span class="cov0" title="0">return handler(ctx, req)</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package handler

import (
        "pvz-cli/internal/usecase/service"
        "pvz-cli/pkg/logger"
        pvzpb "pvz-cli/pkg/pvz"

        "google.golang.org/grpc"
)

type OrderServiceServer struct {
        pvzpb.UnimplementedOrdersServiceServer
        svc service.Service
        log logger.Logger
}

func NewOrderServiceServer(svc service.Service, log logger.Logger) *OrderServiceServer <span class="cov0" title="0">{
        return &amp;OrderServiceServer{
                svc: svc,
                log: log,
        }
}</span>

func RegisterOrderService(grpcServer *grpc.Server, svc service.Service, log logger.Logger) <span class="cov0" title="0">{
        pvzpb.RegisterOrdersServiceServer(grpcServer, NewOrderServiceServer(svc, log))
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package handler

import (
        "context"
        "pvz-cli/internal/handler/mappers"
        "pvz-cli/pkg/errs"
        pvzpb "pvz-cli/pkg/pvz"
        "strconv"

        "google.golang.org/grpc/codes"
        grpcstatus "google.golang.org/grpc/status"
)

func (s *OrderServiceServer) ProcessOrders(
        ctx context.Context,
        req *pvzpb.ProcessOrdersRequest,
) (*pvzpb.ProcessResult, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, grpcstatus.Error(codes.InvalidArgument, "ProcessOrdersRequest is nil")
        }</span>
        <span class="cov0" title="0">if err := req.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, grpcstatus.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov0" title="0">userIDStr := strconv.FormatUint(req.UserId, 10)
        ids := make([]string, 0, len(req.OrderIds))
        for _, id := range req.OrderIds </span><span class="cov0" title="0">{
                ids = append(ids, strconv.FormatUint(id, 10))
        }</span>

        <span class="cov0" title="0">var (
                result map[string]error
                err    error
        )

        switch req.Action </span>{
        case pvzpb.ActionType_ACTION_TYPE_ISSUE:<span class="cov0" title="0">
                result, err = s.svc.IssueOrders(ctx, userIDStr, ids)</span>
        case pvzpb.ActionType_ACTION_TYPE_RETURN:<span class="cov0" title="0">
                result, err = s.svc.ReturnOrdersByClient(ctx, userIDStr, ids)</span>
        default:<span class="cov0" title="0">
                return nil, grpcstatus.Error(codes.InvalidArgument, "unknown action")</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.log.Errorw("ProcessOrders service error",
                        "action", req.Action,
                        "user_id", userIDStr,
                        "error", err,
                )
                cause := errs.ErrorCause(err)
                return nil, grpcstatus.Error(codes.Internal, cause)
        }</span>

        <span class="cov0" title="0">protoResult, mapErr := mappers.DomainProcessResultToProtoProcessResult(result)
        if mapErr != nil </span><span class="cov0" title="0">{
                return nil, grpcstatus.Error(codes.Internal, mapErr.Error())
        }</span>
        <span class="cov0" title="0">return protoResult, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package handler

import (
        "fmt"
        "net/http"
        "pvz-cli/internal/usecase/service"
        "pvz-cli/pkg/errs"

        "github.com/gin-gonic/gin"
)

type ReportsHandler interface {
        DownloadClientReport(c *gin.Context)
}

type reportsHandlerImp struct {
        svc service.Service
}

func NewReportsHandler(svc service.Service) *reportsHandlerImp <span class="cov0" title="0">{
        return &amp;reportsHandlerImp{svc: svc}
}</span>

func (h *reportsHandlerImp) DownloadClientReport(c *gin.Context) <span class="cov0" title="0">{
        sortBy := c.Query("sortBy")
        dataBytes, err := h.svc.GenerateClientReportByte(c, sortBy)
        if err != nil </span><span class="cov0" title="0">{
                msg := errs.ErrorCause(err)
                c.String(
                        http.StatusInternalServerError,
                        "failed to generate report: %s",
                        msg,
                )
                return
        }</span>

        <span class="cov0" title="0">c.Header("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
        c.Header("Content-Disposition", "attachment; filename=clients_report.xlsx")
        c.Header("Content-Length", fmt.Sprintf("%d", len(dataBytes)))

        c.Writer.Write(dataBytes)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package handler

import (
        "context"
        errCodes "pvz-cli/internal/domain/codes"
        "pvz-cli/internal/handler/mappers"
        "pvz-cli/pkg/errs"
        pvzpb "pvz-cli/pkg/pvz"
        "strconv"

        "google.golang.org/grpc/codes"
        grpcstatus "google.golang.org/grpc/status"
)

func (s *OrderServiceServer) ReturnOrder(
        ctx context.Context,
        req *pvzpb.OrderIdRequest,
) (*pvzpb.OrderResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, grpcstatus.Error(codes.InvalidArgument, "OrderIdRequest is nil")
        }</span>
        <span class="cov0" title="0">if err := req.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, grpcstatus.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov0" title="0">orderIDStr := strconv.FormatUint(req.OrderId, 10)
        if err := s.svc.ReturnOrder(ctx, orderIDStr); err != nil </span><span class="cov0" title="0">{
                s.log.Errorw("ReturnOrder service error",
                        "order_id", orderIDStr,
                        "error", err,
                )
                if grpcErr := errs.GrpcError(err); grpcErr != nil </span><span class="cov0" title="0">{
                        return nil, grpcErr
                }</span>

                <span class="cov0" title="0">cause := errs.ErrorCause(err)
                return nil, grpcstatus.Error(codes.Internal, cause)</span>
        }

        <span class="cov0" title="0">return mappers.DomainToProtoOrderResponse(errCodes.CodeOrderReturned, orderIDStr)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package postgres

import (
        "fmt"
        "pvz-cli/internal/domain/models"
        "pvz-cli/internal/domain/vo"
        "strings"

        "github.com/jackc/pgx/v5"
)

// selectClause возвращает основу SELECT-части без WHERE
func selectClause() string <span class="cov0" title="0">{
        return `
SELECT
        id, user_id, status, expires_at,
        issued_at, returned_at, created_at,
        package, weight, price, total_price
FROM orders`
}</span>

// filterClause собирает WHERE-часть и параметры
func filterClause(userID string, onlyInPVZ bool) (string, []any) <span class="cov0" title="0">{
        conds := []string{"user_id = $1"}
        args := []any{userID}

        if onlyInPVZ </span><span class="cov0" title="0">{
                conds = append(conds, "status = 'ACCEPTED'")
        }</span>
        <span class="cov0" title="0">return "WHERE " + strings.Join(conds, " AND "), args</span>
}

// orderClause строит ORDER BY.
func orderClause(asc bool) string <span class="cov0" title="0">{
        dir := "DESC"
        if asc </span><span class="cov0" title="0">{
                dir = "ASC"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("ORDER BY created_at %s, id %s", dir, dir)</span>
}

func isEmptyPaging(p *vo.Pagination) bool <span class="cov0" title="0">{
        if p == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return p.Page == 0 &amp;&amp; p.Limit == 0</span>
}

// paginationClause строит LIMIT/OFFSET, возвращая новую args
func paginationClause(lastN int, pg *vo.Pagination, args []any) (string, []any) <span class="cov0" title="0">{
        if lastN &gt; 0 </span><span class="cov0" title="0">{
                args = append(args, lastN)
                return fmt.Sprintf("LIMIT $%d", len(args)), args
        }</span>
        <span class="cov0" title="0">if isEmptyPaging(pg) </span><span class="cov0" title="0">{
                return "", args
        }</span>
        // sane defaults
        <span class="cov0" title="0">if pg.Page &lt;= 0 </span><span class="cov0" title="0">{
                pg.Page = 1
        }</span>
        <span class="cov0" title="0">if pg.Limit &lt;= 0 </span><span class="cov0" title="0">{
                pg.Limit = 20
        }</span>
        <span class="cov0" title="0">offset := (pg.Page - 1) * pg.Limit
        args = append(args, pg.Limit, offset)
        return fmt.Sprintf("LIMIT $%d OFFSET $%d", len(args)-1, len(args)), args</span>
}

// scanOrders конвертирует pgx.Rows -&gt; []*models.Order
func scanOrders(rows pgx.Rows) ([]*models.Order, error) <span class="cov0" title="0">{
        defer rows.Close()

        var out []*models.Order
        for rows.Next() </span><span class="cov0" title="0">{
                var o models.Order
                if err := rows.Scan(
                        &amp;o.ID, &amp;o.UserID, &amp;o.Status, &amp;o.ExpiresAt,
                        &amp;o.IssuedAt, &amp;o.ReturnedAt, &amp;o.CreatedAt,
                        &amp;o.Package, &amp;o.Weight, &amp;o.Price, &amp;o.TotalPrice,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">out = append(out, &amp;o)</span>
        }
        <span class="cov0" title="0">return out, nil</span>
}

// scanReturnRecords конвертирует pgx.Rows → []*models.ReturnRecord
func scanReturnRecords(rows pgx.Rows) ([]*models.ReturnRecord, error) <span class="cov0" title="0">{
        defer rows.Close()

        var out []*models.ReturnRecord
        for rows.Next() </span><span class="cov0" title="0">{
                var rr models.ReturnRecord
                if err := rows.Scan(&amp;rr.OrderID, &amp;rr.UserID, &amp;rr.ReturnedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">out = append(out, &amp;rr)</span>
        }
        <span class="cov0" title="0">return out, nil</span>
}

// scanHistoryEvents конвертирует pgx.Rows → []*models.HistoryEvent.
func scanHistoryEvents(rows pgx.Rows) ([]*models.HistoryEvent, error) <span class="cov0" title="0">{
        defer rows.Close()

        var out []*models.HistoryEvent
        for rows.Next() </span><span class="cov0" title="0">{
                var he models.HistoryEvent
                if err := rows.Scan(&amp;he.OrderID, &amp;he.Status, &amp;he.Time); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">out = append(out, &amp;he)</span>
        }
        <span class="cov0" title="0">return out, nil</span>
}

// buildLimitOffset возвращает LIMIT/OFFSET и обновляет args
func buildLimitOffset(pg vo.Pagination, args []any) (string, []any) <span class="cov0" title="0">{
        if pg.Page &lt;= 0 </span><span class="cov0" title="0">{
                pg.Page = 1
        }</span>
        <span class="cov0" title="0">if pg.Limit &lt;= 0 </span><span class="cov0" title="0">{
                pg.Limit = 20
        }</span>
        <span class="cov0" title="0">offset := (pg.Page - 1) * pg.Limit
        args = append(args, pg.Limit, offset)
        clause := fmt.Sprintf("LIMIT $%d OFFSET $%d", len(args)-1, len(args))
        return clause, args</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package postgres

import (
        "context"
        "pvz-cli/internal/domain/models"
        "pvz-cli/internal/domain/vo"
        "pvz-cli/pkg/errs"
        "pvz-cli/pkg/txmanager"
)

type HistoryAndReturnsPostgresRepo struct {
        conn txmanager.TxManager
}

func NewHistoryAndReturnsPostgresRepo(conn txmanager.TxManager) *HistoryAndReturnsPostgresRepo <span class="cov0" title="0">{
        return &amp;HistoryAndReturnsPostgresRepo{
                conn: conn,
        }
}</span>

const (
        selectReturnsBase = `
                SELECT
                        order_id, user_id, returned_at
                FROM order_returns`

        selectHistoryBase = `
                SELECT
                        order_id, status, event_time
                FROM order_history`

        insertHistorySQL = `
        INSERT INTO order_history (
            order_id, status, event_time
        ) VALUES (
            $1, $2, $3
        );`

        insertReturnSQL = `
                INSERT INTO order_returns (
                        order_id, user_id, returned_at
                ) VALUES (
                        $1, $2, $3
                );`

        selectReturnsByUserSQL = `
                SELECT
                        order_id, user_id, returned_at
                FROM order_returns
                WHERE user_id = $1
                ORDER BY returned_at DESC, order_id DESC;`
)

func (r *HistoryAndReturnsPostgresRepo) ListReturns(
        ctx context.Context,
        pg vo.Pagination,
) ([]*models.ReturnRecord, error) <span class="cov0" title="0">{
        exec := r.conn.GetExecutor(ctx)

        limitClause, args := buildLimitOffset(pg, nil)
        sql := selectReturnsBase + `
                ORDER BY returned_at DESC, order_id DESC
                ` + limitClause

        rows, err := exec.Query(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Wrap(err,
                        errs.CodeDatabaseError, "failed to query returns")
        }</span>
        <span class="cov0" title="0">records, err := scanReturnRecords(rows)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Wrap(err,
                        errs.CodeDatabaseError, "failed to scan returns")
        }</span>
        <span class="cov0" title="0">return records, nil</span>
}

func (r *HistoryAndReturnsPostgresRepo) History(
        ctx context.Context,
        pg vo.Pagination,
) ([]*models.HistoryEvent, error) <span class="cov0" title="0">{
        exec := r.conn.GetExecutor(ctx)

        // page
        limitClause, args := buildLimitOffset(pg, nil)
        sql := selectHistoryBase + `
                ORDER BY event_time DESC, order_id DESC
                ` + limitClause

        rows, err := exec.Query(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Wrap(err,
                        errs.CodeDatabaseError, "failed to query history")
        }</span>
        <span class="cov0" title="0">events, err := scanHistoryEvents(rows)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Wrap(err,
                        errs.CodeDatabaseError, "failed to scan history")
        }</span>

        <span class="cov0" title="0">return events, nil</span>
}

func (r *HistoryAndReturnsPostgresRepo) AddHistory(ctx context.Context, e *models.HistoryEvent) error <span class="cov0" title="0">{
        exec := r.conn.GetExecutor(ctx)

        if _, err := exec.Exec(ctx,
                insertHistorySQL,
                e.OrderID, e.Status, e.Time,
        ); err != nil </span><span class="cov0" title="0">{
                return errs.Wrap(err,
                        errs.CodeDatabaseError,
                        "failed to insert history event",
                        "order_id", e.OrderID,
                )
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *HistoryAndReturnsPostgresRepo) AddReturn(ctx context.Context, rec *models.ReturnRecord) error <span class="cov0" title="0">{
        exec := r.conn.GetExecutor(ctx)

        if _, err := exec.Exec(ctx,
                insertReturnSQL,
                rec.OrderID, rec.UserID, rec.ReturnedAt,
        ); err != nil </span><span class="cov0" title="0">{
                return errs.Wrap(err,
                        errs.CodeDatabaseError,
                        "failed to insert return record",
                        "order_id", rec.OrderID,
                )
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *HistoryAndReturnsPostgresRepo) ListReturnsByUser(
        ctx context.Context,
        userID string,
) ([]*models.ReturnRecord, error) <span class="cov0" title="0">{
        exec := r.conn.GetExecutor(ctx)

        rows, err := exec.Query(ctx, selectReturnsByUserSQL, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Wrap(err,
                        errs.CodeDatabaseError, "failed to query returns by user", "user_id", userID)
        }</span>
        <span class="cov0" title="0">return scanReturnRecords(rows)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package postgres

import (
        "context"
        "errors"
        "pvz-cli/internal/domain/codes"
        "pvz-cli/internal/domain/models"
        "pvz-cli/internal/domain/vo"
        "pvz-cli/pkg/errs"
        "pvz-cli/pkg/txmanager"
        "strings"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type OrdersPostgresRepo struct {
        conn txmanager.TxManager
}

func NewOrdersPostgresRepo(conn txmanager.TxManager) *OrdersPostgresRepo <span class="cov0" title="0">{
        return &amp;OrdersPostgresRepo{
                conn: conn,
        }
}</span>

const (
        insertOrderSQL = `
                INSERT INTO orders (
                        id, user_id, status, expires_at,
                        issued_at, returned_at, created_at,
                        package, weight, price, total_price
                ) VALUES (
                        $1,$2,$3,$4,
                        $5,$6,$7,
                        $8,$9,$10,$11
                );`

        updateOrderSQL = `
                UPDATE orders SET
                        user_id      = $2,
                        status       = $3,
                        expires_at   = $4,
                        issued_at    = $5,
                        returned_at  = $6,
                        package      = $7,
                        weight       = $8,
                        price        = $9,
                        total_price  = $10
                WHERE id = $1;`

        selectOrderSQL = `
                SELECT
                        id, user_id, status, expires_at,
                        issued_at, returned_at, created_at,
                        package, weight, price, total_price
                FROM orders
                WHERE id = $1;`

        deleteOrderSQL = `DELETE FROM orders WHERE id = $1;`

        listAllSQL = `
                SELECT
                        id, user_id, status, expires_at,
                        issued_at, returned_at, created_at,
                        package, weight, price, total_price
                FROM orders
                ORDER BY created_at ASC, id ASC;`
)

func (r *OrdersPostgresRepo) Create(ctx context.Context, o *models.Order) error <span class="cov0" title="0">{
        exec := r.conn.GetExecutor(ctx)

        if _, err := exec.Exec(ctx,
                insertOrderSQL,
                o.ID, o.UserID, o.Status, o.ExpiresAt,
                o.IssuedAt, o.ReturnedAt, o.CreatedAt,
                o.Package, o.Weight, o.Price, o.TotalPrice,
        ); err != nil </span><span class="cov0" title="0">{
                return errs.Wrap(err, errs.CodeDatabaseError,
                        "failed to insert order", "order_id", o.ID)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *OrdersPostgresRepo) Update(ctx context.Context, o *models.Order) error <span class="cov0" title="0">{
        exec := r.conn.GetExecutor(ctx)

        tag, err := exec.Exec(ctx, updateOrderSQL,
                o.ID, o.UserID, o.Status, o.ExpiresAt,
                o.IssuedAt, o.ReturnedAt,
                o.Package, o.Weight, o.Price, o.TotalPrice,
        )
        if err != nil </span><span class="cov0" title="0">{
                return errs.Wrap(err, errs.CodeDatabaseError,
                        "failed to update order", "order_id", o.ID)
        }</span>
        <span class="cov0" title="0">if tag.RowsAffected() == 0 </span><span class="cov0" title="0">{
                return codes.ErrOrderNotFound
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *OrdersPostgresRepo) Get(ctx context.Context, id string) (*models.Order, error) <span class="cov0" title="0">{
        exec := r.conn.GetExecutor(ctx)

        var o models.Order
        if err := exec.QueryRow(ctx, selectOrderSQL, id).Scan(
                &amp;o.ID, &amp;o.UserID, &amp;o.Status, &amp;o.ExpiresAt,
                &amp;o.IssuedAt, &amp;o.ReturnedAt, &amp;o.CreatedAt,
                &amp;o.Package, &amp;o.Weight, &amp;o.Price, &amp;o.TotalPrice,
        ); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, codes.ErrOrderNotFound
                }</span>
                <span class="cov0" title="0">return nil, errs.Wrap(err, errs.CodeDatabaseError,
                        "failed to select order", "order_id", id)</span>
        }
        <span class="cov0" title="0">return &amp;o, nil</span>
}

func (r *OrdersPostgresRepo) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        exec := r.conn.GetExecutor(ctx)

        tag, err := exec.Exec(ctx, deleteOrderSQL, id)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Wrap(err, errs.CodeDatabaseError,
                        "failed to delete order", "order_id", id)
        }</span>
        <span class="cov0" title="0">if tag.RowsAffected() == 0 </span><span class="cov0" title="0">{
                return codes.ErrOrderNotFound
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *OrdersPostgresRepo) ListByUser(
        ctx context.Context,
        userID string,
        onlyInPVZ bool,
        lastN int,
        pg *vo.Pagination,
) ([]*models.Order, error) <span class="cov0" title="0">{
        exec := r.conn.GetExecutor(ctx)

        where, fArgs := filterClause(userID, onlyInPVZ)

        sel := selectClause()
        ord := orderClause(false)
        pag, args := paginationClause(lastN, pg, fArgs)

        fullQ := strings.Join([]string{sel, where, ord, pag}, " ")
        rows, err := exec.Query(ctx, fullQ, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Wrap(err, errs.CodeDatabaseError, "query failed")
        }</span>

        <span class="cov0" title="0">orders, err := scanOrders(rows)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Wrap(err, errs.CodeDatabaseError, "scan failed")
        }</span>
        <span class="cov0" title="0">return orders, nil</span>
}

func (r *OrdersPostgresRepo) ImportMany(ctx context.Context, list []*models.Order) error <span class="cov0" title="0">{
        exec := r.conn.GetExecutor(ctx)

        for _, o := range list </span><span class="cov0" title="0">{
                if _, err := exec.Exec(ctx, insertOrderSQL,
                        o.ID, o.UserID, o.Status, o.ExpiresAt,
                        o.IssuedAt, o.ReturnedAt, o.CreatedAt,
                        o.Package, o.Weight, o.Price, o.TotalPrice,
                ); err != nil </span><span class="cov0" title="0">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) &amp;&amp; pgErr.Code == "23505" </span><span class="cov0" title="0">{
                                return errs.New(errs.CodeRecordAlreadyExists,
                                        "order already exists", "orderID", o.ID)
                        }</span>
                        <span class="cov0" title="0">return errs.Wrap(err, errs.CodeDatabaseError,
                                "failed to import order", "orderID", o.ID)</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *OrdersPostgresRepo) ListAllOrders(ctx context.Context) ([]*models.Order, error) <span class="cov0" title="0">{

        exec := r.conn.GetExecutor(ctx)

        rows, err := exec.Query(ctx, listAllSQL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Wrap(err,
                        errs.CodeDatabaseError, "failed to list all orders")
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        orders, err := scanOrders(rows)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Wrap(err,
                        errs.CodeDatabaseError, "failed to scan orders")
        }</span>
        <span class="cov0" title="0">return orders, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i pvz-cli/internal/usecase.HistoryAndReturnsRepository -o history_and_returns_repo_mock.go -n HistoryAndReturnsRepositoryMock -p mock

import (
        "context"
        "pvz-cli/internal/domain/models"
        "pvz-cli/internal/domain/vo"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
)

// HistoryAndReturnsRepositoryMock implements mm_usecase.HistoryAndReturnsRepository
type HistoryAndReturnsRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcAddHistory          func(ctx context.Context, e *models.HistoryEvent) (err error)
        funcAddHistoryOrigin    string
        inspectFuncAddHistory   func(ctx context.Context, e *models.HistoryEvent)
        afterAddHistoryCounter  uint64
        beforeAddHistoryCounter uint64
        AddHistoryMock          mHistoryAndReturnsRepositoryMockAddHistory

        funcAddReturn          func(ctx context.Context, rec *models.ReturnRecord) (err error)
        funcAddReturnOrigin    string
        inspectFuncAddReturn   func(ctx context.Context, rec *models.ReturnRecord)
        afterAddReturnCounter  uint64
        beforeAddReturnCounter uint64
        AddReturnMock          mHistoryAndReturnsRepositoryMockAddReturn

        funcHistory          func(ctx context.Context, pg vo.Pagination) (hpa1 []*models.HistoryEvent, err error)
        funcHistoryOrigin    string
        inspectFuncHistory   func(ctx context.Context, pg vo.Pagination)
        afterHistoryCounter  uint64
        beforeHistoryCounter uint64
        HistoryMock          mHistoryAndReturnsRepositoryMockHistory

        funcListReturns          func(ctx context.Context, pg vo.Pagination) (rpa1 []*models.ReturnRecord, err error)
        funcListReturnsOrigin    string
        inspectFuncListReturns   func(ctx context.Context, pg vo.Pagination)
        afterListReturnsCounter  uint64
        beforeListReturnsCounter uint64
        ListReturnsMock          mHistoryAndReturnsRepositoryMockListReturns

        funcListReturnsByUser          func(ctx context.Context, userID string) (rpa1 []*models.ReturnRecord, err error)
        funcListReturnsByUserOrigin    string
        inspectFuncListReturnsByUser   func(ctx context.Context, userID string)
        afterListReturnsByUserCounter  uint64
        beforeListReturnsByUserCounter uint64
        ListReturnsByUserMock          mHistoryAndReturnsRepositoryMockListReturnsByUser
}

// NewHistoryAndReturnsRepositoryMock returns a mock for mm_usecase.HistoryAndReturnsRepository
func NewHistoryAndReturnsRepositoryMock(t minimock.Tester) *HistoryAndReturnsRepositoryMock <span class="cov0" title="0">{
        m := &amp;HistoryAndReturnsRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.AddHistoryMock = mHistoryAndReturnsRepositoryMockAddHistory{mock: m}
        m.AddHistoryMock.callArgs = []*HistoryAndReturnsRepositoryMockAddHistoryParams{}

        m.AddReturnMock = mHistoryAndReturnsRepositoryMockAddReturn{mock: m}
        m.AddReturnMock.callArgs = []*HistoryAndReturnsRepositoryMockAddReturnParams{}

        m.HistoryMock = mHistoryAndReturnsRepositoryMockHistory{mock: m}
        m.HistoryMock.callArgs = []*HistoryAndReturnsRepositoryMockHistoryParams{}

        m.ListReturnsMock = mHistoryAndReturnsRepositoryMockListReturns{mock: m}
        m.ListReturnsMock.callArgs = []*HistoryAndReturnsRepositoryMockListReturnsParams{}

        m.ListReturnsByUserMock = mHistoryAndReturnsRepositoryMockListReturnsByUser{mock: m}
        m.ListReturnsByUserMock.callArgs = []*HistoryAndReturnsRepositoryMockListReturnsByUserParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mHistoryAndReturnsRepositoryMockAddHistory struct {
        optional           bool
        mock               *HistoryAndReturnsRepositoryMock
        defaultExpectation *HistoryAndReturnsRepositoryMockAddHistoryExpectation
        expectations       []*HistoryAndReturnsRepositoryMockAddHistoryExpectation

        callArgs []*HistoryAndReturnsRepositoryMockAddHistoryParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// HistoryAndReturnsRepositoryMockAddHistoryExpectation specifies expectation struct of the HistoryAndReturnsRepository.AddHistory
type HistoryAndReturnsRepositoryMockAddHistoryExpectation struct {
        mock               *HistoryAndReturnsRepositoryMock
        params             *HistoryAndReturnsRepositoryMockAddHistoryParams
        paramPtrs          *HistoryAndReturnsRepositoryMockAddHistoryParamPtrs
        expectationOrigins HistoryAndReturnsRepositoryMockAddHistoryExpectationOrigins
        results            *HistoryAndReturnsRepositoryMockAddHistoryResults
        returnOrigin       string
        Counter            uint64
}

// HistoryAndReturnsRepositoryMockAddHistoryParams contains parameters of the HistoryAndReturnsRepository.AddHistory
type HistoryAndReturnsRepositoryMockAddHistoryParams struct {
        ctx context.Context
        e   *models.HistoryEvent
}

// HistoryAndReturnsRepositoryMockAddHistoryParamPtrs contains pointers to parameters of the HistoryAndReturnsRepository.AddHistory
type HistoryAndReturnsRepositoryMockAddHistoryParamPtrs struct {
        ctx *context.Context
        e   **models.HistoryEvent
}

// HistoryAndReturnsRepositoryMockAddHistoryResults contains results of the HistoryAndReturnsRepository.AddHistory
type HistoryAndReturnsRepositoryMockAddHistoryResults struct {
        err error
}

// HistoryAndReturnsRepositoryMockAddHistoryOrigins contains origins of expectations of the HistoryAndReturnsRepository.AddHistory
type HistoryAndReturnsRepositoryMockAddHistoryExpectationOrigins struct {
        origin    string
        originCtx string
        originE   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) Optional() *mHistoryAndReturnsRepositoryMockAddHistory <span class="cov0" title="0">{
        mmAddHistory.optional = true
        return mmAddHistory
}</span>

// Expect sets up expected params for HistoryAndReturnsRepository.AddHistory
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) Expect(ctx context.Context, e *models.HistoryEvent) *mHistoryAndReturnsRepositoryMockAddHistory <span class="cov0" title="0">{
        if mmAddHistory.mock.funcAddHistory != nil </span><span class="cov0" title="0">{
                mmAddHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddHistory mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddHistory.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddHistory.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockAddHistoryExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAddHistory.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmAddHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddHistory mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmAddHistory.defaultExpectation.params = &amp;HistoryAndReturnsRepositoryMockAddHistoryParams{ctx, e}
        mmAddHistory.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmAddHistory.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmAddHistory.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmAddHistory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddHistory.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmAddHistory</span>
}

// ExpectCtxParam1 sets up expected param ctx for HistoryAndReturnsRepository.AddHistory
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) ExpectCtxParam1(ctx context.Context) *mHistoryAndReturnsRepositoryMockAddHistory <span class="cov0" title="0">{
        if mmAddHistory.mock.funcAddHistory != nil </span><span class="cov0" title="0">{
                mmAddHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddHistory mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddHistory.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddHistory.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockAddHistoryExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAddHistory.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmAddHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddHistory mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmAddHistory.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmAddHistory.defaultExpectation.paramPtrs = &amp;HistoryAndReturnsRepositoryMockAddHistoryParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmAddHistory.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmAddHistory.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmAddHistory</span>
}

// ExpectEParam2 sets up expected param e for HistoryAndReturnsRepository.AddHistory
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) ExpectEParam2(e *models.HistoryEvent) *mHistoryAndReturnsRepositoryMockAddHistory <span class="cov0" title="0">{
        if mmAddHistory.mock.funcAddHistory != nil </span><span class="cov0" title="0">{
                mmAddHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddHistory mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddHistory.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddHistory.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockAddHistoryExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAddHistory.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmAddHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddHistory mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmAddHistory.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmAddHistory.defaultExpectation.paramPtrs = &amp;HistoryAndReturnsRepositoryMockAddHistoryParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmAddHistory.defaultExpectation.paramPtrs.e = &amp;e
        mmAddHistory.defaultExpectation.expectationOrigins.originE = minimock.CallerInfo(1)

        return mmAddHistory</span>
}

// Inspect accepts an inspector function that has same arguments as the HistoryAndReturnsRepository.AddHistory
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) Inspect(f func(ctx context.Context, e *models.HistoryEvent)) *mHistoryAndReturnsRepositoryMockAddHistory <span class="cov0" title="0">{
        if mmAddHistory.mock.inspectFuncAddHistory != nil </span><span class="cov0" title="0">{
                mmAddHistory.mock.t.Fatalf("Inspect function is already set for HistoryAndReturnsRepositoryMock.AddHistory")
        }</span>

        <span class="cov0" title="0">mmAddHistory.mock.inspectFuncAddHistory = f

        return mmAddHistory</span>
}

// Return sets up results that will be returned by HistoryAndReturnsRepository.AddHistory
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) Return(err error) *HistoryAndReturnsRepositoryMock <span class="cov0" title="0">{
        if mmAddHistory.mock.funcAddHistory != nil </span><span class="cov0" title="0">{
                mmAddHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddHistory mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddHistory.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddHistory.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockAddHistoryExpectation{mock: mmAddHistory.mock}
        }</span>
        <span class="cov0" title="0">mmAddHistory.defaultExpectation.results = &amp;HistoryAndReturnsRepositoryMockAddHistoryResults{err}
        mmAddHistory.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmAddHistory.mock</span>
}

// Set uses given function f to mock the HistoryAndReturnsRepository.AddHistory method
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) Set(f func(ctx context.Context, e *models.HistoryEvent) (err error)) *HistoryAndReturnsRepositoryMock <span class="cov0" title="0">{
        if mmAddHistory.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmAddHistory.mock.t.Fatalf("Default expectation is already set for the HistoryAndReturnsRepository.AddHistory method")
        }</span>

        <span class="cov0" title="0">if len(mmAddHistory.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmAddHistory.mock.t.Fatalf("Some expectations are already set for the HistoryAndReturnsRepository.AddHistory method")
        }</span>

        <span class="cov0" title="0">mmAddHistory.mock.funcAddHistory = f
        mmAddHistory.mock.funcAddHistoryOrigin = minimock.CallerInfo(1)
        return mmAddHistory.mock</span>
}

// When sets expectation for the HistoryAndReturnsRepository.AddHistory which will trigger the result defined by the following
// Then helper
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) When(ctx context.Context, e *models.HistoryEvent) *HistoryAndReturnsRepositoryMockAddHistoryExpectation <span class="cov0" title="0">{
        if mmAddHistory.mock.funcAddHistory != nil </span><span class="cov0" title="0">{
                mmAddHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddHistory mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;HistoryAndReturnsRepositoryMockAddHistoryExpectation{
                mock:               mmAddHistory.mock,
                params:             &amp;HistoryAndReturnsRepositoryMockAddHistoryParams{ctx, e},
                expectationOrigins: HistoryAndReturnsRepositoryMockAddHistoryExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmAddHistory.expectations = append(mmAddHistory.expectations, expectation)
        return expectation</span>
}

// Then sets up HistoryAndReturnsRepository.AddHistory return parameters for the expectation previously defined by the When method
func (e *HistoryAndReturnsRepositoryMockAddHistoryExpectation) Then(err error) *HistoryAndReturnsRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;HistoryAndReturnsRepositoryMockAddHistoryResults{err}
        return e.mock
}</span>

// Times sets number of times HistoryAndReturnsRepository.AddHistory should be invoked
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) Times(n uint64) *mHistoryAndReturnsRepositoryMockAddHistory <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmAddHistory.mock.t.Fatalf("Times of HistoryAndReturnsRepositoryMock.AddHistory mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmAddHistory.expectedInvocations, n)
        mmAddHistory.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmAddHistory</span>
}

func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmAddHistory.expectations) == 0 &amp;&amp; mmAddHistory.defaultExpectation == nil &amp;&amp; mmAddHistory.mock.funcAddHistory == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmAddHistory.mock.afterAddHistoryCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmAddHistory.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// AddHistory implements mm_usecase.HistoryAndReturnsRepository
func (mmAddHistory *HistoryAndReturnsRepositoryMock) AddHistory(ctx context.Context, e *models.HistoryEvent) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmAddHistory.beforeAddHistoryCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmAddHistory.afterAddHistoryCounter, 1)

        mmAddHistory.t.Helper()

        if mmAddHistory.inspectFuncAddHistory != nil </span><span class="cov0" title="0">{
                mmAddHistory.inspectFuncAddHistory(ctx, e)
        }</span>

        <span class="cov0" title="0">mm_params := HistoryAndReturnsRepositoryMockAddHistoryParams{ctx, e}

        // Record call args
        mmAddHistory.AddHistoryMock.mutex.Lock()
        mmAddHistory.AddHistoryMock.callArgs = append(mmAddHistory.AddHistoryMock.callArgs, &amp;mm_params)
        mmAddHistory.AddHistoryMock.mutex.Unlock()

        for _, e := range mmAddHistory.AddHistoryMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmAddHistory.AddHistoryMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmAddHistory.AddHistoryMock.defaultExpectation.Counter, 1)
                mm_want := mmAddHistory.AddHistoryMock.defaultExpectation.params
                mm_want_ptrs := mmAddHistory.AddHistoryMock.defaultExpectation.paramPtrs

                mm_got := HistoryAndReturnsRepositoryMockAddHistoryParams{ctx, e}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmAddHistory.t.Errorf("HistoryAndReturnsRepositoryMock.AddHistory got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmAddHistory.AddHistoryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.e != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.e, mm_got.e) </span><span class="cov0" title="0">{
                                mmAddHistory.t.Errorf("HistoryAndReturnsRepositoryMock.AddHistory got unexpected parameter e, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmAddHistory.AddHistoryMock.defaultExpectation.expectationOrigins.originE, *mm_want_ptrs.e, mm_got.e, minimock.Diff(*mm_want_ptrs.e, mm_got.e))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmAddHistory.t.Errorf("HistoryAndReturnsRepositoryMock.AddHistory got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmAddHistory.AddHistoryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmAddHistory.AddHistoryMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmAddHistory.t.Fatal("No results are set for the HistoryAndReturnsRepositoryMock.AddHistory")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmAddHistory.funcAddHistory != nil </span><span class="cov0" title="0">{
                return mmAddHistory.funcAddHistory(ctx, e)
        }</span>
        <span class="cov0" title="0">mmAddHistory.t.Fatalf("Unexpected call to HistoryAndReturnsRepositoryMock.AddHistory. %v %v", ctx, e)
        return</span>
}

// AddHistoryAfterCounter returns a count of finished HistoryAndReturnsRepositoryMock.AddHistory invocations
func (mmAddHistory *HistoryAndReturnsRepositoryMock) AddHistoryAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAddHistory.afterAddHistoryCounter)
}</span>

// AddHistoryBeforeCounter returns a count of HistoryAndReturnsRepositoryMock.AddHistory invocations
func (mmAddHistory *HistoryAndReturnsRepositoryMock) AddHistoryBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAddHistory.beforeAddHistoryCounter)
}</span>

// Calls returns a list of arguments used in each call to HistoryAndReturnsRepositoryMock.AddHistory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddHistory *mHistoryAndReturnsRepositoryMockAddHistory) Calls() []*HistoryAndReturnsRepositoryMockAddHistoryParams <span class="cov0" title="0">{
        mmAddHistory.mutex.RLock()

        argCopy := make([]*HistoryAndReturnsRepositoryMockAddHistoryParams, len(mmAddHistory.callArgs))
        copy(argCopy, mmAddHistory.callArgs)

        mmAddHistory.mutex.RUnlock()

        return argCopy
}</span>

// MinimockAddHistoryDone returns true if the count of the AddHistory invocations corresponds
// the number of defined expectations
func (m *HistoryAndReturnsRepositoryMock) MinimockAddHistoryDone() bool <span class="cov0" title="0">{
        if m.AddHistoryMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.AddHistoryMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.AddHistoryMock.invocationsDone()</span>
}

// MinimockAddHistoryInspect logs each unmet expectation
func (m *HistoryAndReturnsRepositoryMock) MinimockAddHistoryInspect() <span class="cov0" title="0">{
        for _, e := range m.AddHistoryMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.AddHistory at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterAddHistoryCounter := mm_atomic.LoadUint64(&amp;m.afterAddHistoryCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.AddHistoryMock.defaultExpectation != nil &amp;&amp; afterAddHistoryCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.AddHistoryMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.AddHistory at\n%s", m.AddHistoryMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.AddHistory at\n%s with params: %#v", m.AddHistoryMock.defaultExpectation.expectationOrigins.origin, *m.AddHistoryMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcAddHistory != nil &amp;&amp; afterAddHistoryCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.AddHistory at\n%s", m.funcAddHistoryOrigin)
        }</span>

        <span class="cov0" title="0">if !m.AddHistoryMock.invocationsDone() &amp;&amp; afterAddHistoryCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to HistoryAndReturnsRepositoryMock.AddHistory at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.AddHistoryMock.expectedInvocations), m.AddHistoryMock.expectedInvocationsOrigin, afterAddHistoryCounter)
        }</span>
}

type mHistoryAndReturnsRepositoryMockAddReturn struct {
        optional           bool
        mock               *HistoryAndReturnsRepositoryMock
        defaultExpectation *HistoryAndReturnsRepositoryMockAddReturnExpectation
        expectations       []*HistoryAndReturnsRepositoryMockAddReturnExpectation

        callArgs []*HistoryAndReturnsRepositoryMockAddReturnParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// HistoryAndReturnsRepositoryMockAddReturnExpectation specifies expectation struct of the HistoryAndReturnsRepository.AddReturn
type HistoryAndReturnsRepositoryMockAddReturnExpectation struct {
        mock               *HistoryAndReturnsRepositoryMock
        params             *HistoryAndReturnsRepositoryMockAddReturnParams
        paramPtrs          *HistoryAndReturnsRepositoryMockAddReturnParamPtrs
        expectationOrigins HistoryAndReturnsRepositoryMockAddReturnExpectationOrigins
        results            *HistoryAndReturnsRepositoryMockAddReturnResults
        returnOrigin       string
        Counter            uint64
}

// HistoryAndReturnsRepositoryMockAddReturnParams contains parameters of the HistoryAndReturnsRepository.AddReturn
type HistoryAndReturnsRepositoryMockAddReturnParams struct {
        ctx context.Context
        rec *models.ReturnRecord
}

// HistoryAndReturnsRepositoryMockAddReturnParamPtrs contains pointers to parameters of the HistoryAndReturnsRepository.AddReturn
type HistoryAndReturnsRepositoryMockAddReturnParamPtrs struct {
        ctx *context.Context
        rec **models.ReturnRecord
}

// HistoryAndReturnsRepositoryMockAddReturnResults contains results of the HistoryAndReturnsRepository.AddReturn
type HistoryAndReturnsRepositoryMockAddReturnResults struct {
        err error
}

// HistoryAndReturnsRepositoryMockAddReturnOrigins contains origins of expectations of the HistoryAndReturnsRepository.AddReturn
type HistoryAndReturnsRepositoryMockAddReturnExpectationOrigins struct {
        origin    string
        originCtx string
        originRec string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) Optional() *mHistoryAndReturnsRepositoryMockAddReturn <span class="cov0" title="0">{
        mmAddReturn.optional = true
        return mmAddReturn
}</span>

// Expect sets up expected params for HistoryAndReturnsRepository.AddReturn
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) Expect(ctx context.Context, rec *models.ReturnRecord) *mHistoryAndReturnsRepositoryMockAddReturn <span class="cov0" title="0">{
        if mmAddReturn.mock.funcAddReturn != nil </span><span class="cov0" title="0">{
                mmAddReturn.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddReturn mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddReturn.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddReturn.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockAddReturnExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAddReturn.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmAddReturn.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddReturn mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmAddReturn.defaultExpectation.params = &amp;HistoryAndReturnsRepositoryMockAddReturnParams{ctx, rec}
        mmAddReturn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmAddReturn.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmAddReturn.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmAddReturn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddReturn.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmAddReturn</span>
}

// ExpectCtxParam1 sets up expected param ctx for HistoryAndReturnsRepository.AddReturn
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) ExpectCtxParam1(ctx context.Context) *mHistoryAndReturnsRepositoryMockAddReturn <span class="cov0" title="0">{
        if mmAddReturn.mock.funcAddReturn != nil </span><span class="cov0" title="0">{
                mmAddReturn.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddReturn mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddReturn.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddReturn.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockAddReturnExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAddReturn.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmAddReturn.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddReturn mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmAddReturn.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmAddReturn.defaultExpectation.paramPtrs = &amp;HistoryAndReturnsRepositoryMockAddReturnParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmAddReturn.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmAddReturn.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmAddReturn</span>
}

// ExpectRecParam2 sets up expected param rec for HistoryAndReturnsRepository.AddReturn
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) ExpectRecParam2(rec *models.ReturnRecord) *mHistoryAndReturnsRepositoryMockAddReturn <span class="cov0" title="0">{
        if mmAddReturn.mock.funcAddReturn != nil </span><span class="cov0" title="0">{
                mmAddReturn.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddReturn mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddReturn.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddReturn.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockAddReturnExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAddReturn.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmAddReturn.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddReturn mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmAddReturn.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmAddReturn.defaultExpectation.paramPtrs = &amp;HistoryAndReturnsRepositoryMockAddReturnParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmAddReturn.defaultExpectation.paramPtrs.rec = &amp;rec
        mmAddReturn.defaultExpectation.expectationOrigins.originRec = minimock.CallerInfo(1)

        return mmAddReturn</span>
}

// Inspect accepts an inspector function that has same arguments as the HistoryAndReturnsRepository.AddReturn
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) Inspect(f func(ctx context.Context, rec *models.ReturnRecord)) *mHistoryAndReturnsRepositoryMockAddReturn <span class="cov0" title="0">{
        if mmAddReturn.mock.inspectFuncAddReturn != nil </span><span class="cov0" title="0">{
                mmAddReturn.mock.t.Fatalf("Inspect function is already set for HistoryAndReturnsRepositoryMock.AddReturn")
        }</span>

        <span class="cov0" title="0">mmAddReturn.mock.inspectFuncAddReturn = f

        return mmAddReturn</span>
}

// Return sets up results that will be returned by HistoryAndReturnsRepository.AddReturn
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) Return(err error) *HistoryAndReturnsRepositoryMock <span class="cov0" title="0">{
        if mmAddReturn.mock.funcAddReturn != nil </span><span class="cov0" title="0">{
                mmAddReturn.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddReturn mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddReturn.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddReturn.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockAddReturnExpectation{mock: mmAddReturn.mock}
        }</span>
        <span class="cov0" title="0">mmAddReturn.defaultExpectation.results = &amp;HistoryAndReturnsRepositoryMockAddReturnResults{err}
        mmAddReturn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmAddReturn.mock</span>
}

// Set uses given function f to mock the HistoryAndReturnsRepository.AddReturn method
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) Set(f func(ctx context.Context, rec *models.ReturnRecord) (err error)) *HistoryAndReturnsRepositoryMock <span class="cov0" title="0">{
        if mmAddReturn.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmAddReturn.mock.t.Fatalf("Default expectation is already set for the HistoryAndReturnsRepository.AddReturn method")
        }</span>

        <span class="cov0" title="0">if len(mmAddReturn.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmAddReturn.mock.t.Fatalf("Some expectations are already set for the HistoryAndReturnsRepository.AddReturn method")
        }</span>

        <span class="cov0" title="0">mmAddReturn.mock.funcAddReturn = f
        mmAddReturn.mock.funcAddReturnOrigin = minimock.CallerInfo(1)
        return mmAddReturn.mock</span>
}

// When sets expectation for the HistoryAndReturnsRepository.AddReturn which will trigger the result defined by the following
// Then helper
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) When(ctx context.Context, rec *models.ReturnRecord) *HistoryAndReturnsRepositoryMockAddReturnExpectation <span class="cov0" title="0">{
        if mmAddReturn.mock.funcAddReturn != nil </span><span class="cov0" title="0">{
                mmAddReturn.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.AddReturn mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;HistoryAndReturnsRepositoryMockAddReturnExpectation{
                mock:               mmAddReturn.mock,
                params:             &amp;HistoryAndReturnsRepositoryMockAddReturnParams{ctx, rec},
                expectationOrigins: HistoryAndReturnsRepositoryMockAddReturnExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmAddReturn.expectations = append(mmAddReturn.expectations, expectation)
        return expectation</span>
}

// Then sets up HistoryAndReturnsRepository.AddReturn return parameters for the expectation previously defined by the When method
func (e *HistoryAndReturnsRepositoryMockAddReturnExpectation) Then(err error) *HistoryAndReturnsRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;HistoryAndReturnsRepositoryMockAddReturnResults{err}
        return e.mock
}</span>

// Times sets number of times HistoryAndReturnsRepository.AddReturn should be invoked
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) Times(n uint64) *mHistoryAndReturnsRepositoryMockAddReturn <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmAddReturn.mock.t.Fatalf("Times of HistoryAndReturnsRepositoryMock.AddReturn mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmAddReturn.expectedInvocations, n)
        mmAddReturn.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmAddReturn</span>
}

func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmAddReturn.expectations) == 0 &amp;&amp; mmAddReturn.defaultExpectation == nil &amp;&amp; mmAddReturn.mock.funcAddReturn == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmAddReturn.mock.afterAddReturnCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmAddReturn.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// AddReturn implements mm_usecase.HistoryAndReturnsRepository
func (mmAddReturn *HistoryAndReturnsRepositoryMock) AddReturn(ctx context.Context, rec *models.ReturnRecord) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmAddReturn.beforeAddReturnCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmAddReturn.afterAddReturnCounter, 1)

        mmAddReturn.t.Helper()

        if mmAddReturn.inspectFuncAddReturn != nil </span><span class="cov0" title="0">{
                mmAddReturn.inspectFuncAddReturn(ctx, rec)
        }</span>

        <span class="cov0" title="0">mm_params := HistoryAndReturnsRepositoryMockAddReturnParams{ctx, rec}

        // Record call args
        mmAddReturn.AddReturnMock.mutex.Lock()
        mmAddReturn.AddReturnMock.callArgs = append(mmAddReturn.AddReturnMock.callArgs, &amp;mm_params)
        mmAddReturn.AddReturnMock.mutex.Unlock()

        for _, e := range mmAddReturn.AddReturnMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmAddReturn.AddReturnMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmAddReturn.AddReturnMock.defaultExpectation.Counter, 1)
                mm_want := mmAddReturn.AddReturnMock.defaultExpectation.params
                mm_want_ptrs := mmAddReturn.AddReturnMock.defaultExpectation.paramPtrs

                mm_got := HistoryAndReturnsRepositoryMockAddReturnParams{ctx, rec}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmAddReturn.t.Errorf("HistoryAndReturnsRepositoryMock.AddReturn got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmAddReturn.AddReturnMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.rec != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.rec, mm_got.rec) </span><span class="cov0" title="0">{
                                mmAddReturn.t.Errorf("HistoryAndReturnsRepositoryMock.AddReturn got unexpected parameter rec, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmAddReturn.AddReturnMock.defaultExpectation.expectationOrigins.originRec, *mm_want_ptrs.rec, mm_got.rec, minimock.Diff(*mm_want_ptrs.rec, mm_got.rec))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmAddReturn.t.Errorf("HistoryAndReturnsRepositoryMock.AddReturn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmAddReturn.AddReturnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmAddReturn.AddReturnMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmAddReturn.t.Fatal("No results are set for the HistoryAndReturnsRepositoryMock.AddReturn")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmAddReturn.funcAddReturn != nil </span><span class="cov0" title="0">{
                return mmAddReturn.funcAddReturn(ctx, rec)
        }</span>
        <span class="cov0" title="0">mmAddReturn.t.Fatalf("Unexpected call to HistoryAndReturnsRepositoryMock.AddReturn. %v %v", ctx, rec)
        return</span>
}

// AddReturnAfterCounter returns a count of finished HistoryAndReturnsRepositoryMock.AddReturn invocations
func (mmAddReturn *HistoryAndReturnsRepositoryMock) AddReturnAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAddReturn.afterAddReturnCounter)
}</span>

// AddReturnBeforeCounter returns a count of HistoryAndReturnsRepositoryMock.AddReturn invocations
func (mmAddReturn *HistoryAndReturnsRepositoryMock) AddReturnBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAddReturn.beforeAddReturnCounter)
}</span>

// Calls returns a list of arguments used in each call to HistoryAndReturnsRepositoryMock.AddReturn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddReturn *mHistoryAndReturnsRepositoryMockAddReturn) Calls() []*HistoryAndReturnsRepositoryMockAddReturnParams <span class="cov0" title="0">{
        mmAddReturn.mutex.RLock()

        argCopy := make([]*HistoryAndReturnsRepositoryMockAddReturnParams, len(mmAddReturn.callArgs))
        copy(argCopy, mmAddReturn.callArgs)

        mmAddReturn.mutex.RUnlock()

        return argCopy
}</span>

// MinimockAddReturnDone returns true if the count of the AddReturn invocations corresponds
// the number of defined expectations
func (m *HistoryAndReturnsRepositoryMock) MinimockAddReturnDone() bool <span class="cov0" title="0">{
        if m.AddReturnMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.AddReturnMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.AddReturnMock.invocationsDone()</span>
}

// MinimockAddReturnInspect logs each unmet expectation
func (m *HistoryAndReturnsRepositoryMock) MinimockAddReturnInspect() <span class="cov0" title="0">{
        for _, e := range m.AddReturnMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.AddReturn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterAddReturnCounter := mm_atomic.LoadUint64(&amp;m.afterAddReturnCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.AddReturnMock.defaultExpectation != nil &amp;&amp; afterAddReturnCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.AddReturnMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.AddReturn at\n%s", m.AddReturnMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.AddReturn at\n%s with params: %#v", m.AddReturnMock.defaultExpectation.expectationOrigins.origin, *m.AddReturnMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcAddReturn != nil &amp;&amp; afterAddReturnCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.AddReturn at\n%s", m.funcAddReturnOrigin)
        }</span>

        <span class="cov0" title="0">if !m.AddReturnMock.invocationsDone() &amp;&amp; afterAddReturnCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to HistoryAndReturnsRepositoryMock.AddReturn at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.AddReturnMock.expectedInvocations), m.AddReturnMock.expectedInvocationsOrigin, afterAddReturnCounter)
        }</span>
}

type mHistoryAndReturnsRepositoryMockHistory struct {
        optional           bool
        mock               *HistoryAndReturnsRepositoryMock
        defaultExpectation *HistoryAndReturnsRepositoryMockHistoryExpectation
        expectations       []*HistoryAndReturnsRepositoryMockHistoryExpectation

        callArgs []*HistoryAndReturnsRepositoryMockHistoryParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// HistoryAndReturnsRepositoryMockHistoryExpectation specifies expectation struct of the HistoryAndReturnsRepository.History
type HistoryAndReturnsRepositoryMockHistoryExpectation struct {
        mock               *HistoryAndReturnsRepositoryMock
        params             *HistoryAndReturnsRepositoryMockHistoryParams
        paramPtrs          *HistoryAndReturnsRepositoryMockHistoryParamPtrs
        expectationOrigins HistoryAndReturnsRepositoryMockHistoryExpectationOrigins
        results            *HistoryAndReturnsRepositoryMockHistoryResults
        returnOrigin       string
        Counter            uint64
}

// HistoryAndReturnsRepositoryMockHistoryParams contains parameters of the HistoryAndReturnsRepository.History
type HistoryAndReturnsRepositoryMockHistoryParams struct {
        ctx context.Context
        pg  vo.Pagination
}

// HistoryAndReturnsRepositoryMockHistoryParamPtrs contains pointers to parameters of the HistoryAndReturnsRepository.History
type HistoryAndReturnsRepositoryMockHistoryParamPtrs struct {
        ctx *context.Context
        pg  *vo.Pagination
}

// HistoryAndReturnsRepositoryMockHistoryResults contains results of the HistoryAndReturnsRepository.History
type HistoryAndReturnsRepositoryMockHistoryResults struct {
        hpa1 []*models.HistoryEvent
        err  error
}

// HistoryAndReturnsRepositoryMockHistoryOrigins contains origins of expectations of the HistoryAndReturnsRepository.History
type HistoryAndReturnsRepositoryMockHistoryExpectationOrigins struct {
        origin    string
        originCtx string
        originPg  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) Optional() *mHistoryAndReturnsRepositoryMockHistory <span class="cov0" title="0">{
        mmHistory.optional = true
        return mmHistory
}</span>

// Expect sets up expected params for HistoryAndReturnsRepository.History
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) Expect(ctx context.Context, pg vo.Pagination) *mHistoryAndReturnsRepositoryMockHistory <span class="cov0" title="0">{
        if mmHistory.mock.funcHistory != nil </span><span class="cov0" title="0">{
                mmHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.History mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmHistory.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmHistory.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockHistoryExpectation{}
        }</span>

        <span class="cov0" title="0">if mmHistory.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.History mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmHistory.defaultExpectation.params = &amp;HistoryAndReturnsRepositoryMockHistoryParams{ctx, pg}
        mmHistory.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmHistory.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmHistory.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmHistory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHistory.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmHistory</span>
}

// ExpectCtxParam1 sets up expected param ctx for HistoryAndReturnsRepository.History
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) ExpectCtxParam1(ctx context.Context) *mHistoryAndReturnsRepositoryMockHistory <span class="cov0" title="0">{
        if mmHistory.mock.funcHistory != nil </span><span class="cov0" title="0">{
                mmHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.History mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmHistory.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmHistory.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockHistoryExpectation{}
        }</span>

        <span class="cov0" title="0">if mmHistory.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.History mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmHistory.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmHistory.defaultExpectation.paramPtrs = &amp;HistoryAndReturnsRepositoryMockHistoryParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmHistory.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmHistory.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmHistory</span>
}

// ExpectPgParam2 sets up expected param pg for HistoryAndReturnsRepository.History
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) ExpectPgParam2(pg vo.Pagination) *mHistoryAndReturnsRepositoryMockHistory <span class="cov0" title="0">{
        if mmHistory.mock.funcHistory != nil </span><span class="cov0" title="0">{
                mmHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.History mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmHistory.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmHistory.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockHistoryExpectation{}
        }</span>

        <span class="cov0" title="0">if mmHistory.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.History mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmHistory.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmHistory.defaultExpectation.paramPtrs = &amp;HistoryAndReturnsRepositoryMockHistoryParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmHistory.defaultExpectation.paramPtrs.pg = &amp;pg
        mmHistory.defaultExpectation.expectationOrigins.originPg = minimock.CallerInfo(1)

        return mmHistory</span>
}

// Inspect accepts an inspector function that has same arguments as the HistoryAndReturnsRepository.History
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) Inspect(f func(ctx context.Context, pg vo.Pagination)) *mHistoryAndReturnsRepositoryMockHistory <span class="cov0" title="0">{
        if mmHistory.mock.inspectFuncHistory != nil </span><span class="cov0" title="0">{
                mmHistory.mock.t.Fatalf("Inspect function is already set for HistoryAndReturnsRepositoryMock.History")
        }</span>

        <span class="cov0" title="0">mmHistory.mock.inspectFuncHistory = f

        return mmHistory</span>
}

// Return sets up results that will be returned by HistoryAndReturnsRepository.History
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) Return(hpa1 []*models.HistoryEvent, err error) *HistoryAndReturnsRepositoryMock <span class="cov0" title="0">{
        if mmHistory.mock.funcHistory != nil </span><span class="cov0" title="0">{
                mmHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.History mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmHistory.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmHistory.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockHistoryExpectation{mock: mmHistory.mock}
        }</span>
        <span class="cov0" title="0">mmHistory.defaultExpectation.results = &amp;HistoryAndReturnsRepositoryMockHistoryResults{hpa1, err}
        mmHistory.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmHistory.mock</span>
}

// Set uses given function f to mock the HistoryAndReturnsRepository.History method
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) Set(f func(ctx context.Context, pg vo.Pagination) (hpa1 []*models.HistoryEvent, err error)) *HistoryAndReturnsRepositoryMock <span class="cov0" title="0">{
        if mmHistory.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmHistory.mock.t.Fatalf("Default expectation is already set for the HistoryAndReturnsRepository.History method")
        }</span>

        <span class="cov0" title="0">if len(mmHistory.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmHistory.mock.t.Fatalf("Some expectations are already set for the HistoryAndReturnsRepository.History method")
        }</span>

        <span class="cov0" title="0">mmHistory.mock.funcHistory = f
        mmHistory.mock.funcHistoryOrigin = minimock.CallerInfo(1)
        return mmHistory.mock</span>
}

// When sets expectation for the HistoryAndReturnsRepository.History which will trigger the result defined by the following
// Then helper
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) When(ctx context.Context, pg vo.Pagination) *HistoryAndReturnsRepositoryMockHistoryExpectation <span class="cov0" title="0">{
        if mmHistory.mock.funcHistory != nil </span><span class="cov0" title="0">{
                mmHistory.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.History mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;HistoryAndReturnsRepositoryMockHistoryExpectation{
                mock:               mmHistory.mock,
                params:             &amp;HistoryAndReturnsRepositoryMockHistoryParams{ctx, pg},
                expectationOrigins: HistoryAndReturnsRepositoryMockHistoryExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmHistory.expectations = append(mmHistory.expectations, expectation)
        return expectation</span>
}

// Then sets up HistoryAndReturnsRepository.History return parameters for the expectation previously defined by the When method
func (e *HistoryAndReturnsRepositoryMockHistoryExpectation) Then(hpa1 []*models.HistoryEvent, err error) *HistoryAndReturnsRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;HistoryAndReturnsRepositoryMockHistoryResults{hpa1, err}
        return e.mock
}</span>

// Times sets number of times HistoryAndReturnsRepository.History should be invoked
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) Times(n uint64) *mHistoryAndReturnsRepositoryMockHistory <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmHistory.mock.t.Fatalf("Times of HistoryAndReturnsRepositoryMock.History mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmHistory.expectedInvocations, n)
        mmHistory.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmHistory</span>
}

func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmHistory.expectations) == 0 &amp;&amp; mmHistory.defaultExpectation == nil &amp;&amp; mmHistory.mock.funcHistory == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmHistory.mock.afterHistoryCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmHistory.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// History implements mm_usecase.HistoryAndReturnsRepository
func (mmHistory *HistoryAndReturnsRepositoryMock) History(ctx context.Context, pg vo.Pagination) (hpa1 []*models.HistoryEvent, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmHistory.beforeHistoryCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmHistory.afterHistoryCounter, 1)

        mmHistory.t.Helper()

        if mmHistory.inspectFuncHistory != nil </span><span class="cov0" title="0">{
                mmHistory.inspectFuncHistory(ctx, pg)
        }</span>

        <span class="cov0" title="0">mm_params := HistoryAndReturnsRepositoryMockHistoryParams{ctx, pg}

        // Record call args
        mmHistory.HistoryMock.mutex.Lock()
        mmHistory.HistoryMock.callArgs = append(mmHistory.HistoryMock.callArgs, &amp;mm_params)
        mmHistory.HistoryMock.mutex.Unlock()

        for _, e := range mmHistory.HistoryMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.hpa1, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmHistory.HistoryMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmHistory.HistoryMock.defaultExpectation.Counter, 1)
                mm_want := mmHistory.HistoryMock.defaultExpectation.params
                mm_want_ptrs := mmHistory.HistoryMock.defaultExpectation.paramPtrs

                mm_got := HistoryAndReturnsRepositoryMockHistoryParams{ctx, pg}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmHistory.t.Errorf("HistoryAndReturnsRepositoryMock.History got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmHistory.HistoryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.pg != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.pg, mm_got.pg) </span><span class="cov0" title="0">{
                                mmHistory.t.Errorf("HistoryAndReturnsRepositoryMock.History got unexpected parameter pg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmHistory.HistoryMock.defaultExpectation.expectationOrigins.originPg, *mm_want_ptrs.pg, mm_got.pg, minimock.Diff(*mm_want_ptrs.pg, mm_got.pg))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmHistory.t.Errorf("HistoryAndReturnsRepositoryMock.History got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmHistory.HistoryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmHistory.HistoryMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmHistory.t.Fatal("No results are set for the HistoryAndReturnsRepositoryMock.History")
                }</span>
                <span class="cov0" title="0">return (*mm_results).hpa1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmHistory.funcHistory != nil </span><span class="cov0" title="0">{
                return mmHistory.funcHistory(ctx, pg)
        }</span>
        <span class="cov0" title="0">mmHistory.t.Fatalf("Unexpected call to HistoryAndReturnsRepositoryMock.History. %v %v", ctx, pg)
        return</span>
}

// HistoryAfterCounter returns a count of finished HistoryAndReturnsRepositoryMock.History invocations
func (mmHistory *HistoryAndReturnsRepositoryMock) HistoryAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmHistory.afterHistoryCounter)
}</span>

// HistoryBeforeCounter returns a count of HistoryAndReturnsRepositoryMock.History invocations
func (mmHistory *HistoryAndReturnsRepositoryMock) HistoryBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmHistory.beforeHistoryCounter)
}</span>

// Calls returns a list of arguments used in each call to HistoryAndReturnsRepositoryMock.History.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHistory *mHistoryAndReturnsRepositoryMockHistory) Calls() []*HistoryAndReturnsRepositoryMockHistoryParams <span class="cov0" title="0">{
        mmHistory.mutex.RLock()

        argCopy := make([]*HistoryAndReturnsRepositoryMockHistoryParams, len(mmHistory.callArgs))
        copy(argCopy, mmHistory.callArgs)

        mmHistory.mutex.RUnlock()

        return argCopy
}</span>

// MinimockHistoryDone returns true if the count of the History invocations corresponds
// the number of defined expectations
func (m *HistoryAndReturnsRepositoryMock) MinimockHistoryDone() bool <span class="cov0" title="0">{
        if m.HistoryMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.HistoryMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.HistoryMock.invocationsDone()</span>
}

// MinimockHistoryInspect logs each unmet expectation
func (m *HistoryAndReturnsRepositoryMock) MinimockHistoryInspect() <span class="cov0" title="0">{
        for _, e := range m.HistoryMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.History at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterHistoryCounter := mm_atomic.LoadUint64(&amp;m.afterHistoryCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.HistoryMock.defaultExpectation != nil &amp;&amp; afterHistoryCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.HistoryMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.History at\n%s", m.HistoryMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.History at\n%s with params: %#v", m.HistoryMock.defaultExpectation.expectationOrigins.origin, *m.HistoryMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcHistory != nil &amp;&amp; afterHistoryCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.History at\n%s", m.funcHistoryOrigin)
        }</span>

        <span class="cov0" title="0">if !m.HistoryMock.invocationsDone() &amp;&amp; afterHistoryCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to HistoryAndReturnsRepositoryMock.History at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.HistoryMock.expectedInvocations), m.HistoryMock.expectedInvocationsOrigin, afterHistoryCounter)
        }</span>
}

type mHistoryAndReturnsRepositoryMockListReturns struct {
        optional           bool
        mock               *HistoryAndReturnsRepositoryMock
        defaultExpectation *HistoryAndReturnsRepositoryMockListReturnsExpectation
        expectations       []*HistoryAndReturnsRepositoryMockListReturnsExpectation

        callArgs []*HistoryAndReturnsRepositoryMockListReturnsParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// HistoryAndReturnsRepositoryMockListReturnsExpectation specifies expectation struct of the HistoryAndReturnsRepository.ListReturns
type HistoryAndReturnsRepositoryMockListReturnsExpectation struct {
        mock               *HistoryAndReturnsRepositoryMock
        params             *HistoryAndReturnsRepositoryMockListReturnsParams
        paramPtrs          *HistoryAndReturnsRepositoryMockListReturnsParamPtrs
        expectationOrigins HistoryAndReturnsRepositoryMockListReturnsExpectationOrigins
        results            *HistoryAndReturnsRepositoryMockListReturnsResults
        returnOrigin       string
        Counter            uint64
}

// HistoryAndReturnsRepositoryMockListReturnsParams contains parameters of the HistoryAndReturnsRepository.ListReturns
type HistoryAndReturnsRepositoryMockListReturnsParams struct {
        ctx context.Context
        pg  vo.Pagination
}

// HistoryAndReturnsRepositoryMockListReturnsParamPtrs contains pointers to parameters of the HistoryAndReturnsRepository.ListReturns
type HistoryAndReturnsRepositoryMockListReturnsParamPtrs struct {
        ctx *context.Context
        pg  *vo.Pagination
}

// HistoryAndReturnsRepositoryMockListReturnsResults contains results of the HistoryAndReturnsRepository.ListReturns
type HistoryAndReturnsRepositoryMockListReturnsResults struct {
        rpa1 []*models.ReturnRecord
        err  error
}

// HistoryAndReturnsRepositoryMockListReturnsOrigins contains origins of expectations of the HistoryAndReturnsRepository.ListReturns
type HistoryAndReturnsRepositoryMockListReturnsExpectationOrigins struct {
        origin    string
        originCtx string
        originPg  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) Optional() *mHistoryAndReturnsRepositoryMockListReturns <span class="cov0" title="0">{
        mmListReturns.optional = true
        return mmListReturns
}</span>

// Expect sets up expected params for HistoryAndReturnsRepository.ListReturns
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) Expect(ctx context.Context, pg vo.Pagination) *mHistoryAndReturnsRepositoryMockListReturns <span class="cov0" title="0">{
        if mmListReturns.mock.funcListReturns != nil </span><span class="cov0" title="0">{
                mmListReturns.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturns mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListReturns.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListReturns.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockListReturnsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListReturns.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmListReturns.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturns mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmListReturns.defaultExpectation.params = &amp;HistoryAndReturnsRepositoryMockListReturnsParams{ctx, pg}
        mmListReturns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmListReturns.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmListReturns.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmListReturns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListReturns.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmListReturns</span>
}

// ExpectCtxParam1 sets up expected param ctx for HistoryAndReturnsRepository.ListReturns
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) ExpectCtxParam1(ctx context.Context) *mHistoryAndReturnsRepositoryMockListReturns <span class="cov0" title="0">{
        if mmListReturns.mock.funcListReturns != nil </span><span class="cov0" title="0">{
                mmListReturns.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturns mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListReturns.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListReturns.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockListReturnsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListReturns.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmListReturns.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturns mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmListReturns.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmListReturns.defaultExpectation.paramPtrs = &amp;HistoryAndReturnsRepositoryMockListReturnsParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmListReturns.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmListReturns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmListReturns</span>
}

// ExpectPgParam2 sets up expected param pg for HistoryAndReturnsRepository.ListReturns
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) ExpectPgParam2(pg vo.Pagination) *mHistoryAndReturnsRepositoryMockListReturns <span class="cov0" title="0">{
        if mmListReturns.mock.funcListReturns != nil </span><span class="cov0" title="0">{
                mmListReturns.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturns mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListReturns.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListReturns.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockListReturnsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListReturns.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmListReturns.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturns mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmListReturns.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmListReturns.defaultExpectation.paramPtrs = &amp;HistoryAndReturnsRepositoryMockListReturnsParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmListReturns.defaultExpectation.paramPtrs.pg = &amp;pg
        mmListReturns.defaultExpectation.expectationOrigins.originPg = minimock.CallerInfo(1)

        return mmListReturns</span>
}

// Inspect accepts an inspector function that has same arguments as the HistoryAndReturnsRepository.ListReturns
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) Inspect(f func(ctx context.Context, pg vo.Pagination)) *mHistoryAndReturnsRepositoryMockListReturns <span class="cov0" title="0">{
        if mmListReturns.mock.inspectFuncListReturns != nil </span><span class="cov0" title="0">{
                mmListReturns.mock.t.Fatalf("Inspect function is already set for HistoryAndReturnsRepositoryMock.ListReturns")
        }</span>

        <span class="cov0" title="0">mmListReturns.mock.inspectFuncListReturns = f

        return mmListReturns</span>
}

// Return sets up results that will be returned by HistoryAndReturnsRepository.ListReturns
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) Return(rpa1 []*models.ReturnRecord, err error) *HistoryAndReturnsRepositoryMock <span class="cov0" title="0">{
        if mmListReturns.mock.funcListReturns != nil </span><span class="cov0" title="0">{
                mmListReturns.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturns mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListReturns.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListReturns.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockListReturnsExpectation{mock: mmListReturns.mock}
        }</span>
        <span class="cov0" title="0">mmListReturns.defaultExpectation.results = &amp;HistoryAndReturnsRepositoryMockListReturnsResults{rpa1, err}
        mmListReturns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmListReturns.mock</span>
}

// Set uses given function f to mock the HistoryAndReturnsRepository.ListReturns method
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) Set(f func(ctx context.Context, pg vo.Pagination) (rpa1 []*models.ReturnRecord, err error)) *HistoryAndReturnsRepositoryMock <span class="cov0" title="0">{
        if mmListReturns.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmListReturns.mock.t.Fatalf("Default expectation is already set for the HistoryAndReturnsRepository.ListReturns method")
        }</span>

        <span class="cov0" title="0">if len(mmListReturns.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmListReturns.mock.t.Fatalf("Some expectations are already set for the HistoryAndReturnsRepository.ListReturns method")
        }</span>

        <span class="cov0" title="0">mmListReturns.mock.funcListReturns = f
        mmListReturns.mock.funcListReturnsOrigin = minimock.CallerInfo(1)
        return mmListReturns.mock</span>
}

// When sets expectation for the HistoryAndReturnsRepository.ListReturns which will trigger the result defined by the following
// Then helper
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) When(ctx context.Context, pg vo.Pagination) *HistoryAndReturnsRepositoryMockListReturnsExpectation <span class="cov0" title="0">{
        if mmListReturns.mock.funcListReturns != nil </span><span class="cov0" title="0">{
                mmListReturns.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturns mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;HistoryAndReturnsRepositoryMockListReturnsExpectation{
                mock:               mmListReturns.mock,
                params:             &amp;HistoryAndReturnsRepositoryMockListReturnsParams{ctx, pg},
                expectationOrigins: HistoryAndReturnsRepositoryMockListReturnsExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmListReturns.expectations = append(mmListReturns.expectations, expectation)
        return expectation</span>
}

// Then sets up HistoryAndReturnsRepository.ListReturns return parameters for the expectation previously defined by the When method
func (e *HistoryAndReturnsRepositoryMockListReturnsExpectation) Then(rpa1 []*models.ReturnRecord, err error) *HistoryAndReturnsRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;HistoryAndReturnsRepositoryMockListReturnsResults{rpa1, err}
        return e.mock
}</span>

// Times sets number of times HistoryAndReturnsRepository.ListReturns should be invoked
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) Times(n uint64) *mHistoryAndReturnsRepositoryMockListReturns <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmListReturns.mock.t.Fatalf("Times of HistoryAndReturnsRepositoryMock.ListReturns mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmListReturns.expectedInvocations, n)
        mmListReturns.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmListReturns</span>
}

func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmListReturns.expectations) == 0 &amp;&amp; mmListReturns.defaultExpectation == nil &amp;&amp; mmListReturns.mock.funcListReturns == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmListReturns.mock.afterListReturnsCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmListReturns.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// ListReturns implements mm_usecase.HistoryAndReturnsRepository
func (mmListReturns *HistoryAndReturnsRepositoryMock) ListReturns(ctx context.Context, pg vo.Pagination) (rpa1 []*models.ReturnRecord, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmListReturns.beforeListReturnsCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmListReturns.afterListReturnsCounter, 1)

        mmListReturns.t.Helper()

        if mmListReturns.inspectFuncListReturns != nil </span><span class="cov0" title="0">{
                mmListReturns.inspectFuncListReturns(ctx, pg)
        }</span>

        <span class="cov0" title="0">mm_params := HistoryAndReturnsRepositoryMockListReturnsParams{ctx, pg}

        // Record call args
        mmListReturns.ListReturnsMock.mutex.Lock()
        mmListReturns.ListReturnsMock.callArgs = append(mmListReturns.ListReturnsMock.callArgs, &amp;mm_params)
        mmListReturns.ListReturnsMock.mutex.Unlock()

        for _, e := range mmListReturns.ListReturnsMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.rpa1, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmListReturns.ListReturnsMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmListReturns.ListReturnsMock.defaultExpectation.Counter, 1)
                mm_want := mmListReturns.ListReturnsMock.defaultExpectation.params
                mm_want_ptrs := mmListReturns.ListReturnsMock.defaultExpectation.paramPtrs

                mm_got := HistoryAndReturnsRepositoryMockListReturnsParams{ctx, pg}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmListReturns.t.Errorf("HistoryAndReturnsRepositoryMock.ListReturns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmListReturns.ListReturnsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.pg != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.pg, mm_got.pg) </span><span class="cov0" title="0">{
                                mmListReturns.t.Errorf("HistoryAndReturnsRepositoryMock.ListReturns got unexpected parameter pg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmListReturns.ListReturnsMock.defaultExpectation.expectationOrigins.originPg, *mm_want_ptrs.pg, mm_got.pg, minimock.Diff(*mm_want_ptrs.pg, mm_got.pg))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmListReturns.t.Errorf("HistoryAndReturnsRepositoryMock.ListReturns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmListReturns.ListReturnsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmListReturns.ListReturnsMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmListReturns.t.Fatal("No results are set for the HistoryAndReturnsRepositoryMock.ListReturns")
                }</span>
                <span class="cov0" title="0">return (*mm_results).rpa1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmListReturns.funcListReturns != nil </span><span class="cov0" title="0">{
                return mmListReturns.funcListReturns(ctx, pg)
        }</span>
        <span class="cov0" title="0">mmListReturns.t.Fatalf("Unexpected call to HistoryAndReturnsRepositoryMock.ListReturns. %v %v", ctx, pg)
        return</span>
}

// ListReturnsAfterCounter returns a count of finished HistoryAndReturnsRepositoryMock.ListReturns invocations
func (mmListReturns *HistoryAndReturnsRepositoryMock) ListReturnsAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmListReturns.afterListReturnsCounter)
}</span>

// ListReturnsBeforeCounter returns a count of HistoryAndReturnsRepositoryMock.ListReturns invocations
func (mmListReturns *HistoryAndReturnsRepositoryMock) ListReturnsBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmListReturns.beforeListReturnsCounter)
}</span>

// Calls returns a list of arguments used in each call to HistoryAndReturnsRepositoryMock.ListReturns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListReturns *mHistoryAndReturnsRepositoryMockListReturns) Calls() []*HistoryAndReturnsRepositoryMockListReturnsParams <span class="cov0" title="0">{
        mmListReturns.mutex.RLock()

        argCopy := make([]*HistoryAndReturnsRepositoryMockListReturnsParams, len(mmListReturns.callArgs))
        copy(argCopy, mmListReturns.callArgs)

        mmListReturns.mutex.RUnlock()

        return argCopy
}</span>

// MinimockListReturnsDone returns true if the count of the ListReturns invocations corresponds
// the number of defined expectations
func (m *HistoryAndReturnsRepositoryMock) MinimockListReturnsDone() bool <span class="cov0" title="0">{
        if m.ListReturnsMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.ListReturnsMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.ListReturnsMock.invocationsDone()</span>
}

// MinimockListReturnsInspect logs each unmet expectation
func (m *HistoryAndReturnsRepositoryMock) MinimockListReturnsInspect() <span class="cov0" title="0">{
        for _, e := range m.ListReturnsMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.ListReturns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterListReturnsCounter := mm_atomic.LoadUint64(&amp;m.afterListReturnsCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ListReturnsMock.defaultExpectation != nil &amp;&amp; afterListReturnsCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.ListReturnsMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.ListReturns at\n%s", m.ListReturnsMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.ListReturns at\n%s with params: %#v", m.ListReturnsMock.defaultExpectation.expectationOrigins.origin, *m.ListReturnsMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcListReturns != nil &amp;&amp; afterListReturnsCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.ListReturns at\n%s", m.funcListReturnsOrigin)
        }</span>

        <span class="cov0" title="0">if !m.ListReturnsMock.invocationsDone() &amp;&amp; afterListReturnsCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to HistoryAndReturnsRepositoryMock.ListReturns at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ListReturnsMock.expectedInvocations), m.ListReturnsMock.expectedInvocationsOrigin, afterListReturnsCounter)
        }</span>
}

type mHistoryAndReturnsRepositoryMockListReturnsByUser struct {
        optional           bool
        mock               *HistoryAndReturnsRepositoryMock
        defaultExpectation *HistoryAndReturnsRepositoryMockListReturnsByUserExpectation
        expectations       []*HistoryAndReturnsRepositoryMockListReturnsByUserExpectation

        callArgs []*HistoryAndReturnsRepositoryMockListReturnsByUserParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// HistoryAndReturnsRepositoryMockListReturnsByUserExpectation specifies expectation struct of the HistoryAndReturnsRepository.ListReturnsByUser
type HistoryAndReturnsRepositoryMockListReturnsByUserExpectation struct {
        mock               *HistoryAndReturnsRepositoryMock
        params             *HistoryAndReturnsRepositoryMockListReturnsByUserParams
        paramPtrs          *HistoryAndReturnsRepositoryMockListReturnsByUserParamPtrs
        expectationOrigins HistoryAndReturnsRepositoryMockListReturnsByUserExpectationOrigins
        results            *HistoryAndReturnsRepositoryMockListReturnsByUserResults
        returnOrigin       string
        Counter            uint64
}

// HistoryAndReturnsRepositoryMockListReturnsByUserParams contains parameters of the HistoryAndReturnsRepository.ListReturnsByUser
type HistoryAndReturnsRepositoryMockListReturnsByUserParams struct {
        ctx    context.Context
        userID string
}

// HistoryAndReturnsRepositoryMockListReturnsByUserParamPtrs contains pointers to parameters of the HistoryAndReturnsRepository.ListReturnsByUser
type HistoryAndReturnsRepositoryMockListReturnsByUserParamPtrs struct {
        ctx    *context.Context
        userID *string
}

// HistoryAndReturnsRepositoryMockListReturnsByUserResults contains results of the HistoryAndReturnsRepository.ListReturnsByUser
type HistoryAndReturnsRepositoryMockListReturnsByUserResults struct {
        rpa1 []*models.ReturnRecord
        err  error
}

// HistoryAndReturnsRepositoryMockListReturnsByUserOrigins contains origins of expectations of the HistoryAndReturnsRepository.ListReturnsByUser
type HistoryAndReturnsRepositoryMockListReturnsByUserExpectationOrigins struct {
        origin       string
        originCtx    string
        originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) Optional() *mHistoryAndReturnsRepositoryMockListReturnsByUser <span class="cov0" title="0">{
        mmListReturnsByUser.optional = true
        return mmListReturnsByUser
}</span>

// Expect sets up expected params for HistoryAndReturnsRepository.ListReturnsByUser
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) Expect(ctx context.Context, userID string) *mHistoryAndReturnsRepositoryMockListReturnsByUser <span class="cov0" title="0">{
        if mmListReturnsByUser.mock.funcListReturnsByUser != nil </span><span class="cov0" title="0">{
                mmListReturnsByUser.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturnsByUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListReturnsByUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListReturnsByUser.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockListReturnsByUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListReturnsByUser.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmListReturnsByUser.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturnsByUser mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmListReturnsByUser.defaultExpectation.params = &amp;HistoryAndReturnsRepositoryMockListReturnsByUserParams{ctx, userID}
        mmListReturnsByUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmListReturnsByUser.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmListReturnsByUser.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmListReturnsByUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListReturnsByUser.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmListReturnsByUser</span>
}

// ExpectCtxParam1 sets up expected param ctx for HistoryAndReturnsRepository.ListReturnsByUser
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) ExpectCtxParam1(ctx context.Context) *mHistoryAndReturnsRepositoryMockListReturnsByUser <span class="cov0" title="0">{
        if mmListReturnsByUser.mock.funcListReturnsByUser != nil </span><span class="cov0" title="0">{
                mmListReturnsByUser.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturnsByUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListReturnsByUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListReturnsByUser.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockListReturnsByUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListReturnsByUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmListReturnsByUser.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturnsByUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmListReturnsByUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmListReturnsByUser.defaultExpectation.paramPtrs = &amp;HistoryAndReturnsRepositoryMockListReturnsByUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmListReturnsByUser.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmListReturnsByUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmListReturnsByUser</span>
}

// ExpectUserIDParam2 sets up expected param userID for HistoryAndReturnsRepository.ListReturnsByUser
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) ExpectUserIDParam2(userID string) *mHistoryAndReturnsRepositoryMockListReturnsByUser <span class="cov0" title="0">{
        if mmListReturnsByUser.mock.funcListReturnsByUser != nil </span><span class="cov0" title="0">{
                mmListReturnsByUser.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturnsByUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListReturnsByUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListReturnsByUser.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockListReturnsByUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListReturnsByUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmListReturnsByUser.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturnsByUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmListReturnsByUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmListReturnsByUser.defaultExpectation.paramPtrs = &amp;HistoryAndReturnsRepositoryMockListReturnsByUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmListReturnsByUser.defaultExpectation.paramPtrs.userID = &amp;userID
        mmListReturnsByUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

        return mmListReturnsByUser</span>
}

// Inspect accepts an inspector function that has same arguments as the HistoryAndReturnsRepository.ListReturnsByUser
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) Inspect(f func(ctx context.Context, userID string)) *mHistoryAndReturnsRepositoryMockListReturnsByUser <span class="cov0" title="0">{
        if mmListReturnsByUser.mock.inspectFuncListReturnsByUser != nil </span><span class="cov0" title="0">{
                mmListReturnsByUser.mock.t.Fatalf("Inspect function is already set for HistoryAndReturnsRepositoryMock.ListReturnsByUser")
        }</span>

        <span class="cov0" title="0">mmListReturnsByUser.mock.inspectFuncListReturnsByUser = f

        return mmListReturnsByUser</span>
}

// Return sets up results that will be returned by HistoryAndReturnsRepository.ListReturnsByUser
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) Return(rpa1 []*models.ReturnRecord, err error) *HistoryAndReturnsRepositoryMock <span class="cov0" title="0">{
        if mmListReturnsByUser.mock.funcListReturnsByUser != nil </span><span class="cov0" title="0">{
                mmListReturnsByUser.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturnsByUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListReturnsByUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListReturnsByUser.defaultExpectation = &amp;HistoryAndReturnsRepositoryMockListReturnsByUserExpectation{mock: mmListReturnsByUser.mock}
        }</span>
        <span class="cov0" title="0">mmListReturnsByUser.defaultExpectation.results = &amp;HistoryAndReturnsRepositoryMockListReturnsByUserResults{rpa1, err}
        mmListReturnsByUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmListReturnsByUser.mock</span>
}

// Set uses given function f to mock the HistoryAndReturnsRepository.ListReturnsByUser method
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) Set(f func(ctx context.Context, userID string) (rpa1 []*models.ReturnRecord, err error)) *HistoryAndReturnsRepositoryMock <span class="cov0" title="0">{
        if mmListReturnsByUser.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmListReturnsByUser.mock.t.Fatalf("Default expectation is already set for the HistoryAndReturnsRepository.ListReturnsByUser method")
        }</span>

        <span class="cov0" title="0">if len(mmListReturnsByUser.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmListReturnsByUser.mock.t.Fatalf("Some expectations are already set for the HistoryAndReturnsRepository.ListReturnsByUser method")
        }</span>

        <span class="cov0" title="0">mmListReturnsByUser.mock.funcListReturnsByUser = f
        mmListReturnsByUser.mock.funcListReturnsByUserOrigin = minimock.CallerInfo(1)
        return mmListReturnsByUser.mock</span>
}

// When sets expectation for the HistoryAndReturnsRepository.ListReturnsByUser which will trigger the result defined by the following
// Then helper
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) When(ctx context.Context, userID string) *HistoryAndReturnsRepositoryMockListReturnsByUserExpectation <span class="cov0" title="0">{
        if mmListReturnsByUser.mock.funcListReturnsByUser != nil </span><span class="cov0" title="0">{
                mmListReturnsByUser.mock.t.Fatalf("HistoryAndReturnsRepositoryMock.ListReturnsByUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;HistoryAndReturnsRepositoryMockListReturnsByUserExpectation{
                mock:               mmListReturnsByUser.mock,
                params:             &amp;HistoryAndReturnsRepositoryMockListReturnsByUserParams{ctx, userID},
                expectationOrigins: HistoryAndReturnsRepositoryMockListReturnsByUserExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmListReturnsByUser.expectations = append(mmListReturnsByUser.expectations, expectation)
        return expectation</span>
}

// Then sets up HistoryAndReturnsRepository.ListReturnsByUser return parameters for the expectation previously defined by the When method
func (e *HistoryAndReturnsRepositoryMockListReturnsByUserExpectation) Then(rpa1 []*models.ReturnRecord, err error) *HistoryAndReturnsRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;HistoryAndReturnsRepositoryMockListReturnsByUserResults{rpa1, err}
        return e.mock
}</span>

// Times sets number of times HistoryAndReturnsRepository.ListReturnsByUser should be invoked
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) Times(n uint64) *mHistoryAndReturnsRepositoryMockListReturnsByUser <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmListReturnsByUser.mock.t.Fatalf("Times of HistoryAndReturnsRepositoryMock.ListReturnsByUser mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmListReturnsByUser.expectedInvocations, n)
        mmListReturnsByUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmListReturnsByUser</span>
}

func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmListReturnsByUser.expectations) == 0 &amp;&amp; mmListReturnsByUser.defaultExpectation == nil &amp;&amp; mmListReturnsByUser.mock.funcListReturnsByUser == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmListReturnsByUser.mock.afterListReturnsByUserCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmListReturnsByUser.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// ListReturnsByUser implements mm_usecase.HistoryAndReturnsRepository
func (mmListReturnsByUser *HistoryAndReturnsRepositoryMock) ListReturnsByUser(ctx context.Context, userID string) (rpa1 []*models.ReturnRecord, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmListReturnsByUser.beforeListReturnsByUserCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmListReturnsByUser.afterListReturnsByUserCounter, 1)

        mmListReturnsByUser.t.Helper()

        if mmListReturnsByUser.inspectFuncListReturnsByUser != nil </span><span class="cov0" title="0">{
                mmListReturnsByUser.inspectFuncListReturnsByUser(ctx, userID)
        }</span>

        <span class="cov0" title="0">mm_params := HistoryAndReturnsRepositoryMockListReturnsByUserParams{ctx, userID}

        // Record call args
        mmListReturnsByUser.ListReturnsByUserMock.mutex.Lock()
        mmListReturnsByUser.ListReturnsByUserMock.callArgs = append(mmListReturnsByUser.ListReturnsByUserMock.callArgs, &amp;mm_params)
        mmListReturnsByUser.ListReturnsByUserMock.mutex.Unlock()

        for _, e := range mmListReturnsByUser.ListReturnsByUserMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.rpa1, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmListReturnsByUser.ListReturnsByUserMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmListReturnsByUser.ListReturnsByUserMock.defaultExpectation.Counter, 1)
                mm_want := mmListReturnsByUser.ListReturnsByUserMock.defaultExpectation.params
                mm_want_ptrs := mmListReturnsByUser.ListReturnsByUserMock.defaultExpectation.paramPtrs

                mm_got := HistoryAndReturnsRepositoryMockListReturnsByUserParams{ctx, userID}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmListReturnsByUser.t.Errorf("HistoryAndReturnsRepositoryMock.ListReturnsByUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmListReturnsByUser.ListReturnsByUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.userID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) </span><span class="cov0" title="0">{
                                mmListReturnsByUser.t.Errorf("HistoryAndReturnsRepositoryMock.ListReturnsByUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmListReturnsByUser.ListReturnsByUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmListReturnsByUser.t.Errorf("HistoryAndReturnsRepositoryMock.ListReturnsByUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmListReturnsByUser.ListReturnsByUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmListReturnsByUser.ListReturnsByUserMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmListReturnsByUser.t.Fatal("No results are set for the HistoryAndReturnsRepositoryMock.ListReturnsByUser")
                }</span>
                <span class="cov0" title="0">return (*mm_results).rpa1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmListReturnsByUser.funcListReturnsByUser != nil </span><span class="cov0" title="0">{
                return mmListReturnsByUser.funcListReturnsByUser(ctx, userID)
        }</span>
        <span class="cov0" title="0">mmListReturnsByUser.t.Fatalf("Unexpected call to HistoryAndReturnsRepositoryMock.ListReturnsByUser. %v %v", ctx, userID)
        return</span>
}

// ListReturnsByUserAfterCounter returns a count of finished HistoryAndReturnsRepositoryMock.ListReturnsByUser invocations
func (mmListReturnsByUser *HistoryAndReturnsRepositoryMock) ListReturnsByUserAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmListReturnsByUser.afterListReturnsByUserCounter)
}</span>

// ListReturnsByUserBeforeCounter returns a count of HistoryAndReturnsRepositoryMock.ListReturnsByUser invocations
func (mmListReturnsByUser *HistoryAndReturnsRepositoryMock) ListReturnsByUserBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmListReturnsByUser.beforeListReturnsByUserCounter)
}</span>

// Calls returns a list of arguments used in each call to HistoryAndReturnsRepositoryMock.ListReturnsByUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListReturnsByUser *mHistoryAndReturnsRepositoryMockListReturnsByUser) Calls() []*HistoryAndReturnsRepositoryMockListReturnsByUserParams <span class="cov0" title="0">{
        mmListReturnsByUser.mutex.RLock()

        argCopy := make([]*HistoryAndReturnsRepositoryMockListReturnsByUserParams, len(mmListReturnsByUser.callArgs))
        copy(argCopy, mmListReturnsByUser.callArgs)

        mmListReturnsByUser.mutex.RUnlock()

        return argCopy
}</span>

// MinimockListReturnsByUserDone returns true if the count of the ListReturnsByUser invocations corresponds
// the number of defined expectations
func (m *HistoryAndReturnsRepositoryMock) MinimockListReturnsByUserDone() bool <span class="cov0" title="0">{
        if m.ListReturnsByUserMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.ListReturnsByUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.ListReturnsByUserMock.invocationsDone()</span>
}

// MinimockListReturnsByUserInspect logs each unmet expectation
func (m *HistoryAndReturnsRepositoryMock) MinimockListReturnsByUserInspect() <span class="cov0" title="0">{
        for _, e := range m.ListReturnsByUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.ListReturnsByUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterListReturnsByUserCounter := mm_atomic.LoadUint64(&amp;m.afterListReturnsByUserCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ListReturnsByUserMock.defaultExpectation != nil &amp;&amp; afterListReturnsByUserCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.ListReturnsByUserMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.ListReturnsByUser at\n%s", m.ListReturnsByUserMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.ListReturnsByUser at\n%s with params: %#v", m.ListReturnsByUserMock.defaultExpectation.expectationOrigins.origin, *m.ListReturnsByUserMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcListReturnsByUser != nil &amp;&amp; afterListReturnsByUserCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to HistoryAndReturnsRepositoryMock.ListReturnsByUser at\n%s", m.funcListReturnsByUserOrigin)
        }</span>

        <span class="cov0" title="0">if !m.ListReturnsByUserMock.invocationsDone() &amp;&amp; afterListReturnsByUserCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to HistoryAndReturnsRepositoryMock.ListReturnsByUser at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ListReturnsByUserMock.expectedInvocations), m.ListReturnsByUserMock.expectedInvocationsOrigin, afterListReturnsByUserCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *HistoryAndReturnsRepositoryMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockAddHistoryInspect()

                        m.MinimockAddReturnInspect()

                        m.MinimockHistoryInspect()

                        m.MinimockListReturnsInspect()

                        m.MinimockListReturnsByUserInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *HistoryAndReturnsRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *HistoryAndReturnsRepositoryMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockAddHistoryDone() &amp;&amp;
                m.MinimockAddReturnDone() &amp;&amp;
                m.MinimockHistoryDone() &amp;&amp;
                m.MinimockListReturnsDone() &amp;&amp;
                m.MinimockListReturnsByUserDone()
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i pvz-cli/internal/usecase.OrdersRepository -o orders_repo_mock.go -n OrdersRepositoryMock -p mock

import (
        "context"
        "pvz-cli/internal/domain/models"
        "pvz-cli/internal/domain/vo"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
)

// OrdersRepositoryMock implements mm_usecase.OrdersRepository
type OrdersRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcCreate          func(ctx context.Context, o *models.Order) (err error)
        funcCreateOrigin    string
        inspectFuncCreate   func(ctx context.Context, o *models.Order)
        afterCreateCounter  uint64
        beforeCreateCounter uint64
        CreateMock          mOrdersRepositoryMockCreate

        funcDelete          func(ctx context.Context, id string) (err error)
        funcDeleteOrigin    string
        inspectFuncDelete   func(ctx context.Context, id string)
        afterDeleteCounter  uint64
        beforeDeleteCounter uint64
        DeleteMock          mOrdersRepositoryMockDelete

        funcGet          func(ctx context.Context, id string) (op1 *models.Order, err error)
        funcGetOrigin    string
        inspectFuncGet   func(ctx context.Context, id string)
        afterGetCounter  uint64
        beforeGetCounter uint64
        GetMock          mOrdersRepositoryMockGet

        funcImportMany          func(ctx context.Context, list []*models.Order) (err error)
        funcImportManyOrigin    string
        inspectFuncImportMany   func(ctx context.Context, list []*models.Order)
        afterImportManyCounter  uint64
        beforeImportManyCounter uint64
        ImportManyMock          mOrdersRepositoryMockImportMany

        funcListAllOrders          func(ctx context.Context) (opa1 []*models.Order, err error)
        funcListAllOrdersOrigin    string
        inspectFuncListAllOrders   func(ctx context.Context)
        afterListAllOrdersCounter  uint64
        beforeListAllOrdersCounter uint64
        ListAllOrdersMock          mOrdersRepositoryMockListAllOrders

        funcListByUser          func(ctx context.Context, userID string, onlyInPVZ bool, lastN int, pg *vo.Pagination) (opa1 []*models.Order, err error)
        funcListByUserOrigin    string
        inspectFuncListByUser   func(ctx context.Context, userID string, onlyInPVZ bool, lastN int, pg *vo.Pagination)
        afterListByUserCounter  uint64
        beforeListByUserCounter uint64
        ListByUserMock          mOrdersRepositoryMockListByUser

        funcUpdate          func(ctx context.Context, o *models.Order) (err error)
        funcUpdateOrigin    string
        inspectFuncUpdate   func(ctx context.Context, o *models.Order)
        afterUpdateCounter  uint64
        beforeUpdateCounter uint64
        UpdateMock          mOrdersRepositoryMockUpdate
}

// NewOrdersRepositoryMock returns a mock for mm_usecase.OrdersRepository
func NewOrdersRepositoryMock(t minimock.Tester) *OrdersRepositoryMock <span class="cov0" title="0">{
        m := &amp;OrdersRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.CreateMock = mOrdersRepositoryMockCreate{mock: m}
        m.CreateMock.callArgs = []*OrdersRepositoryMockCreateParams{}

        m.DeleteMock = mOrdersRepositoryMockDelete{mock: m}
        m.DeleteMock.callArgs = []*OrdersRepositoryMockDeleteParams{}

        m.GetMock = mOrdersRepositoryMockGet{mock: m}
        m.GetMock.callArgs = []*OrdersRepositoryMockGetParams{}

        m.ImportManyMock = mOrdersRepositoryMockImportMany{mock: m}
        m.ImportManyMock.callArgs = []*OrdersRepositoryMockImportManyParams{}

        m.ListAllOrdersMock = mOrdersRepositoryMockListAllOrders{mock: m}
        m.ListAllOrdersMock.callArgs = []*OrdersRepositoryMockListAllOrdersParams{}

        m.ListByUserMock = mOrdersRepositoryMockListByUser{mock: m}
        m.ListByUserMock.callArgs = []*OrdersRepositoryMockListByUserParams{}

        m.UpdateMock = mOrdersRepositoryMockUpdate{mock: m}
        m.UpdateMock.callArgs = []*OrdersRepositoryMockUpdateParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mOrdersRepositoryMockCreate struct {
        optional           bool
        mock               *OrdersRepositoryMock
        defaultExpectation *OrdersRepositoryMockCreateExpectation
        expectations       []*OrdersRepositoryMockCreateExpectation

        callArgs []*OrdersRepositoryMockCreateParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrdersRepositoryMockCreateExpectation specifies expectation struct of the OrdersRepository.Create
type OrdersRepositoryMockCreateExpectation struct {
        mock               *OrdersRepositoryMock
        params             *OrdersRepositoryMockCreateParams
        paramPtrs          *OrdersRepositoryMockCreateParamPtrs
        expectationOrigins OrdersRepositoryMockCreateExpectationOrigins
        results            *OrdersRepositoryMockCreateResults
        returnOrigin       string
        Counter            uint64
}

// OrdersRepositoryMockCreateParams contains parameters of the OrdersRepository.Create
type OrdersRepositoryMockCreateParams struct {
        ctx context.Context
        o   *models.Order
}

// OrdersRepositoryMockCreateParamPtrs contains pointers to parameters of the OrdersRepository.Create
type OrdersRepositoryMockCreateParamPtrs struct {
        ctx *context.Context
        o   **models.Order
}

// OrdersRepositoryMockCreateResults contains results of the OrdersRepository.Create
type OrdersRepositoryMockCreateResults struct {
        err error
}

// OrdersRepositoryMockCreateOrigins contains origins of expectations of the OrdersRepository.Create
type OrdersRepositoryMockCreateExpectationOrigins struct {
        origin    string
        originCtx string
        originO   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mOrdersRepositoryMockCreate) Optional() *mOrdersRepositoryMockCreate <span class="cov0" title="0">{
        mmCreate.optional = true
        return mmCreate
}</span>

// Expect sets up expected params for OrdersRepository.Create
func (mmCreate *mOrdersRepositoryMockCreate) Expect(ctx context.Context, o *models.Order) *mOrdersRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;OrdersRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmCreate.defaultExpectation.params = &amp;OrdersRepositoryMockCreateParams{ctx, o}
        mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmCreate.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmCreate.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmCreate</span>
}

// ExpectCtxParam1 sets up expected param ctx for OrdersRepository.Create
func (mmCreate *mOrdersRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mOrdersRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;OrdersRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation.paramPtrs = &amp;OrdersRepositoryMockCreateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmCreate</span>
}

// ExpectOParam2 sets up expected param o for OrdersRepository.Create
func (mmCreate *mOrdersRepositoryMockCreate) ExpectOParam2(o *models.Order) *mOrdersRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;OrdersRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation.paramPtrs = &amp;OrdersRepositoryMockCreateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.paramPtrs.o = &amp;o
        mmCreate.defaultExpectation.expectationOrigins.originO = minimock.CallerInfo(1)

        return mmCreate</span>
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.Create
func (mmCreate *mOrdersRepositoryMockCreate) Inspect(f func(ctx context.Context, o *models.Order)) *mOrdersRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.inspectFuncCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.Create")
        }</span>

        <span class="cov0" title="0">mmCreate.mock.inspectFuncCreate = f

        return mmCreate</span>
}

// Return sets up results that will be returned by OrdersRepository.Create
func (mmCreate *mOrdersRepositoryMockCreate) Return(err error) *OrdersRepositoryMock <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;OrdersRepositoryMockCreateExpectation{mock: mmCreate.mock}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.results = &amp;OrdersRepositoryMockCreateResults{err}
        mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmCreate.mock</span>
}

// Set uses given function f to mock the OrdersRepository.Create method
func (mmCreate *mOrdersRepositoryMockCreate) Set(f func(ctx context.Context, o *models.Order) (err error)) *OrdersRepositoryMock <span class="cov0" title="0">{
        if mmCreate.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.Create method")
        }</span>

        <span class="cov0" title="0">if len(mmCreate.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.Create method")
        }</span>

        <span class="cov0" title="0">mmCreate.mock.funcCreate = f
        mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
        return mmCreate.mock</span>
}

// When sets expectation for the OrdersRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mOrdersRepositoryMockCreate) When(ctx context.Context, o *models.Order) *OrdersRepositoryMockCreateExpectation <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrdersRepositoryMockCreateExpectation{
                mock:               mmCreate.mock,
                params:             &amp;OrdersRepositoryMockCreateParams{ctx, o},
                expectationOrigins: OrdersRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmCreate.expectations = append(mmCreate.expectations, expectation)
        return expectation</span>
}

// Then sets up OrdersRepository.Create return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockCreateExpectation) Then(err error) *OrdersRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;OrdersRepositoryMockCreateResults{err}
        return e.mock
}</span>

// Times sets number of times OrdersRepository.Create should be invoked
func (mmCreate *mOrdersRepositoryMockCreate) Times(n uint64) *mOrdersRepositoryMockCreate <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Times of OrdersRepositoryMock.Create mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCreate.expectedInvocations, n)
        mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmCreate</span>
}

func (mmCreate *mOrdersRepositoryMockCreate) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmCreate.expectations) == 0 &amp;&amp; mmCreate.defaultExpectation == nil &amp;&amp; mmCreate.mock.funcCreate == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmCreate.mock.afterCreateCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCreate.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Create implements mm_usecase.OrdersRepository
func (mmCreate *OrdersRepositoryMock) Create(ctx context.Context, o *models.Order) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmCreate.beforeCreateCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCreate.afterCreateCounter, 1)

        mmCreate.t.Helper()

        if mmCreate.inspectFuncCreate != nil </span><span class="cov0" title="0">{
                mmCreate.inspectFuncCreate(ctx, o)
        }</span>

        <span class="cov0" title="0">mm_params := OrdersRepositoryMockCreateParams{ctx, o}

        // Record call args
        mmCreate.CreateMock.mutex.Lock()
        mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &amp;mm_params)
        mmCreate.CreateMock.mutex.Unlock()

        for _, e := range mmCreate.CreateMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmCreate.CreateMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmCreate.CreateMock.defaultExpectation.Counter, 1)
                mm_want := mmCreate.CreateMock.defaultExpectation.params
                mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

                mm_got := OrdersRepositoryMockCreateParams{ctx, o}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmCreate.t.Errorf("OrdersRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.o != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.o, mm_got.o) </span><span class="cov0" title="0">{
                                mmCreate.t.Errorf("OrdersRepositoryMock.Create got unexpected parameter o, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreate.CreateMock.defaultExpectation.expectationOrigins.originO, *mm_want_ptrs.o, mm_got.o, minimock.Diff(*mm_want_ptrs.o, mm_got.o))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmCreate.t.Errorf("OrdersRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmCreate.CreateMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCreate.t.Fatal("No results are set for the OrdersRepositoryMock.Create")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmCreate.funcCreate != nil </span><span class="cov0" title="0">{
                return mmCreate.funcCreate(ctx, o)
        }</span>
        <span class="cov0" title="0">mmCreate.t.Fatalf("Unexpected call to OrdersRepositoryMock.Create. %v %v", ctx, o)
        return</span>
}

// CreateAfterCounter returns a count of finished OrdersRepositoryMock.Create invocations
func (mmCreate *OrdersRepositoryMock) CreateAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreate.afterCreateCounter)
}</span>

// CreateBeforeCounter returns a count of OrdersRepositoryMock.Create invocations
func (mmCreate *OrdersRepositoryMock) CreateBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreate.beforeCreateCounter)
}</span>

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mOrdersRepositoryMockCreate) Calls() []*OrdersRepositoryMockCreateParams <span class="cov0" title="0">{
        mmCreate.mutex.RLock()

        argCopy := make([]*OrdersRepositoryMockCreateParams, len(mmCreate.callArgs))
        copy(argCopy, mmCreate.callArgs)

        mmCreate.mutex.RUnlock()

        return argCopy
}</span>

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockCreateDone() bool <span class="cov0" title="0">{
        if m.CreateMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.CreateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.CreateMock.invocationsDone()</span>
}

// MinimockCreateInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockCreateInspect() <span class="cov0" title="0">{
        for _, e := range m.CreateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrdersRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterCreateCounter := mm_atomic.LoadUint64(&amp;m.afterCreateCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CreateMock.defaultExpectation != nil &amp;&amp; afterCreateCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.CreateMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrdersRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrdersRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCreate != nil &amp;&amp; afterCreateCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrdersRepositoryMock.Create at\n%s", m.funcCreateOrigin)
        }</span>

        <span class="cov0" title="0">if !m.CreateMock.invocationsDone() &amp;&amp; afterCreateCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrdersRepositoryMock.Create at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
        }</span>
}

type mOrdersRepositoryMockDelete struct {
        optional           bool
        mock               *OrdersRepositoryMock
        defaultExpectation *OrdersRepositoryMockDeleteExpectation
        expectations       []*OrdersRepositoryMockDeleteExpectation

        callArgs []*OrdersRepositoryMockDeleteParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrdersRepositoryMockDeleteExpectation specifies expectation struct of the OrdersRepository.Delete
type OrdersRepositoryMockDeleteExpectation struct {
        mock               *OrdersRepositoryMock
        params             *OrdersRepositoryMockDeleteParams
        paramPtrs          *OrdersRepositoryMockDeleteParamPtrs
        expectationOrigins OrdersRepositoryMockDeleteExpectationOrigins
        results            *OrdersRepositoryMockDeleteResults
        returnOrigin       string
        Counter            uint64
}

// OrdersRepositoryMockDeleteParams contains parameters of the OrdersRepository.Delete
type OrdersRepositoryMockDeleteParams struct {
        ctx context.Context
        id  string
}

// OrdersRepositoryMockDeleteParamPtrs contains pointers to parameters of the OrdersRepository.Delete
type OrdersRepositoryMockDeleteParamPtrs struct {
        ctx *context.Context
        id  *string
}

// OrdersRepositoryMockDeleteResults contains results of the OrdersRepository.Delete
type OrdersRepositoryMockDeleteResults struct {
        err error
}

// OrdersRepositoryMockDeleteOrigins contains origins of expectations of the OrdersRepository.Delete
type OrdersRepositoryMockDeleteExpectationOrigins struct {
        origin    string
        originCtx string
        originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mOrdersRepositoryMockDelete) Optional() *mOrdersRepositoryMockDelete <span class="cov0" title="0">{
        mmDelete.optional = true
        return mmDelete
}</span>

// Expect sets up expected params for OrdersRepository.Delete
func (mmDelete *mOrdersRepositoryMockDelete) Expect(ctx context.Context, id string) *mOrdersRepositoryMockDelete <span class="cov0" title="0">{
        if mmDelete.mock.funcDelete != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("OrdersRepositoryMock.Delete mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDelete.defaultExpectation = &amp;OrdersRepositoryMockDeleteExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("OrdersRepositoryMock.Delete mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmDelete.defaultExpectation.params = &amp;OrdersRepositoryMockDeleteParams{ctx, id}
        mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmDelete.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmDelete.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmDelete</span>
}

// ExpectCtxParam1 sets up expected param ctx for OrdersRepository.Delete
func (mmDelete *mOrdersRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mOrdersRepositoryMockDelete <span class="cov0" title="0">{
        if mmDelete.mock.funcDelete != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("OrdersRepositoryMock.Delete mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDelete.defaultExpectation = &amp;OrdersRepositoryMockDeleteExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("OrdersRepositoryMock.Delete mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDelete.defaultExpectation.paramPtrs = &amp;OrdersRepositoryMockDeleteParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDelete.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmDelete</span>
}

// ExpectIdParam2 sets up expected param id for OrdersRepository.Delete
func (mmDelete *mOrdersRepositoryMockDelete) ExpectIdParam2(id string) *mOrdersRepositoryMockDelete <span class="cov0" title="0">{
        if mmDelete.mock.funcDelete != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("OrdersRepositoryMock.Delete mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDelete.defaultExpectation = &amp;OrdersRepositoryMockDeleteExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("OrdersRepositoryMock.Delete mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDelete.defaultExpectation.paramPtrs = &amp;OrdersRepositoryMockDeleteParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDelete.defaultExpectation.paramPtrs.id = &amp;id
        mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmDelete</span>
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.Delete
func (mmDelete *mOrdersRepositoryMockDelete) Inspect(f func(ctx context.Context, id string)) *mOrdersRepositoryMockDelete <span class="cov0" title="0">{
        if mmDelete.mock.inspectFuncDelete != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.Delete")
        }</span>

        <span class="cov0" title="0">mmDelete.mock.inspectFuncDelete = f

        return mmDelete</span>
}

// Return sets up results that will be returned by OrdersRepository.Delete
func (mmDelete *mOrdersRepositoryMockDelete) Return(err error) *OrdersRepositoryMock <span class="cov0" title="0">{
        if mmDelete.mock.funcDelete != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("OrdersRepositoryMock.Delete mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDelete.defaultExpectation = &amp;OrdersRepositoryMockDeleteExpectation{mock: mmDelete.mock}
        }</span>
        <span class="cov0" title="0">mmDelete.defaultExpectation.results = &amp;OrdersRepositoryMockDeleteResults{err}
        mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmDelete.mock</span>
}

// Set uses given function f to mock the OrdersRepository.Delete method
func (mmDelete *mOrdersRepositoryMockDelete) Set(f func(ctx context.Context, id string) (err error)) *OrdersRepositoryMock <span class="cov0" title="0">{
        if mmDelete.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.Delete method")
        }</span>

        <span class="cov0" title="0">if len(mmDelete.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.Delete method")
        }</span>

        <span class="cov0" title="0">mmDelete.mock.funcDelete = f
        mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
        return mmDelete.mock</span>
}

// When sets expectation for the OrdersRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mOrdersRepositoryMockDelete) When(ctx context.Context, id string) *OrdersRepositoryMockDeleteExpectation <span class="cov0" title="0">{
        if mmDelete.mock.funcDelete != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("OrdersRepositoryMock.Delete mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrdersRepositoryMockDeleteExpectation{
                mock:               mmDelete.mock,
                params:             &amp;OrdersRepositoryMockDeleteParams{ctx, id},
                expectationOrigins: OrdersRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmDelete.expectations = append(mmDelete.expectations, expectation)
        return expectation</span>
}

// Then sets up OrdersRepository.Delete return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockDeleteExpectation) Then(err error) *OrdersRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;OrdersRepositoryMockDeleteResults{err}
        return e.mock
}</span>

// Times sets number of times OrdersRepository.Delete should be invoked
func (mmDelete *mOrdersRepositoryMockDelete) Times(n uint64) *mOrdersRepositoryMockDelete <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("Times of OrdersRepositoryMock.Delete mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmDelete.expectedInvocations, n)
        mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmDelete</span>
}

func (mmDelete *mOrdersRepositoryMockDelete) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmDelete.expectations) == 0 &amp;&amp; mmDelete.defaultExpectation == nil &amp;&amp; mmDelete.mock.funcDelete == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmDelete.mock.afterDeleteCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmDelete.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Delete implements mm_usecase.OrdersRepository
func (mmDelete *OrdersRepositoryMock) Delete(ctx context.Context, id string) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmDelete.beforeDeleteCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmDelete.afterDeleteCounter, 1)

        mmDelete.t.Helper()

        if mmDelete.inspectFuncDelete != nil </span><span class="cov0" title="0">{
                mmDelete.inspectFuncDelete(ctx, id)
        }</span>

        <span class="cov0" title="0">mm_params := OrdersRepositoryMockDeleteParams{ctx, id}

        // Record call args
        mmDelete.DeleteMock.mutex.Lock()
        mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &amp;mm_params)
        mmDelete.DeleteMock.mutex.Unlock()

        for _, e := range mmDelete.DeleteMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmDelete.DeleteMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmDelete.DeleteMock.defaultExpectation.Counter, 1)
                mm_want := mmDelete.DeleteMock.defaultExpectation.params
                mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

                mm_got := OrdersRepositoryMockDeleteParams{ctx, id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmDelete.t.Errorf("OrdersRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmDelete.t.Errorf("OrdersRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmDelete.t.Errorf("OrdersRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmDelete.DeleteMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmDelete.t.Fatal("No results are set for the OrdersRepositoryMock.Delete")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmDelete.funcDelete != nil </span><span class="cov0" title="0">{
                return mmDelete.funcDelete(ctx, id)
        }</span>
        <span class="cov0" title="0">mmDelete.t.Fatalf("Unexpected call to OrdersRepositoryMock.Delete. %v %v", ctx, id)
        return</span>
}

// DeleteAfterCounter returns a count of finished OrdersRepositoryMock.Delete invocations
func (mmDelete *OrdersRepositoryMock) DeleteAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDelete.afterDeleteCounter)
}</span>

// DeleteBeforeCounter returns a count of OrdersRepositoryMock.Delete invocations
func (mmDelete *OrdersRepositoryMock) DeleteBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDelete.beforeDeleteCounter)
}</span>

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mOrdersRepositoryMockDelete) Calls() []*OrdersRepositoryMockDeleteParams <span class="cov0" title="0">{
        mmDelete.mutex.RLock()

        argCopy := make([]*OrdersRepositoryMockDeleteParams, len(mmDelete.callArgs))
        copy(argCopy, mmDelete.callArgs)

        mmDelete.mutex.RUnlock()

        return argCopy
}</span>

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockDeleteDone() bool <span class="cov0" title="0">{
        if m.DeleteMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.DeleteMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.DeleteMock.invocationsDone()</span>
}

// MinimockDeleteInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockDeleteInspect() <span class="cov0" title="0">{
        for _, e := range m.DeleteMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrdersRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterDeleteCounter := mm_atomic.LoadUint64(&amp;m.afterDeleteCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.DeleteMock.defaultExpectation != nil &amp;&amp; afterDeleteCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.DeleteMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrdersRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrdersRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcDelete != nil &amp;&amp; afterDeleteCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrdersRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
        }</span>

        <span class="cov0" title="0">if !m.DeleteMock.invocationsDone() &amp;&amp; afterDeleteCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrdersRepositoryMock.Delete at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
        }</span>
}

type mOrdersRepositoryMockGet struct {
        optional           bool
        mock               *OrdersRepositoryMock
        defaultExpectation *OrdersRepositoryMockGetExpectation
        expectations       []*OrdersRepositoryMockGetExpectation

        callArgs []*OrdersRepositoryMockGetParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrdersRepositoryMockGetExpectation specifies expectation struct of the OrdersRepository.Get
type OrdersRepositoryMockGetExpectation struct {
        mock               *OrdersRepositoryMock
        params             *OrdersRepositoryMockGetParams
        paramPtrs          *OrdersRepositoryMockGetParamPtrs
        expectationOrigins OrdersRepositoryMockGetExpectationOrigins
        results            *OrdersRepositoryMockGetResults
        returnOrigin       string
        Counter            uint64
}

// OrdersRepositoryMockGetParams contains parameters of the OrdersRepository.Get
type OrdersRepositoryMockGetParams struct {
        ctx context.Context
        id  string
}

// OrdersRepositoryMockGetParamPtrs contains pointers to parameters of the OrdersRepository.Get
type OrdersRepositoryMockGetParamPtrs struct {
        ctx *context.Context
        id  *string
}

// OrdersRepositoryMockGetResults contains results of the OrdersRepository.Get
type OrdersRepositoryMockGetResults struct {
        op1 *models.Order
        err error
}

// OrdersRepositoryMockGetOrigins contains origins of expectations of the OrdersRepository.Get
type OrdersRepositoryMockGetExpectationOrigins struct {
        origin    string
        originCtx string
        originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mOrdersRepositoryMockGet) Optional() *mOrdersRepositoryMockGet <span class="cov0" title="0">{
        mmGet.optional = true
        return mmGet
}</span>

// Expect sets up expected params for OrdersRepository.Get
func (mmGet *mOrdersRepositoryMockGet) Expect(ctx context.Context, id string) *mOrdersRepositoryMockGet <span class="cov0" title="0">{
        if mmGet.mock.funcGet != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("OrdersRepositoryMock.Get mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGet.defaultExpectation = &amp;OrdersRepositoryMockGetExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("OrdersRepositoryMock.Get mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGet.defaultExpectation.params = &amp;OrdersRepositoryMockGetParams{ctx, id}
        mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGet.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGet.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGet</span>
}

// ExpectCtxParam1 sets up expected param ctx for OrdersRepository.Get
func (mmGet *mOrdersRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mOrdersRepositoryMockGet <span class="cov0" title="0">{
        if mmGet.mock.funcGet != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("OrdersRepositoryMock.Get mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGet.defaultExpectation = &amp;OrdersRepositoryMockGetExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("OrdersRepositoryMock.Get mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGet.defaultExpectation.paramPtrs = &amp;OrdersRepositoryMockGetParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGet.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmGet</span>
}

// ExpectIdParam2 sets up expected param id for OrdersRepository.Get
func (mmGet *mOrdersRepositoryMockGet) ExpectIdParam2(id string) *mOrdersRepositoryMockGet <span class="cov0" title="0">{
        if mmGet.mock.funcGet != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("OrdersRepositoryMock.Get mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGet.defaultExpectation = &amp;OrdersRepositoryMockGetExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("OrdersRepositoryMock.Get mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGet.defaultExpectation.paramPtrs = &amp;OrdersRepositoryMockGetParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGet.defaultExpectation.paramPtrs.id = &amp;id
        mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmGet</span>
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.Get
func (mmGet *mOrdersRepositoryMockGet) Inspect(f func(ctx context.Context, id string)) *mOrdersRepositoryMockGet <span class="cov0" title="0">{
        if mmGet.mock.inspectFuncGet != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.Get")
        }</span>

        <span class="cov0" title="0">mmGet.mock.inspectFuncGet = f

        return mmGet</span>
}

// Return sets up results that will be returned by OrdersRepository.Get
func (mmGet *mOrdersRepositoryMockGet) Return(op1 *models.Order, err error) *OrdersRepositoryMock <span class="cov0" title="0">{
        if mmGet.mock.funcGet != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("OrdersRepositoryMock.Get mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGet.defaultExpectation = &amp;OrdersRepositoryMockGetExpectation{mock: mmGet.mock}
        }</span>
        <span class="cov0" title="0">mmGet.defaultExpectation.results = &amp;OrdersRepositoryMockGetResults{op1, err}
        mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGet.mock</span>
}

// Set uses given function f to mock the OrdersRepository.Get method
func (mmGet *mOrdersRepositoryMockGet) Set(f func(ctx context.Context, id string) (op1 *models.Order, err error)) *OrdersRepositoryMock <span class="cov0" title="0">{
        if mmGet.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.Get method")
        }</span>

        <span class="cov0" title="0">if len(mmGet.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.Get method")
        }</span>

        <span class="cov0" title="0">mmGet.mock.funcGet = f
        mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
        return mmGet.mock</span>
}

// When sets expectation for the OrdersRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mOrdersRepositoryMockGet) When(ctx context.Context, id string) *OrdersRepositoryMockGetExpectation <span class="cov0" title="0">{
        if mmGet.mock.funcGet != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("OrdersRepositoryMock.Get mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrdersRepositoryMockGetExpectation{
                mock:               mmGet.mock,
                params:             &amp;OrdersRepositoryMockGetParams{ctx, id},
                expectationOrigins: OrdersRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGet.expectations = append(mmGet.expectations, expectation)
        return expectation</span>
}

// Then sets up OrdersRepository.Get return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockGetExpectation) Then(op1 *models.Order, err error) *OrdersRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;OrdersRepositoryMockGetResults{op1, err}
        return e.mock
}</span>

// Times sets number of times OrdersRepository.Get should be invoked
func (mmGet *mOrdersRepositoryMockGet) Times(n uint64) *mOrdersRepositoryMockGet <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("Times of OrdersRepositoryMock.Get mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGet.expectedInvocations, n)
        mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGet</span>
}

func (mmGet *mOrdersRepositoryMockGet) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmGet.expectations) == 0 &amp;&amp; mmGet.defaultExpectation == nil &amp;&amp; mmGet.mock.funcGet == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmGet.mock.afterGetCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGet.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Get implements mm_usecase.OrdersRepository
func (mmGet *OrdersRepositoryMock) Get(ctx context.Context, id string) (op1 *models.Order, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmGet.beforeGetCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGet.afterGetCounter, 1)

        mmGet.t.Helper()

        if mmGet.inspectFuncGet != nil </span><span class="cov0" title="0">{
                mmGet.inspectFuncGet(ctx, id)
        }</span>

        <span class="cov0" title="0">mm_params := OrdersRepositoryMockGetParams{ctx, id}

        // Record call args
        mmGet.GetMock.mutex.Lock()
        mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &amp;mm_params)
        mmGet.GetMock.mutex.Unlock()

        for _, e := range mmGet.GetMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.op1, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmGet.GetMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmGet.GetMock.defaultExpectation.Counter, 1)
                mm_want := mmGet.GetMock.defaultExpectation.params
                mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

                mm_got := OrdersRepositoryMockGetParams{ctx, id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGet.t.Errorf("OrdersRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmGet.t.Errorf("OrdersRepositoryMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGet.t.Errorf("OrdersRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmGet.GetMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGet.t.Fatal("No results are set for the OrdersRepositoryMock.Get")
                }</span>
                <span class="cov0" title="0">return (*mm_results).op1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmGet.funcGet != nil </span><span class="cov0" title="0">{
                return mmGet.funcGet(ctx, id)
        }</span>
        <span class="cov0" title="0">mmGet.t.Fatalf("Unexpected call to OrdersRepositoryMock.Get. %v %v", ctx, id)
        return</span>
}

// GetAfterCounter returns a count of finished OrdersRepositoryMock.Get invocations
func (mmGet *OrdersRepositoryMock) GetAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGet.afterGetCounter)
}</span>

// GetBeforeCounter returns a count of OrdersRepositoryMock.Get invocations
func (mmGet *OrdersRepositoryMock) GetBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGet.beforeGetCounter)
}</span>

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mOrdersRepositoryMockGet) Calls() []*OrdersRepositoryMockGetParams <span class="cov0" title="0">{
        mmGet.mutex.RLock()

        argCopy := make([]*OrdersRepositoryMockGetParams, len(mmGet.callArgs))
        copy(argCopy, mmGet.callArgs)

        mmGet.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockGetDone() bool <span class="cov0" title="0">{
        if m.GetMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.GetMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.GetMock.invocationsDone()</span>
}

// MinimockGetInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockGetInspect() <span class="cov0" title="0">{
        for _, e := range m.GetMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrdersRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetCounter := mm_atomic.LoadUint64(&amp;m.afterGetCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetMock.defaultExpectation != nil &amp;&amp; afterGetCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrdersRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrdersRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGet != nil &amp;&amp; afterGetCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrdersRepositoryMock.Get at\n%s", m.funcGetOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetMock.invocationsDone() &amp;&amp; afterGetCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrdersRepositoryMock.Get at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
        }</span>
}

type mOrdersRepositoryMockImportMany struct {
        optional           bool
        mock               *OrdersRepositoryMock
        defaultExpectation *OrdersRepositoryMockImportManyExpectation
        expectations       []*OrdersRepositoryMockImportManyExpectation

        callArgs []*OrdersRepositoryMockImportManyParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrdersRepositoryMockImportManyExpectation specifies expectation struct of the OrdersRepository.ImportMany
type OrdersRepositoryMockImportManyExpectation struct {
        mock               *OrdersRepositoryMock
        params             *OrdersRepositoryMockImportManyParams
        paramPtrs          *OrdersRepositoryMockImportManyParamPtrs
        expectationOrigins OrdersRepositoryMockImportManyExpectationOrigins
        results            *OrdersRepositoryMockImportManyResults
        returnOrigin       string
        Counter            uint64
}

// OrdersRepositoryMockImportManyParams contains parameters of the OrdersRepository.ImportMany
type OrdersRepositoryMockImportManyParams struct {
        ctx  context.Context
        list []*models.Order
}

// OrdersRepositoryMockImportManyParamPtrs contains pointers to parameters of the OrdersRepository.ImportMany
type OrdersRepositoryMockImportManyParamPtrs struct {
        ctx  *context.Context
        list *[]*models.Order
}

// OrdersRepositoryMockImportManyResults contains results of the OrdersRepository.ImportMany
type OrdersRepositoryMockImportManyResults struct {
        err error
}

// OrdersRepositoryMockImportManyOrigins contains origins of expectations of the OrdersRepository.ImportMany
type OrdersRepositoryMockImportManyExpectationOrigins struct {
        origin     string
        originCtx  string
        originList string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmImportMany *mOrdersRepositoryMockImportMany) Optional() *mOrdersRepositoryMockImportMany <span class="cov0" title="0">{
        mmImportMany.optional = true
        return mmImportMany
}</span>

// Expect sets up expected params for OrdersRepository.ImportMany
func (mmImportMany *mOrdersRepositoryMockImportMany) Expect(ctx context.Context, list []*models.Order) *mOrdersRepositoryMockImportMany <span class="cov0" title="0">{
        if mmImportMany.mock.funcImportMany != nil </span><span class="cov0" title="0">{
                mmImportMany.mock.t.Fatalf("OrdersRepositoryMock.ImportMany mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmImportMany.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmImportMany.defaultExpectation = &amp;OrdersRepositoryMockImportManyExpectation{}
        }</span>

        <span class="cov0" title="0">if mmImportMany.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmImportMany.mock.t.Fatalf("OrdersRepositoryMock.ImportMany mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmImportMany.defaultExpectation.params = &amp;OrdersRepositoryMockImportManyParams{ctx, list}
        mmImportMany.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmImportMany.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmImportMany.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmImportMany.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmImportMany.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmImportMany</span>
}

// ExpectCtxParam1 sets up expected param ctx for OrdersRepository.ImportMany
func (mmImportMany *mOrdersRepositoryMockImportMany) ExpectCtxParam1(ctx context.Context) *mOrdersRepositoryMockImportMany <span class="cov0" title="0">{
        if mmImportMany.mock.funcImportMany != nil </span><span class="cov0" title="0">{
                mmImportMany.mock.t.Fatalf("OrdersRepositoryMock.ImportMany mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmImportMany.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmImportMany.defaultExpectation = &amp;OrdersRepositoryMockImportManyExpectation{}
        }</span>

        <span class="cov0" title="0">if mmImportMany.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmImportMany.mock.t.Fatalf("OrdersRepositoryMock.ImportMany mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmImportMany.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmImportMany.defaultExpectation.paramPtrs = &amp;OrdersRepositoryMockImportManyParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmImportMany.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmImportMany.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmImportMany</span>
}

// ExpectListParam2 sets up expected param list for OrdersRepository.ImportMany
func (mmImportMany *mOrdersRepositoryMockImportMany) ExpectListParam2(list []*models.Order) *mOrdersRepositoryMockImportMany <span class="cov0" title="0">{
        if mmImportMany.mock.funcImportMany != nil </span><span class="cov0" title="0">{
                mmImportMany.mock.t.Fatalf("OrdersRepositoryMock.ImportMany mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmImportMany.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmImportMany.defaultExpectation = &amp;OrdersRepositoryMockImportManyExpectation{}
        }</span>

        <span class="cov0" title="0">if mmImportMany.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmImportMany.mock.t.Fatalf("OrdersRepositoryMock.ImportMany mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmImportMany.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmImportMany.defaultExpectation.paramPtrs = &amp;OrdersRepositoryMockImportManyParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmImportMany.defaultExpectation.paramPtrs.list = &amp;list
        mmImportMany.defaultExpectation.expectationOrigins.originList = minimock.CallerInfo(1)

        return mmImportMany</span>
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.ImportMany
func (mmImportMany *mOrdersRepositoryMockImportMany) Inspect(f func(ctx context.Context, list []*models.Order)) *mOrdersRepositoryMockImportMany <span class="cov0" title="0">{
        if mmImportMany.mock.inspectFuncImportMany != nil </span><span class="cov0" title="0">{
                mmImportMany.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.ImportMany")
        }</span>

        <span class="cov0" title="0">mmImportMany.mock.inspectFuncImportMany = f

        return mmImportMany</span>
}

// Return sets up results that will be returned by OrdersRepository.ImportMany
func (mmImportMany *mOrdersRepositoryMockImportMany) Return(err error) *OrdersRepositoryMock <span class="cov0" title="0">{
        if mmImportMany.mock.funcImportMany != nil </span><span class="cov0" title="0">{
                mmImportMany.mock.t.Fatalf("OrdersRepositoryMock.ImportMany mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmImportMany.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmImportMany.defaultExpectation = &amp;OrdersRepositoryMockImportManyExpectation{mock: mmImportMany.mock}
        }</span>
        <span class="cov0" title="0">mmImportMany.defaultExpectation.results = &amp;OrdersRepositoryMockImportManyResults{err}
        mmImportMany.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmImportMany.mock</span>
}

// Set uses given function f to mock the OrdersRepository.ImportMany method
func (mmImportMany *mOrdersRepositoryMockImportMany) Set(f func(ctx context.Context, list []*models.Order) (err error)) *OrdersRepositoryMock <span class="cov0" title="0">{
        if mmImportMany.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmImportMany.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.ImportMany method")
        }</span>

        <span class="cov0" title="0">if len(mmImportMany.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmImportMany.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.ImportMany method")
        }</span>

        <span class="cov0" title="0">mmImportMany.mock.funcImportMany = f
        mmImportMany.mock.funcImportManyOrigin = minimock.CallerInfo(1)
        return mmImportMany.mock</span>
}

// When sets expectation for the OrdersRepository.ImportMany which will trigger the result defined by the following
// Then helper
func (mmImportMany *mOrdersRepositoryMockImportMany) When(ctx context.Context, list []*models.Order) *OrdersRepositoryMockImportManyExpectation <span class="cov0" title="0">{
        if mmImportMany.mock.funcImportMany != nil </span><span class="cov0" title="0">{
                mmImportMany.mock.t.Fatalf("OrdersRepositoryMock.ImportMany mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrdersRepositoryMockImportManyExpectation{
                mock:               mmImportMany.mock,
                params:             &amp;OrdersRepositoryMockImportManyParams{ctx, list},
                expectationOrigins: OrdersRepositoryMockImportManyExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmImportMany.expectations = append(mmImportMany.expectations, expectation)
        return expectation</span>
}

// Then sets up OrdersRepository.ImportMany return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockImportManyExpectation) Then(err error) *OrdersRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;OrdersRepositoryMockImportManyResults{err}
        return e.mock
}</span>

// Times sets number of times OrdersRepository.ImportMany should be invoked
func (mmImportMany *mOrdersRepositoryMockImportMany) Times(n uint64) *mOrdersRepositoryMockImportMany <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmImportMany.mock.t.Fatalf("Times of OrdersRepositoryMock.ImportMany mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmImportMany.expectedInvocations, n)
        mmImportMany.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmImportMany</span>
}

func (mmImportMany *mOrdersRepositoryMockImportMany) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmImportMany.expectations) == 0 &amp;&amp; mmImportMany.defaultExpectation == nil &amp;&amp; mmImportMany.mock.funcImportMany == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmImportMany.mock.afterImportManyCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmImportMany.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// ImportMany implements mm_usecase.OrdersRepository
func (mmImportMany *OrdersRepositoryMock) ImportMany(ctx context.Context, list []*models.Order) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmImportMany.beforeImportManyCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmImportMany.afterImportManyCounter, 1)

        mmImportMany.t.Helper()

        if mmImportMany.inspectFuncImportMany != nil </span><span class="cov0" title="0">{
                mmImportMany.inspectFuncImportMany(ctx, list)
        }</span>

        <span class="cov0" title="0">mm_params := OrdersRepositoryMockImportManyParams{ctx, list}

        // Record call args
        mmImportMany.ImportManyMock.mutex.Lock()
        mmImportMany.ImportManyMock.callArgs = append(mmImportMany.ImportManyMock.callArgs, &amp;mm_params)
        mmImportMany.ImportManyMock.mutex.Unlock()

        for _, e := range mmImportMany.ImportManyMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmImportMany.ImportManyMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmImportMany.ImportManyMock.defaultExpectation.Counter, 1)
                mm_want := mmImportMany.ImportManyMock.defaultExpectation.params
                mm_want_ptrs := mmImportMany.ImportManyMock.defaultExpectation.paramPtrs

                mm_got := OrdersRepositoryMockImportManyParams{ctx, list}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmImportMany.t.Errorf("OrdersRepositoryMock.ImportMany got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmImportMany.ImportManyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.list != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.list, mm_got.list) </span><span class="cov0" title="0">{
                                mmImportMany.t.Errorf("OrdersRepositoryMock.ImportMany got unexpected parameter list, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmImportMany.ImportManyMock.defaultExpectation.expectationOrigins.originList, *mm_want_ptrs.list, mm_got.list, minimock.Diff(*mm_want_ptrs.list, mm_got.list))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmImportMany.t.Errorf("OrdersRepositoryMock.ImportMany got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmImportMany.ImportManyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmImportMany.ImportManyMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmImportMany.t.Fatal("No results are set for the OrdersRepositoryMock.ImportMany")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmImportMany.funcImportMany != nil </span><span class="cov0" title="0">{
                return mmImportMany.funcImportMany(ctx, list)
        }</span>
        <span class="cov0" title="0">mmImportMany.t.Fatalf("Unexpected call to OrdersRepositoryMock.ImportMany. %v %v", ctx, list)
        return</span>
}

// ImportManyAfterCounter returns a count of finished OrdersRepositoryMock.ImportMany invocations
func (mmImportMany *OrdersRepositoryMock) ImportManyAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmImportMany.afterImportManyCounter)
}</span>

// ImportManyBeforeCounter returns a count of OrdersRepositoryMock.ImportMany invocations
func (mmImportMany *OrdersRepositoryMock) ImportManyBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmImportMany.beforeImportManyCounter)
}</span>

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.ImportMany.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmImportMany *mOrdersRepositoryMockImportMany) Calls() []*OrdersRepositoryMockImportManyParams <span class="cov0" title="0">{
        mmImportMany.mutex.RLock()

        argCopy := make([]*OrdersRepositoryMockImportManyParams, len(mmImportMany.callArgs))
        copy(argCopy, mmImportMany.callArgs)

        mmImportMany.mutex.RUnlock()

        return argCopy
}</span>

// MinimockImportManyDone returns true if the count of the ImportMany invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockImportManyDone() bool <span class="cov0" title="0">{
        if m.ImportManyMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.ImportManyMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.ImportManyMock.invocationsDone()</span>
}

// MinimockImportManyInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockImportManyInspect() <span class="cov0" title="0">{
        for _, e := range m.ImportManyMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrdersRepositoryMock.ImportMany at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterImportManyCounter := mm_atomic.LoadUint64(&amp;m.afterImportManyCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ImportManyMock.defaultExpectation != nil &amp;&amp; afterImportManyCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.ImportManyMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrdersRepositoryMock.ImportMany at\n%s", m.ImportManyMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrdersRepositoryMock.ImportMany at\n%s with params: %#v", m.ImportManyMock.defaultExpectation.expectationOrigins.origin, *m.ImportManyMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcImportMany != nil &amp;&amp; afterImportManyCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrdersRepositoryMock.ImportMany at\n%s", m.funcImportManyOrigin)
        }</span>

        <span class="cov0" title="0">if !m.ImportManyMock.invocationsDone() &amp;&amp; afterImportManyCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrdersRepositoryMock.ImportMany at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ImportManyMock.expectedInvocations), m.ImportManyMock.expectedInvocationsOrigin, afterImportManyCounter)
        }</span>
}

type mOrdersRepositoryMockListAllOrders struct {
        optional           bool
        mock               *OrdersRepositoryMock
        defaultExpectation *OrdersRepositoryMockListAllOrdersExpectation
        expectations       []*OrdersRepositoryMockListAllOrdersExpectation

        callArgs []*OrdersRepositoryMockListAllOrdersParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrdersRepositoryMockListAllOrdersExpectation specifies expectation struct of the OrdersRepository.ListAllOrders
type OrdersRepositoryMockListAllOrdersExpectation struct {
        mock               *OrdersRepositoryMock
        params             *OrdersRepositoryMockListAllOrdersParams
        paramPtrs          *OrdersRepositoryMockListAllOrdersParamPtrs
        expectationOrigins OrdersRepositoryMockListAllOrdersExpectationOrigins
        results            *OrdersRepositoryMockListAllOrdersResults
        returnOrigin       string
        Counter            uint64
}

// OrdersRepositoryMockListAllOrdersParams contains parameters of the OrdersRepository.ListAllOrders
type OrdersRepositoryMockListAllOrdersParams struct {
        ctx context.Context
}

// OrdersRepositoryMockListAllOrdersParamPtrs contains pointers to parameters of the OrdersRepository.ListAllOrders
type OrdersRepositoryMockListAllOrdersParamPtrs struct {
        ctx *context.Context
}

// OrdersRepositoryMockListAllOrdersResults contains results of the OrdersRepository.ListAllOrders
type OrdersRepositoryMockListAllOrdersResults struct {
        opa1 []*models.Order
        err  error
}

// OrdersRepositoryMockListAllOrdersOrigins contains origins of expectations of the OrdersRepository.ListAllOrders
type OrdersRepositoryMockListAllOrdersExpectationOrigins struct {
        origin    string
        originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) Optional() *mOrdersRepositoryMockListAllOrders <span class="cov0" title="0">{
        mmListAllOrders.optional = true
        return mmListAllOrders
}</span>

// Expect sets up expected params for OrdersRepository.ListAllOrders
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) Expect(ctx context.Context) *mOrdersRepositoryMockListAllOrders <span class="cov0" title="0">{
        if mmListAllOrders.mock.funcListAllOrders != nil </span><span class="cov0" title="0">{
                mmListAllOrders.mock.t.Fatalf("OrdersRepositoryMock.ListAllOrders mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListAllOrders.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListAllOrders.defaultExpectation = &amp;OrdersRepositoryMockListAllOrdersExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListAllOrders.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmListAllOrders.mock.t.Fatalf("OrdersRepositoryMock.ListAllOrders mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmListAllOrders.defaultExpectation.params = &amp;OrdersRepositoryMockListAllOrdersParams{ctx}
        mmListAllOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmListAllOrders.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmListAllOrders.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmListAllOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListAllOrders.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmListAllOrders</span>
}

// ExpectCtxParam1 sets up expected param ctx for OrdersRepository.ListAllOrders
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) ExpectCtxParam1(ctx context.Context) *mOrdersRepositoryMockListAllOrders <span class="cov0" title="0">{
        if mmListAllOrders.mock.funcListAllOrders != nil </span><span class="cov0" title="0">{
                mmListAllOrders.mock.t.Fatalf("OrdersRepositoryMock.ListAllOrders mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListAllOrders.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListAllOrders.defaultExpectation = &amp;OrdersRepositoryMockListAllOrdersExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListAllOrders.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmListAllOrders.mock.t.Fatalf("OrdersRepositoryMock.ListAllOrders mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmListAllOrders.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmListAllOrders.defaultExpectation.paramPtrs = &amp;OrdersRepositoryMockListAllOrdersParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmListAllOrders.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmListAllOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmListAllOrders</span>
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.ListAllOrders
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) Inspect(f func(ctx context.Context)) *mOrdersRepositoryMockListAllOrders <span class="cov0" title="0">{
        if mmListAllOrders.mock.inspectFuncListAllOrders != nil </span><span class="cov0" title="0">{
                mmListAllOrders.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.ListAllOrders")
        }</span>

        <span class="cov0" title="0">mmListAllOrders.mock.inspectFuncListAllOrders = f

        return mmListAllOrders</span>
}

// Return sets up results that will be returned by OrdersRepository.ListAllOrders
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) Return(opa1 []*models.Order, err error) *OrdersRepositoryMock <span class="cov0" title="0">{
        if mmListAllOrders.mock.funcListAllOrders != nil </span><span class="cov0" title="0">{
                mmListAllOrders.mock.t.Fatalf("OrdersRepositoryMock.ListAllOrders mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListAllOrders.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListAllOrders.defaultExpectation = &amp;OrdersRepositoryMockListAllOrdersExpectation{mock: mmListAllOrders.mock}
        }</span>
        <span class="cov0" title="0">mmListAllOrders.defaultExpectation.results = &amp;OrdersRepositoryMockListAllOrdersResults{opa1, err}
        mmListAllOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmListAllOrders.mock</span>
}

// Set uses given function f to mock the OrdersRepository.ListAllOrders method
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) Set(f func(ctx context.Context) (opa1 []*models.Order, err error)) *OrdersRepositoryMock <span class="cov0" title="0">{
        if mmListAllOrders.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmListAllOrders.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.ListAllOrders method")
        }</span>

        <span class="cov0" title="0">if len(mmListAllOrders.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmListAllOrders.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.ListAllOrders method")
        }</span>

        <span class="cov0" title="0">mmListAllOrders.mock.funcListAllOrders = f
        mmListAllOrders.mock.funcListAllOrdersOrigin = minimock.CallerInfo(1)
        return mmListAllOrders.mock</span>
}

// When sets expectation for the OrdersRepository.ListAllOrders which will trigger the result defined by the following
// Then helper
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) When(ctx context.Context) *OrdersRepositoryMockListAllOrdersExpectation <span class="cov0" title="0">{
        if mmListAllOrders.mock.funcListAllOrders != nil </span><span class="cov0" title="0">{
                mmListAllOrders.mock.t.Fatalf("OrdersRepositoryMock.ListAllOrders mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrdersRepositoryMockListAllOrdersExpectation{
                mock:               mmListAllOrders.mock,
                params:             &amp;OrdersRepositoryMockListAllOrdersParams{ctx},
                expectationOrigins: OrdersRepositoryMockListAllOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmListAllOrders.expectations = append(mmListAllOrders.expectations, expectation)
        return expectation</span>
}

// Then sets up OrdersRepository.ListAllOrders return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockListAllOrdersExpectation) Then(opa1 []*models.Order, err error) *OrdersRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;OrdersRepositoryMockListAllOrdersResults{opa1, err}
        return e.mock
}</span>

// Times sets number of times OrdersRepository.ListAllOrders should be invoked
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) Times(n uint64) *mOrdersRepositoryMockListAllOrders <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmListAllOrders.mock.t.Fatalf("Times of OrdersRepositoryMock.ListAllOrders mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmListAllOrders.expectedInvocations, n)
        mmListAllOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmListAllOrders</span>
}

func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmListAllOrders.expectations) == 0 &amp;&amp; mmListAllOrders.defaultExpectation == nil &amp;&amp; mmListAllOrders.mock.funcListAllOrders == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmListAllOrders.mock.afterListAllOrdersCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmListAllOrders.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// ListAllOrders implements mm_usecase.OrdersRepository
func (mmListAllOrders *OrdersRepositoryMock) ListAllOrders(ctx context.Context) (opa1 []*models.Order, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmListAllOrders.beforeListAllOrdersCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmListAllOrders.afterListAllOrdersCounter, 1)

        mmListAllOrders.t.Helper()

        if mmListAllOrders.inspectFuncListAllOrders != nil </span><span class="cov0" title="0">{
                mmListAllOrders.inspectFuncListAllOrders(ctx)
        }</span>

        <span class="cov0" title="0">mm_params := OrdersRepositoryMockListAllOrdersParams{ctx}

        // Record call args
        mmListAllOrders.ListAllOrdersMock.mutex.Lock()
        mmListAllOrders.ListAllOrdersMock.callArgs = append(mmListAllOrders.ListAllOrdersMock.callArgs, &amp;mm_params)
        mmListAllOrders.ListAllOrdersMock.mutex.Unlock()

        for _, e := range mmListAllOrders.ListAllOrdersMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.opa1, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmListAllOrders.ListAllOrdersMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmListAllOrders.ListAllOrdersMock.defaultExpectation.Counter, 1)
                mm_want := mmListAllOrders.ListAllOrdersMock.defaultExpectation.params
                mm_want_ptrs := mmListAllOrders.ListAllOrdersMock.defaultExpectation.paramPtrs

                mm_got := OrdersRepositoryMockListAllOrdersParams{ctx}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmListAllOrders.t.Errorf("OrdersRepositoryMock.ListAllOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmListAllOrders.ListAllOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmListAllOrders.t.Errorf("OrdersRepositoryMock.ListAllOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmListAllOrders.ListAllOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmListAllOrders.ListAllOrdersMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmListAllOrders.t.Fatal("No results are set for the OrdersRepositoryMock.ListAllOrders")
                }</span>
                <span class="cov0" title="0">return (*mm_results).opa1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmListAllOrders.funcListAllOrders != nil </span><span class="cov0" title="0">{
                return mmListAllOrders.funcListAllOrders(ctx)
        }</span>
        <span class="cov0" title="0">mmListAllOrders.t.Fatalf("Unexpected call to OrdersRepositoryMock.ListAllOrders. %v", ctx)
        return</span>
}

// ListAllOrdersAfterCounter returns a count of finished OrdersRepositoryMock.ListAllOrders invocations
func (mmListAllOrders *OrdersRepositoryMock) ListAllOrdersAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmListAllOrders.afterListAllOrdersCounter)
}</span>

// ListAllOrdersBeforeCounter returns a count of OrdersRepositoryMock.ListAllOrders invocations
func (mmListAllOrders *OrdersRepositoryMock) ListAllOrdersBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmListAllOrders.beforeListAllOrdersCounter)
}</span>

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.ListAllOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListAllOrders *mOrdersRepositoryMockListAllOrders) Calls() []*OrdersRepositoryMockListAllOrdersParams <span class="cov0" title="0">{
        mmListAllOrders.mutex.RLock()

        argCopy := make([]*OrdersRepositoryMockListAllOrdersParams, len(mmListAllOrders.callArgs))
        copy(argCopy, mmListAllOrders.callArgs)

        mmListAllOrders.mutex.RUnlock()

        return argCopy
}</span>

// MinimockListAllOrdersDone returns true if the count of the ListAllOrders invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockListAllOrdersDone() bool <span class="cov0" title="0">{
        if m.ListAllOrdersMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.ListAllOrdersMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.ListAllOrdersMock.invocationsDone()</span>
}

// MinimockListAllOrdersInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockListAllOrdersInspect() <span class="cov0" title="0">{
        for _, e := range m.ListAllOrdersMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrdersRepositoryMock.ListAllOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterListAllOrdersCounter := mm_atomic.LoadUint64(&amp;m.afterListAllOrdersCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ListAllOrdersMock.defaultExpectation != nil &amp;&amp; afterListAllOrdersCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.ListAllOrdersMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrdersRepositoryMock.ListAllOrders at\n%s", m.ListAllOrdersMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrdersRepositoryMock.ListAllOrders at\n%s with params: %#v", m.ListAllOrdersMock.defaultExpectation.expectationOrigins.origin, *m.ListAllOrdersMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcListAllOrders != nil &amp;&amp; afterListAllOrdersCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrdersRepositoryMock.ListAllOrders at\n%s", m.funcListAllOrdersOrigin)
        }</span>

        <span class="cov0" title="0">if !m.ListAllOrdersMock.invocationsDone() &amp;&amp; afterListAllOrdersCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrdersRepositoryMock.ListAllOrders at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ListAllOrdersMock.expectedInvocations), m.ListAllOrdersMock.expectedInvocationsOrigin, afterListAllOrdersCounter)
        }</span>
}

type mOrdersRepositoryMockListByUser struct {
        optional           bool
        mock               *OrdersRepositoryMock
        defaultExpectation *OrdersRepositoryMockListByUserExpectation
        expectations       []*OrdersRepositoryMockListByUserExpectation

        callArgs []*OrdersRepositoryMockListByUserParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrdersRepositoryMockListByUserExpectation specifies expectation struct of the OrdersRepository.ListByUser
type OrdersRepositoryMockListByUserExpectation struct {
        mock               *OrdersRepositoryMock
        params             *OrdersRepositoryMockListByUserParams
        paramPtrs          *OrdersRepositoryMockListByUserParamPtrs
        expectationOrigins OrdersRepositoryMockListByUserExpectationOrigins
        results            *OrdersRepositoryMockListByUserResults
        returnOrigin       string
        Counter            uint64
}

// OrdersRepositoryMockListByUserParams contains parameters of the OrdersRepository.ListByUser
type OrdersRepositoryMockListByUserParams struct {
        ctx       context.Context
        userID    string
        onlyInPVZ bool
        lastN     int
        pg        *vo.Pagination
}

// OrdersRepositoryMockListByUserParamPtrs contains pointers to parameters of the OrdersRepository.ListByUser
type OrdersRepositoryMockListByUserParamPtrs struct {
        ctx       *context.Context
        userID    *string
        onlyInPVZ *bool
        lastN     *int
        pg        **vo.Pagination
}

// OrdersRepositoryMockListByUserResults contains results of the OrdersRepository.ListByUser
type OrdersRepositoryMockListByUserResults struct {
        opa1 []*models.Order
        err  error
}

// OrdersRepositoryMockListByUserOrigins contains origins of expectations of the OrdersRepository.ListByUser
type OrdersRepositoryMockListByUserExpectationOrigins struct {
        origin          string
        originCtx       string
        originUserID    string
        originOnlyInPVZ string
        originLastN     string
        originPg        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListByUser *mOrdersRepositoryMockListByUser) Optional() *mOrdersRepositoryMockListByUser <span class="cov0" title="0">{
        mmListByUser.optional = true
        return mmListByUser
}</span>

// Expect sets up expected params for OrdersRepository.ListByUser
func (mmListByUser *mOrdersRepositoryMockListByUser) Expect(ctx context.Context, userID string, onlyInPVZ bool, lastN int, pg *vo.Pagination) *mOrdersRepositoryMockListByUser <span class="cov0" title="0">{
        if mmListByUser.mock.funcListByUser != nil </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListByUser.defaultExpectation = &amp;OrdersRepositoryMockListByUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmListByUser.defaultExpectation.params = &amp;OrdersRepositoryMockListByUserParams{ctx, userID, onlyInPVZ, lastN, pg}
        mmListByUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmListByUser.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmListByUser.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmListByUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListByUser.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmListByUser</span>
}

// ExpectCtxParam1 sets up expected param ctx for OrdersRepository.ListByUser
func (mmListByUser *mOrdersRepositoryMockListByUser) ExpectCtxParam1(ctx context.Context) *mOrdersRepositoryMockListByUser <span class="cov0" title="0">{
        if mmListByUser.mock.funcListByUser != nil </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListByUser.defaultExpectation = &amp;OrdersRepositoryMockListByUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmListByUser.defaultExpectation.paramPtrs = &amp;OrdersRepositoryMockListByUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmListByUser.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmListByUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmListByUser</span>
}

// ExpectUserIDParam2 sets up expected param userID for OrdersRepository.ListByUser
func (mmListByUser *mOrdersRepositoryMockListByUser) ExpectUserIDParam2(userID string) *mOrdersRepositoryMockListByUser <span class="cov0" title="0">{
        if mmListByUser.mock.funcListByUser != nil </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListByUser.defaultExpectation = &amp;OrdersRepositoryMockListByUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmListByUser.defaultExpectation.paramPtrs = &amp;OrdersRepositoryMockListByUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmListByUser.defaultExpectation.paramPtrs.userID = &amp;userID
        mmListByUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

        return mmListByUser</span>
}

// ExpectOnlyInPVZParam3 sets up expected param onlyInPVZ for OrdersRepository.ListByUser
func (mmListByUser *mOrdersRepositoryMockListByUser) ExpectOnlyInPVZParam3(onlyInPVZ bool) *mOrdersRepositoryMockListByUser <span class="cov0" title="0">{
        if mmListByUser.mock.funcListByUser != nil </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListByUser.defaultExpectation = &amp;OrdersRepositoryMockListByUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmListByUser.defaultExpectation.paramPtrs = &amp;OrdersRepositoryMockListByUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmListByUser.defaultExpectation.paramPtrs.onlyInPVZ = &amp;onlyInPVZ
        mmListByUser.defaultExpectation.expectationOrigins.originOnlyInPVZ = minimock.CallerInfo(1)

        return mmListByUser</span>
}

// ExpectLastNParam4 sets up expected param lastN for OrdersRepository.ListByUser
func (mmListByUser *mOrdersRepositoryMockListByUser) ExpectLastNParam4(lastN int) *mOrdersRepositoryMockListByUser <span class="cov0" title="0">{
        if mmListByUser.mock.funcListByUser != nil </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListByUser.defaultExpectation = &amp;OrdersRepositoryMockListByUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmListByUser.defaultExpectation.paramPtrs = &amp;OrdersRepositoryMockListByUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmListByUser.defaultExpectation.paramPtrs.lastN = &amp;lastN
        mmListByUser.defaultExpectation.expectationOrigins.originLastN = minimock.CallerInfo(1)

        return mmListByUser</span>
}

// ExpectPgParam5 sets up expected param pg for OrdersRepository.ListByUser
func (mmListByUser *mOrdersRepositoryMockListByUser) ExpectPgParam5(pg *vo.Pagination) *mOrdersRepositoryMockListByUser <span class="cov0" title="0">{
        if mmListByUser.mock.funcListByUser != nil </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListByUser.defaultExpectation = &amp;OrdersRepositoryMockListByUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmListByUser.defaultExpectation.paramPtrs = &amp;OrdersRepositoryMockListByUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmListByUser.defaultExpectation.paramPtrs.pg = &amp;pg
        mmListByUser.defaultExpectation.expectationOrigins.originPg = minimock.CallerInfo(1)

        return mmListByUser</span>
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.ListByUser
func (mmListByUser *mOrdersRepositoryMockListByUser) Inspect(f func(ctx context.Context, userID string, onlyInPVZ bool, lastN int, pg *vo.Pagination)) *mOrdersRepositoryMockListByUser <span class="cov0" title="0">{
        if mmListByUser.mock.inspectFuncListByUser != nil </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.ListByUser")
        }</span>

        <span class="cov0" title="0">mmListByUser.mock.inspectFuncListByUser = f

        return mmListByUser</span>
}

// Return sets up results that will be returned by OrdersRepository.ListByUser
func (mmListByUser *mOrdersRepositoryMockListByUser) Return(opa1 []*models.Order, err error) *OrdersRepositoryMock <span class="cov0" title="0">{
        if mmListByUser.mock.funcListByUser != nil </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListByUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListByUser.defaultExpectation = &amp;OrdersRepositoryMockListByUserExpectation{mock: mmListByUser.mock}
        }</span>
        <span class="cov0" title="0">mmListByUser.defaultExpectation.results = &amp;OrdersRepositoryMockListByUserResults{opa1, err}
        mmListByUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmListByUser.mock</span>
}

// Set uses given function f to mock the OrdersRepository.ListByUser method
func (mmListByUser *mOrdersRepositoryMockListByUser) Set(f func(ctx context.Context, userID string, onlyInPVZ bool, lastN int, pg *vo.Pagination) (opa1 []*models.Order, err error)) *OrdersRepositoryMock <span class="cov0" title="0">{
        if mmListByUser.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.ListByUser method")
        }</span>

        <span class="cov0" title="0">if len(mmListByUser.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.ListByUser method")
        }</span>

        <span class="cov0" title="0">mmListByUser.mock.funcListByUser = f
        mmListByUser.mock.funcListByUserOrigin = minimock.CallerInfo(1)
        return mmListByUser.mock</span>
}

// When sets expectation for the OrdersRepository.ListByUser which will trigger the result defined by the following
// Then helper
func (mmListByUser *mOrdersRepositoryMockListByUser) When(ctx context.Context, userID string, onlyInPVZ bool, lastN int, pg *vo.Pagination) *OrdersRepositoryMockListByUserExpectation <span class="cov0" title="0">{
        if mmListByUser.mock.funcListByUser != nil </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("OrdersRepositoryMock.ListByUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrdersRepositoryMockListByUserExpectation{
                mock:               mmListByUser.mock,
                params:             &amp;OrdersRepositoryMockListByUserParams{ctx, userID, onlyInPVZ, lastN, pg},
                expectationOrigins: OrdersRepositoryMockListByUserExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmListByUser.expectations = append(mmListByUser.expectations, expectation)
        return expectation</span>
}

// Then sets up OrdersRepository.ListByUser return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockListByUserExpectation) Then(opa1 []*models.Order, err error) *OrdersRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;OrdersRepositoryMockListByUserResults{opa1, err}
        return e.mock
}</span>

// Times sets number of times OrdersRepository.ListByUser should be invoked
func (mmListByUser *mOrdersRepositoryMockListByUser) Times(n uint64) *mOrdersRepositoryMockListByUser <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmListByUser.mock.t.Fatalf("Times of OrdersRepositoryMock.ListByUser mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmListByUser.expectedInvocations, n)
        mmListByUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmListByUser</span>
}

func (mmListByUser *mOrdersRepositoryMockListByUser) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmListByUser.expectations) == 0 &amp;&amp; mmListByUser.defaultExpectation == nil &amp;&amp; mmListByUser.mock.funcListByUser == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmListByUser.mock.afterListByUserCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmListByUser.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// ListByUser implements mm_usecase.OrdersRepository
func (mmListByUser *OrdersRepositoryMock) ListByUser(ctx context.Context, userID string, onlyInPVZ bool, lastN int, pg *vo.Pagination) (opa1 []*models.Order, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmListByUser.beforeListByUserCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmListByUser.afterListByUserCounter, 1)

        mmListByUser.t.Helper()

        if mmListByUser.inspectFuncListByUser != nil </span><span class="cov0" title="0">{
                mmListByUser.inspectFuncListByUser(ctx, userID, onlyInPVZ, lastN, pg)
        }</span>

        <span class="cov0" title="0">mm_params := OrdersRepositoryMockListByUserParams{ctx, userID, onlyInPVZ, lastN, pg}

        // Record call args
        mmListByUser.ListByUserMock.mutex.Lock()
        mmListByUser.ListByUserMock.callArgs = append(mmListByUser.ListByUserMock.callArgs, &amp;mm_params)
        mmListByUser.ListByUserMock.mutex.Unlock()

        for _, e := range mmListByUser.ListByUserMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.opa1, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmListByUser.ListByUserMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmListByUser.ListByUserMock.defaultExpectation.Counter, 1)
                mm_want := mmListByUser.ListByUserMock.defaultExpectation.params
                mm_want_ptrs := mmListByUser.ListByUserMock.defaultExpectation.paramPtrs

                mm_got := OrdersRepositoryMockListByUserParams{ctx, userID, onlyInPVZ, lastN, pg}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmListByUser.t.Errorf("OrdersRepositoryMock.ListByUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmListByUser.ListByUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.userID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) </span><span class="cov0" title="0">{
                                mmListByUser.t.Errorf("OrdersRepositoryMock.ListByUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmListByUser.ListByUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.onlyInPVZ != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.onlyInPVZ, mm_got.onlyInPVZ) </span><span class="cov0" title="0">{
                                mmListByUser.t.Errorf("OrdersRepositoryMock.ListByUser got unexpected parameter onlyInPVZ, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmListByUser.ListByUserMock.defaultExpectation.expectationOrigins.originOnlyInPVZ, *mm_want_ptrs.onlyInPVZ, mm_got.onlyInPVZ, minimock.Diff(*mm_want_ptrs.onlyInPVZ, mm_got.onlyInPVZ))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.lastN != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.lastN, mm_got.lastN) </span><span class="cov0" title="0">{
                                mmListByUser.t.Errorf("OrdersRepositoryMock.ListByUser got unexpected parameter lastN, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmListByUser.ListByUserMock.defaultExpectation.expectationOrigins.originLastN, *mm_want_ptrs.lastN, mm_got.lastN, minimock.Diff(*mm_want_ptrs.lastN, mm_got.lastN))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.pg != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.pg, mm_got.pg) </span><span class="cov0" title="0">{
                                mmListByUser.t.Errorf("OrdersRepositoryMock.ListByUser got unexpected parameter pg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmListByUser.ListByUserMock.defaultExpectation.expectationOrigins.originPg, *mm_want_ptrs.pg, mm_got.pg, minimock.Diff(*mm_want_ptrs.pg, mm_got.pg))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmListByUser.t.Errorf("OrdersRepositoryMock.ListByUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmListByUser.ListByUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmListByUser.ListByUserMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmListByUser.t.Fatal("No results are set for the OrdersRepositoryMock.ListByUser")
                }</span>
                <span class="cov0" title="0">return (*mm_results).opa1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmListByUser.funcListByUser != nil </span><span class="cov0" title="0">{
                return mmListByUser.funcListByUser(ctx, userID, onlyInPVZ, lastN, pg)
        }</span>
        <span class="cov0" title="0">mmListByUser.t.Fatalf("Unexpected call to OrdersRepositoryMock.ListByUser. %v %v %v %v %v", ctx, userID, onlyInPVZ, lastN, pg)
        return</span>
}

// ListByUserAfterCounter returns a count of finished OrdersRepositoryMock.ListByUser invocations
func (mmListByUser *OrdersRepositoryMock) ListByUserAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmListByUser.afterListByUserCounter)
}</span>

// ListByUserBeforeCounter returns a count of OrdersRepositoryMock.ListByUser invocations
func (mmListByUser *OrdersRepositoryMock) ListByUserBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmListByUser.beforeListByUserCounter)
}</span>

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.ListByUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListByUser *mOrdersRepositoryMockListByUser) Calls() []*OrdersRepositoryMockListByUserParams <span class="cov0" title="0">{
        mmListByUser.mutex.RLock()

        argCopy := make([]*OrdersRepositoryMockListByUserParams, len(mmListByUser.callArgs))
        copy(argCopy, mmListByUser.callArgs)

        mmListByUser.mutex.RUnlock()

        return argCopy
}</span>

// MinimockListByUserDone returns true if the count of the ListByUser invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockListByUserDone() bool <span class="cov0" title="0">{
        if m.ListByUserMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.ListByUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.ListByUserMock.invocationsDone()</span>
}

// MinimockListByUserInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockListByUserInspect() <span class="cov0" title="0">{
        for _, e := range m.ListByUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrdersRepositoryMock.ListByUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterListByUserCounter := mm_atomic.LoadUint64(&amp;m.afterListByUserCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ListByUserMock.defaultExpectation != nil &amp;&amp; afterListByUserCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.ListByUserMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrdersRepositoryMock.ListByUser at\n%s", m.ListByUserMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrdersRepositoryMock.ListByUser at\n%s with params: %#v", m.ListByUserMock.defaultExpectation.expectationOrigins.origin, *m.ListByUserMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcListByUser != nil &amp;&amp; afterListByUserCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrdersRepositoryMock.ListByUser at\n%s", m.funcListByUserOrigin)
        }</span>

        <span class="cov0" title="0">if !m.ListByUserMock.invocationsDone() &amp;&amp; afterListByUserCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrdersRepositoryMock.ListByUser at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ListByUserMock.expectedInvocations), m.ListByUserMock.expectedInvocationsOrigin, afterListByUserCounter)
        }</span>
}

type mOrdersRepositoryMockUpdate struct {
        optional           bool
        mock               *OrdersRepositoryMock
        defaultExpectation *OrdersRepositoryMockUpdateExpectation
        expectations       []*OrdersRepositoryMockUpdateExpectation

        callArgs []*OrdersRepositoryMockUpdateParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrdersRepositoryMockUpdateExpectation specifies expectation struct of the OrdersRepository.Update
type OrdersRepositoryMockUpdateExpectation struct {
        mock               *OrdersRepositoryMock
        params             *OrdersRepositoryMockUpdateParams
        paramPtrs          *OrdersRepositoryMockUpdateParamPtrs
        expectationOrigins OrdersRepositoryMockUpdateExpectationOrigins
        results            *OrdersRepositoryMockUpdateResults
        returnOrigin       string
        Counter            uint64
}

// OrdersRepositoryMockUpdateParams contains parameters of the OrdersRepository.Update
type OrdersRepositoryMockUpdateParams struct {
        ctx context.Context
        o   *models.Order
}

// OrdersRepositoryMockUpdateParamPtrs contains pointers to parameters of the OrdersRepository.Update
type OrdersRepositoryMockUpdateParamPtrs struct {
        ctx *context.Context
        o   **models.Order
}

// OrdersRepositoryMockUpdateResults contains results of the OrdersRepository.Update
type OrdersRepositoryMockUpdateResults struct {
        err error
}

// OrdersRepositoryMockUpdateOrigins contains origins of expectations of the OrdersRepository.Update
type OrdersRepositoryMockUpdateExpectationOrigins struct {
        origin    string
        originCtx string
        originO   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mOrdersRepositoryMockUpdate) Optional() *mOrdersRepositoryMockUpdate <span class="cov0" title="0">{
        mmUpdate.optional = true
        return mmUpdate
}</span>

// Expect sets up expected params for OrdersRepository.Update
func (mmUpdate *mOrdersRepositoryMockUpdate) Expect(ctx context.Context, o *models.Order) *mOrdersRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("OrdersRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;OrdersRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("OrdersRepositoryMock.Update mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmUpdate.defaultExpectation.params = &amp;OrdersRepositoryMockUpdateParams{ctx, o}
        mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmUpdate.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmUpdate</span>
}

// ExpectCtxParam1 sets up expected param ctx for OrdersRepository.Update
func (mmUpdate *mOrdersRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mOrdersRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("OrdersRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;OrdersRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("OrdersRepositoryMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;OrdersRepositoryMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// ExpectOParam2 sets up expected param o for OrdersRepository.Update
func (mmUpdate *mOrdersRepositoryMockUpdate) ExpectOParam2(o *models.Order) *mOrdersRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("OrdersRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;OrdersRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("OrdersRepositoryMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;OrdersRepositoryMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.o = &amp;o
        mmUpdate.defaultExpectation.expectationOrigins.originO = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.Update
func (mmUpdate *mOrdersRepositoryMockUpdate) Inspect(f func(ctx context.Context, o *models.Order)) *mOrdersRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.Update")
        }</span>

        <span class="cov0" title="0">mmUpdate.mock.inspectFuncUpdate = f

        return mmUpdate</span>
}

// Return sets up results that will be returned by OrdersRepository.Update
func (mmUpdate *mOrdersRepositoryMockUpdate) Return(err error) *OrdersRepositoryMock <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("OrdersRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;OrdersRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.results = &amp;OrdersRepositoryMockUpdateResults{err}
        mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// Set uses given function f to mock the OrdersRepository.Update method
func (mmUpdate *mOrdersRepositoryMockUpdate) Set(f func(ctx context.Context, o *models.Order) (err error)) *OrdersRepositoryMock <span class="cov0" title="0">{
        if mmUpdate.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.Update method")
        }</span>

        <span class="cov0" title="0">if len(mmUpdate.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.Update method")
        }</span>

        <span class="cov0" title="0">mmUpdate.mock.funcUpdate = f
        mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// When sets expectation for the OrdersRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mOrdersRepositoryMockUpdate) When(ctx context.Context, o *models.Order) *OrdersRepositoryMockUpdateExpectation <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("OrdersRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrdersRepositoryMockUpdateExpectation{
                mock:               mmUpdate.mock,
                params:             &amp;OrdersRepositoryMockUpdateParams{ctx, o},
                expectationOrigins: OrdersRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmUpdate.expectations = append(mmUpdate.expectations, expectation)
        return expectation</span>
}

// Then sets up OrdersRepository.Update return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockUpdateExpectation) Then(err error) *OrdersRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;OrdersRepositoryMockUpdateResults{err}
        return e.mock
}</span>

// Times sets number of times OrdersRepository.Update should be invoked
func (mmUpdate *mOrdersRepositoryMockUpdate) Times(n uint64) *mOrdersRepositoryMockUpdate <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Times of OrdersRepositoryMock.Update mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmUpdate.expectedInvocations, n)
        mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmUpdate</span>
}

func (mmUpdate *mOrdersRepositoryMockUpdate) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmUpdate.expectations) == 0 &amp;&amp; mmUpdate.defaultExpectation == nil &amp;&amp; mmUpdate.mock.funcUpdate == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.mock.afterUpdateCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Update implements mm_usecase.OrdersRepository
func (mmUpdate *OrdersRepositoryMock) Update(ctx context.Context, o *models.Order) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmUpdate.beforeUpdateCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmUpdate.afterUpdateCounter, 1)

        mmUpdate.t.Helper()

        if mmUpdate.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.inspectFuncUpdate(ctx, o)
        }</span>

        <span class="cov0" title="0">mm_params := OrdersRepositoryMockUpdateParams{ctx, o}

        // Record call args
        mmUpdate.UpdateMock.mutex.Lock()
        mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &amp;mm_params)
        mmUpdate.UpdateMock.mutex.Unlock()

        for _, e := range mmUpdate.UpdateMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmUpdate.UpdateMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
                mm_want := mmUpdate.UpdateMock.defaultExpectation.params
                mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

                mm_got := OrdersRepositoryMockUpdateParams{ctx, o}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("OrdersRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.o != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.o, mm_got.o) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("OrdersRepositoryMock.Update got unexpected parameter o, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originO, *mm_want_ptrs.o, mm_got.o, minimock.Diff(*mm_want_ptrs.o, mm_got.o))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmUpdate.t.Errorf("OrdersRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmUpdate.UpdateMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmUpdate.t.Fatal("No results are set for the OrdersRepositoryMock.Update")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmUpdate.funcUpdate != nil </span><span class="cov0" title="0">{
                return mmUpdate.funcUpdate(ctx, o)
        }</span>
        <span class="cov0" title="0">mmUpdate.t.Fatalf("Unexpected call to OrdersRepositoryMock.Update. %v %v", ctx, o)
        return</span>
}

// UpdateAfterCounter returns a count of finished OrdersRepositoryMock.Update invocations
func (mmUpdate *OrdersRepositoryMock) UpdateAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.afterUpdateCounter)
}</span>

// UpdateBeforeCounter returns a count of OrdersRepositoryMock.Update invocations
func (mmUpdate *OrdersRepositoryMock) UpdateBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.beforeUpdateCounter)
}</span>

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mOrdersRepositoryMockUpdate) Calls() []*OrdersRepositoryMockUpdateParams <span class="cov0" title="0">{
        mmUpdate.mutex.RLock()

        argCopy := make([]*OrdersRepositoryMockUpdateParams, len(mmUpdate.callArgs))
        copy(argCopy, mmUpdate.callArgs)

        mmUpdate.mutex.RUnlock()

        return argCopy
}</span>

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockUpdateDone() bool <span class="cov0" title="0">{
        if m.UpdateMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.UpdateMock.invocationsDone()</span>
}

// MinimockUpdateInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockUpdateInspect() <span class="cov0" title="0">{
        for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrdersRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterUpdateCounter := mm_atomic.LoadUint64(&amp;m.afterUpdateCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.UpdateMock.defaultExpectation != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.UpdateMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrdersRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrdersRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcUpdate != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrdersRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
        }</span>

        <span class="cov0" title="0">if !m.UpdateMock.invocationsDone() &amp;&amp; afterUpdateCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrdersRepositoryMock.Update at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrdersRepositoryMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockCreateInspect()

                        m.MinimockDeleteInspect()

                        m.MinimockGetInspect()

                        m.MinimockImportManyInspect()

                        m.MinimockListAllOrdersInspect()

                        m.MinimockListByUserInspect()

                        m.MinimockUpdateInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrdersRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *OrdersRepositoryMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockCreateDone() &amp;&amp;
                m.MinimockDeleteDone() &amp;&amp;
                m.MinimockGetDone() &amp;&amp;
                m.MinimockImportManyDone() &amp;&amp;
                m.MinimockListAllOrdersDone() &amp;&amp;
                m.MinimockListByUserDone() &amp;&amp;
                m.MinimockUpdateDone()
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package packaging

import (
        "pvz-cli/internal/domain/codes"
        "pvz-cli/internal/domain/models"
)

type bagStrategy struct{}

// NewBagStrategy возвращает стратегию упаковки "bag".
func NewBagStrategy() PackagingStrategy <span class="cov8" title="1">{
        return &amp;bagStrategy{}
}</span>

func (b *bagStrategy) Validate(w float64) error <span class="cov8" title="1">{
        if w &lt;= 0 </span><span class="cov8" title="1">{
                return codes.ErrValidationFailed
        }</span>
        <span class="cov8" title="1">if w &gt;= 10 </span><span class="cov8" title="1">{
                return codes.ErrWeightTooHeavy
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (b *bagStrategy) Surcharge() models.PriceKopecks <span class="cov8" title="1">{
        return models.SurchargeBag
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package packaging

import (
        "pvz-cli/internal/domain/codes"
        "pvz-cli/internal/domain/models"
)

type boxStrategy struct{}

// NewBoxStrategy возвращает стратегию упаковки "box".
func NewBoxStrategy() PackagingStrategy <span class="cov8" title="1">{
        return &amp;boxStrategy{}
}</span>

func (b *boxStrategy) Validate(weight float64) error <span class="cov8" title="1">{
        if weight &lt;= 0 </span><span class="cov8" title="1">{
                return codes.ErrValidationFailed
        }</span>
        <span class="cov8" title="1">if weight &gt;= 30 </span><span class="cov8" title="1">{
                return codes.ErrWeightTooHeavy
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (b *boxStrategy) Surcharge() models.PriceKopecks <span class="cov8" title="1">{
        return models.SurchargeBox
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package packaging

import "pvz-cli/internal/domain/models"

type compositeStrategy struct {
        parts []PackagingStrategy
}

// NewCompositeStrategy создает составную стратегию упаковки из нескольких частей.
func NewCompositeStrategy(parts ...PackagingStrategy) PackagingStrategy <span class="cov8" title="1">{
        return &amp;compositeStrategy{parts: parts}
}</span>

func (c *compositeStrategy) Validate(weight float64) error <span class="cov8" title="1">{
        for _, s := range c.parts </span><span class="cov8" title="1">{
                if err := s.Validate(weight); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (c *compositeStrategy) Surcharge() models.PriceKopecks <span class="cov8" title="1">{
        var total models.PriceKopecks
        for _, s := range c.parts </span><span class="cov8" title="1">{
                total += s.Surcharge()
        }</span>
        <span class="cov8" title="1">return total</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package packaging

import (
        "pvz-cli/internal/domain/codes"
        "pvz-cli/internal/domain/models"
)

type filmStrategy struct{}

// NewFilmStrategy возвращает стратегию упаковки "film".
func NewFilmStrategy() PackagingStrategy <span class="cov8" title="1">{
        return &amp;filmStrategy{}
}</span>

func (f *filmStrategy) Validate(weight float64) error <span class="cov8" title="1">{
        if weight &lt;= 0 </span><span class="cov8" title="1">{
                return codes.ErrValidationFailed
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (f *filmStrategy) Surcharge() models.PriceKopecks <span class="cov8" title="1">{
        return models.SurchargeFilm
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i pvz-cli/internal/usecase/packaging.PackagingStrategy -o packaging_strategy_mock.go -n PackagingStrategyMock -p mock

import (
        "pvz-cli/internal/domain/models"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
)

// PackagingStrategyMock implements mm_packaging.PackagingStrategy
type PackagingStrategyMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcSurcharge          func() (p1 models.PriceKopecks)
        funcSurchargeOrigin    string
        inspectFuncSurcharge   func()
        afterSurchargeCounter  uint64
        beforeSurchargeCounter uint64
        SurchargeMock          mPackagingStrategyMockSurcharge

        funcValidate          func(weight float64) (err error)
        funcValidateOrigin    string
        inspectFuncValidate   func(weight float64)
        afterValidateCounter  uint64
        beforeValidateCounter uint64
        ValidateMock          mPackagingStrategyMockValidate
}

// NewPackagingStrategyMock returns a mock for mm_packaging.PackagingStrategy
func NewPackagingStrategyMock(t minimock.Tester) *PackagingStrategyMock <span class="cov0" title="0">{
        m := &amp;PackagingStrategyMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.SurchargeMock = mPackagingStrategyMockSurcharge{mock: m}

        m.ValidateMock = mPackagingStrategyMockValidate{mock: m}
        m.ValidateMock.callArgs = []*PackagingStrategyMockValidateParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mPackagingStrategyMockSurcharge struct {
        optional           bool
        mock               *PackagingStrategyMock
        defaultExpectation *PackagingStrategyMockSurchargeExpectation
        expectations       []*PackagingStrategyMockSurchargeExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// PackagingStrategyMockSurchargeExpectation specifies expectation struct of the PackagingStrategy.Surcharge
type PackagingStrategyMockSurchargeExpectation struct {
        mock *PackagingStrategyMock

        results      *PackagingStrategyMockSurchargeResults
        returnOrigin string
        Counter      uint64
}

// PackagingStrategyMockSurchargeResults contains results of the PackagingStrategy.Surcharge
type PackagingStrategyMockSurchargeResults struct {
        p1 models.PriceKopecks
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSurcharge *mPackagingStrategyMockSurcharge) Optional() *mPackagingStrategyMockSurcharge <span class="cov0" title="0">{
        mmSurcharge.optional = true
        return mmSurcharge
}</span>

// Expect sets up expected params for PackagingStrategy.Surcharge
func (mmSurcharge *mPackagingStrategyMockSurcharge) Expect() *mPackagingStrategyMockSurcharge <span class="cov0" title="0">{
        if mmSurcharge.mock.funcSurcharge != nil </span><span class="cov0" title="0">{
                mmSurcharge.mock.t.Fatalf("PackagingStrategyMock.Surcharge mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSurcharge.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSurcharge.defaultExpectation = &amp;PackagingStrategyMockSurchargeExpectation{}
        }</span>

        <span class="cov0" title="0">return mmSurcharge</span>
}

// Inspect accepts an inspector function that has same arguments as the PackagingStrategy.Surcharge
func (mmSurcharge *mPackagingStrategyMockSurcharge) Inspect(f func()) *mPackagingStrategyMockSurcharge <span class="cov0" title="0">{
        if mmSurcharge.mock.inspectFuncSurcharge != nil </span><span class="cov0" title="0">{
                mmSurcharge.mock.t.Fatalf("Inspect function is already set for PackagingStrategyMock.Surcharge")
        }</span>

        <span class="cov0" title="0">mmSurcharge.mock.inspectFuncSurcharge = f

        return mmSurcharge</span>
}

// Return sets up results that will be returned by PackagingStrategy.Surcharge
func (mmSurcharge *mPackagingStrategyMockSurcharge) Return(p1 models.PriceKopecks) *PackagingStrategyMock <span class="cov0" title="0">{
        if mmSurcharge.mock.funcSurcharge != nil </span><span class="cov0" title="0">{
                mmSurcharge.mock.t.Fatalf("PackagingStrategyMock.Surcharge mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSurcharge.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSurcharge.defaultExpectation = &amp;PackagingStrategyMockSurchargeExpectation{mock: mmSurcharge.mock}
        }</span>
        <span class="cov0" title="0">mmSurcharge.defaultExpectation.results = &amp;PackagingStrategyMockSurchargeResults{p1}
        mmSurcharge.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmSurcharge.mock</span>
}

// Set uses given function f to mock the PackagingStrategy.Surcharge method
func (mmSurcharge *mPackagingStrategyMockSurcharge) Set(f func() (p1 models.PriceKopecks)) *PackagingStrategyMock <span class="cov0" title="0">{
        if mmSurcharge.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmSurcharge.mock.t.Fatalf("Default expectation is already set for the PackagingStrategy.Surcharge method")
        }</span>

        <span class="cov0" title="0">if len(mmSurcharge.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmSurcharge.mock.t.Fatalf("Some expectations are already set for the PackagingStrategy.Surcharge method")
        }</span>

        <span class="cov0" title="0">mmSurcharge.mock.funcSurcharge = f
        mmSurcharge.mock.funcSurchargeOrigin = minimock.CallerInfo(1)
        return mmSurcharge.mock</span>
}

// Times sets number of times PackagingStrategy.Surcharge should be invoked
func (mmSurcharge *mPackagingStrategyMockSurcharge) Times(n uint64) *mPackagingStrategyMockSurcharge <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmSurcharge.mock.t.Fatalf("Times of PackagingStrategyMock.Surcharge mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmSurcharge.expectedInvocations, n)
        mmSurcharge.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmSurcharge</span>
}

func (mmSurcharge *mPackagingStrategyMockSurcharge) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmSurcharge.expectations) == 0 &amp;&amp; mmSurcharge.defaultExpectation == nil &amp;&amp; mmSurcharge.mock.funcSurcharge == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmSurcharge.mock.afterSurchargeCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmSurcharge.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Surcharge implements mm_packaging.PackagingStrategy
func (mmSurcharge *PackagingStrategyMock) Surcharge() (p1 models.PriceKopecks) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmSurcharge.beforeSurchargeCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmSurcharge.afterSurchargeCounter, 1)

        mmSurcharge.t.Helper()

        if mmSurcharge.inspectFuncSurcharge != nil </span><span class="cov0" title="0">{
                mmSurcharge.inspectFuncSurcharge()
        }</span>

        <span class="cov0" title="0">if mmSurcharge.SurchargeMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmSurcharge.SurchargeMock.defaultExpectation.Counter, 1)

                mm_results := mmSurcharge.SurchargeMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmSurcharge.t.Fatal("No results are set for the PackagingStrategyMock.Surcharge")
                }</span>
                <span class="cov0" title="0">return (*mm_results).p1</span>
        }
        <span class="cov0" title="0">if mmSurcharge.funcSurcharge != nil </span><span class="cov0" title="0">{
                return mmSurcharge.funcSurcharge()
        }</span>
        <span class="cov0" title="0">mmSurcharge.t.Fatalf("Unexpected call to PackagingStrategyMock.Surcharge.")
        return</span>
}

// SurchargeAfterCounter returns a count of finished PackagingStrategyMock.Surcharge invocations
func (mmSurcharge *PackagingStrategyMock) SurchargeAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSurcharge.afterSurchargeCounter)
}</span>

// SurchargeBeforeCounter returns a count of PackagingStrategyMock.Surcharge invocations
func (mmSurcharge *PackagingStrategyMock) SurchargeBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSurcharge.beforeSurchargeCounter)
}</span>

// MinimockSurchargeDone returns true if the count of the Surcharge invocations corresponds
// the number of defined expectations
func (m *PackagingStrategyMock) MinimockSurchargeDone() bool <span class="cov0" title="0">{
        if m.SurchargeMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.SurchargeMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.SurchargeMock.invocationsDone()</span>
}

// MinimockSurchargeInspect logs each unmet expectation
func (m *PackagingStrategyMock) MinimockSurchargeInspect() <span class="cov0" title="0">{
        for _, e := range m.SurchargeMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to PackagingStrategyMock.Surcharge")
                }</span>
        }

        <span class="cov0" title="0">afterSurchargeCounter := mm_atomic.LoadUint64(&amp;m.afterSurchargeCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.SurchargeMock.defaultExpectation != nil &amp;&amp; afterSurchargeCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to PackagingStrategyMock.Surcharge at\n%s", m.SurchargeMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcSurcharge != nil &amp;&amp; afterSurchargeCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to PackagingStrategyMock.Surcharge at\n%s", m.funcSurchargeOrigin)
        }</span>

        <span class="cov0" title="0">if !m.SurchargeMock.invocationsDone() &amp;&amp; afterSurchargeCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to PackagingStrategyMock.Surcharge at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.SurchargeMock.expectedInvocations), m.SurchargeMock.expectedInvocationsOrigin, afterSurchargeCounter)
        }</span>
}

type mPackagingStrategyMockValidate struct {
        optional           bool
        mock               *PackagingStrategyMock
        defaultExpectation *PackagingStrategyMockValidateExpectation
        expectations       []*PackagingStrategyMockValidateExpectation

        callArgs []*PackagingStrategyMockValidateParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// PackagingStrategyMockValidateExpectation specifies expectation struct of the PackagingStrategy.Validate
type PackagingStrategyMockValidateExpectation struct {
        mock               *PackagingStrategyMock
        params             *PackagingStrategyMockValidateParams
        paramPtrs          *PackagingStrategyMockValidateParamPtrs
        expectationOrigins PackagingStrategyMockValidateExpectationOrigins
        results            *PackagingStrategyMockValidateResults
        returnOrigin       string
        Counter            uint64
}

// PackagingStrategyMockValidateParams contains parameters of the PackagingStrategy.Validate
type PackagingStrategyMockValidateParams struct {
        weight float64
}

// PackagingStrategyMockValidateParamPtrs contains pointers to parameters of the PackagingStrategy.Validate
type PackagingStrategyMockValidateParamPtrs struct {
        weight *float64
}

// PackagingStrategyMockValidateResults contains results of the PackagingStrategy.Validate
type PackagingStrategyMockValidateResults struct {
        err error
}

// PackagingStrategyMockValidateOrigins contains origins of expectations of the PackagingStrategy.Validate
type PackagingStrategyMockValidateExpectationOrigins struct {
        origin       string
        originWeight string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidate *mPackagingStrategyMockValidate) Optional() *mPackagingStrategyMockValidate <span class="cov0" title="0">{
        mmValidate.optional = true
        return mmValidate
}</span>

// Expect sets up expected params for PackagingStrategy.Validate
func (mmValidate *mPackagingStrategyMockValidate) Expect(weight float64) *mPackagingStrategyMockValidate <span class="cov0" title="0">{
        if mmValidate.mock.funcValidate != nil </span><span class="cov0" title="0">{
                mmValidate.mock.t.Fatalf("PackagingStrategyMock.Validate mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmValidate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmValidate.defaultExpectation = &amp;PackagingStrategyMockValidateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmValidate.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmValidate.mock.t.Fatalf("PackagingStrategyMock.Validate mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmValidate.defaultExpectation.params = &amp;PackagingStrategyMockValidateParams{weight}
        mmValidate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmValidate.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmValidate.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmValidate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidate.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmValidate</span>
}

// ExpectWeightParam1 sets up expected param weight for PackagingStrategy.Validate
func (mmValidate *mPackagingStrategyMockValidate) ExpectWeightParam1(weight float64) *mPackagingStrategyMockValidate <span class="cov0" title="0">{
        if mmValidate.mock.funcValidate != nil </span><span class="cov0" title="0">{
                mmValidate.mock.t.Fatalf("PackagingStrategyMock.Validate mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmValidate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmValidate.defaultExpectation = &amp;PackagingStrategyMockValidateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmValidate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmValidate.mock.t.Fatalf("PackagingStrategyMock.Validate mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmValidate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmValidate.defaultExpectation.paramPtrs = &amp;PackagingStrategyMockValidateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmValidate.defaultExpectation.paramPtrs.weight = &amp;weight
        mmValidate.defaultExpectation.expectationOrigins.originWeight = minimock.CallerInfo(1)

        return mmValidate</span>
}

// Inspect accepts an inspector function that has same arguments as the PackagingStrategy.Validate
func (mmValidate *mPackagingStrategyMockValidate) Inspect(f func(weight float64)) *mPackagingStrategyMockValidate <span class="cov0" title="0">{
        if mmValidate.mock.inspectFuncValidate != nil </span><span class="cov0" title="0">{
                mmValidate.mock.t.Fatalf("Inspect function is already set for PackagingStrategyMock.Validate")
        }</span>

        <span class="cov0" title="0">mmValidate.mock.inspectFuncValidate = f

        return mmValidate</span>
}

// Return sets up results that will be returned by PackagingStrategy.Validate
func (mmValidate *mPackagingStrategyMockValidate) Return(err error) *PackagingStrategyMock <span class="cov0" title="0">{
        if mmValidate.mock.funcValidate != nil </span><span class="cov0" title="0">{
                mmValidate.mock.t.Fatalf("PackagingStrategyMock.Validate mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmValidate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmValidate.defaultExpectation = &amp;PackagingStrategyMockValidateExpectation{mock: mmValidate.mock}
        }</span>
        <span class="cov0" title="0">mmValidate.defaultExpectation.results = &amp;PackagingStrategyMockValidateResults{err}
        mmValidate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmValidate.mock</span>
}

// Set uses given function f to mock the PackagingStrategy.Validate method
func (mmValidate *mPackagingStrategyMockValidate) Set(f func(weight float64) (err error)) *PackagingStrategyMock <span class="cov0" title="0">{
        if mmValidate.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmValidate.mock.t.Fatalf("Default expectation is already set for the PackagingStrategy.Validate method")
        }</span>

        <span class="cov0" title="0">if len(mmValidate.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmValidate.mock.t.Fatalf("Some expectations are already set for the PackagingStrategy.Validate method")
        }</span>

        <span class="cov0" title="0">mmValidate.mock.funcValidate = f
        mmValidate.mock.funcValidateOrigin = minimock.CallerInfo(1)
        return mmValidate.mock</span>
}

// When sets expectation for the PackagingStrategy.Validate which will trigger the result defined by the following
// Then helper
func (mmValidate *mPackagingStrategyMockValidate) When(weight float64) *PackagingStrategyMockValidateExpectation <span class="cov0" title="0">{
        if mmValidate.mock.funcValidate != nil </span><span class="cov0" title="0">{
                mmValidate.mock.t.Fatalf("PackagingStrategyMock.Validate mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;PackagingStrategyMockValidateExpectation{
                mock:               mmValidate.mock,
                params:             &amp;PackagingStrategyMockValidateParams{weight},
                expectationOrigins: PackagingStrategyMockValidateExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmValidate.expectations = append(mmValidate.expectations, expectation)
        return expectation</span>
}

// Then sets up PackagingStrategy.Validate return parameters for the expectation previously defined by the When method
func (e *PackagingStrategyMockValidateExpectation) Then(err error) *PackagingStrategyMock <span class="cov0" title="0">{
        e.results = &amp;PackagingStrategyMockValidateResults{err}
        return e.mock
}</span>

// Times sets number of times PackagingStrategy.Validate should be invoked
func (mmValidate *mPackagingStrategyMockValidate) Times(n uint64) *mPackagingStrategyMockValidate <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmValidate.mock.t.Fatalf("Times of PackagingStrategyMock.Validate mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmValidate.expectedInvocations, n)
        mmValidate.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmValidate</span>
}

func (mmValidate *mPackagingStrategyMockValidate) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmValidate.expectations) == 0 &amp;&amp; mmValidate.defaultExpectation == nil &amp;&amp; mmValidate.mock.funcValidate == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmValidate.mock.afterValidateCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmValidate.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Validate implements mm_packaging.PackagingStrategy
func (mmValidate *PackagingStrategyMock) Validate(weight float64) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmValidate.beforeValidateCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmValidate.afterValidateCounter, 1)

        mmValidate.t.Helper()

        if mmValidate.inspectFuncValidate != nil </span><span class="cov0" title="0">{
                mmValidate.inspectFuncValidate(weight)
        }</span>

        <span class="cov0" title="0">mm_params := PackagingStrategyMockValidateParams{weight}

        // Record call args
        mmValidate.ValidateMock.mutex.Lock()
        mmValidate.ValidateMock.callArgs = append(mmValidate.ValidateMock.callArgs, &amp;mm_params)
        mmValidate.ValidateMock.mutex.Unlock()

        for _, e := range mmValidate.ValidateMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmValidate.ValidateMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmValidate.ValidateMock.defaultExpectation.Counter, 1)
                mm_want := mmValidate.ValidateMock.defaultExpectation.params
                mm_want_ptrs := mmValidate.ValidateMock.defaultExpectation.paramPtrs

                mm_got := PackagingStrategyMockValidateParams{weight}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.weight != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.weight, mm_got.weight) </span><span class="cov0" title="0">{
                                mmValidate.t.Errorf("PackagingStrategyMock.Validate got unexpected parameter weight, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmValidate.ValidateMock.defaultExpectation.expectationOrigins.originWeight, *mm_want_ptrs.weight, mm_got.weight, minimock.Diff(*mm_want_ptrs.weight, mm_got.weight))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmValidate.t.Errorf("PackagingStrategyMock.Validate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmValidate.ValidateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmValidate.ValidateMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmValidate.t.Fatal("No results are set for the PackagingStrategyMock.Validate")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmValidate.funcValidate != nil </span><span class="cov0" title="0">{
                return mmValidate.funcValidate(weight)
        }</span>
        <span class="cov0" title="0">mmValidate.t.Fatalf("Unexpected call to PackagingStrategyMock.Validate. %v", weight)
        return</span>
}

// ValidateAfterCounter returns a count of finished PackagingStrategyMock.Validate invocations
func (mmValidate *PackagingStrategyMock) ValidateAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmValidate.afterValidateCounter)
}</span>

// ValidateBeforeCounter returns a count of PackagingStrategyMock.Validate invocations
func (mmValidate *PackagingStrategyMock) ValidateBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmValidate.beforeValidateCounter)
}</span>

// Calls returns a list of arguments used in each call to PackagingStrategyMock.Validate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidate *mPackagingStrategyMockValidate) Calls() []*PackagingStrategyMockValidateParams <span class="cov0" title="0">{
        mmValidate.mutex.RLock()

        argCopy := make([]*PackagingStrategyMockValidateParams, len(mmValidate.callArgs))
        copy(argCopy, mmValidate.callArgs)

        mmValidate.mutex.RUnlock()

        return argCopy
}</span>

// MinimockValidateDone returns true if the count of the Validate invocations corresponds
// the number of defined expectations
func (m *PackagingStrategyMock) MinimockValidateDone() bool <span class="cov0" title="0">{
        if m.ValidateMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.ValidateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.ValidateMock.invocationsDone()</span>
}

// MinimockValidateInspect logs each unmet expectation
func (m *PackagingStrategyMock) MinimockValidateInspect() <span class="cov0" title="0">{
        for _, e := range m.ValidateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to PackagingStrategyMock.Validate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterValidateCounter := mm_atomic.LoadUint64(&amp;m.afterValidateCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ValidateMock.defaultExpectation != nil &amp;&amp; afterValidateCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.ValidateMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to PackagingStrategyMock.Validate at\n%s", m.ValidateMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to PackagingStrategyMock.Validate at\n%s with params: %#v", m.ValidateMock.defaultExpectation.expectationOrigins.origin, *m.ValidateMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcValidate != nil &amp;&amp; afterValidateCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to PackagingStrategyMock.Validate at\n%s", m.funcValidateOrigin)
        }</span>

        <span class="cov0" title="0">if !m.ValidateMock.invocationsDone() &amp;&amp; afterValidateCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to PackagingStrategyMock.Validate at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ValidateMock.expectedInvocations), m.ValidateMock.expectedInvocationsOrigin, afterValidateCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PackagingStrategyMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockSurchargeInspect()

                        m.MinimockValidateInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PackagingStrategyMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *PackagingStrategyMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockSurchargeDone() &amp;&amp;
                m.MinimockValidateDone()
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i pvz-cli/internal/usecase/packaging.Provider -o provider_mock.go -n ProviderMock -p mock

import (
        "pvz-cli/internal/domain/models"
        mm_packaging "pvz-cli/internal/usecase/packaging"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
)

// ProviderMock implements mm_packaging.Provider
type ProviderMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcStrategy          func(p1 models.PackageType) (p2 mm_packaging.PackagingStrategy, err error)
        funcStrategyOrigin    string
        inspectFuncStrategy   func(p1 models.PackageType)
        afterStrategyCounter  uint64
        beforeStrategyCounter uint64
        StrategyMock          mProviderMockStrategy
}

// NewProviderMock returns a mock for mm_packaging.Provider
func NewProviderMock(t minimock.Tester) *ProviderMock <span class="cov0" title="0">{
        m := &amp;ProviderMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.StrategyMock = mProviderMockStrategy{mock: m}
        m.StrategyMock.callArgs = []*ProviderMockStrategyParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mProviderMockStrategy struct {
        optional           bool
        mock               *ProviderMock
        defaultExpectation *ProviderMockStrategyExpectation
        expectations       []*ProviderMockStrategyExpectation

        callArgs []*ProviderMockStrategyParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ProviderMockStrategyExpectation specifies expectation struct of the Provider.Strategy
type ProviderMockStrategyExpectation struct {
        mock               *ProviderMock
        params             *ProviderMockStrategyParams
        paramPtrs          *ProviderMockStrategyParamPtrs
        expectationOrigins ProviderMockStrategyExpectationOrigins
        results            *ProviderMockStrategyResults
        returnOrigin       string
        Counter            uint64
}

// ProviderMockStrategyParams contains parameters of the Provider.Strategy
type ProviderMockStrategyParams struct {
        p1 models.PackageType
}

// ProviderMockStrategyParamPtrs contains pointers to parameters of the Provider.Strategy
type ProviderMockStrategyParamPtrs struct {
        p1 *models.PackageType
}

// ProviderMockStrategyResults contains results of the Provider.Strategy
type ProviderMockStrategyResults struct {
        p2  mm_packaging.PackagingStrategy
        err error
}

// ProviderMockStrategyOrigins contains origins of expectations of the Provider.Strategy
type ProviderMockStrategyExpectationOrigins struct {
        origin   string
        originP1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStrategy *mProviderMockStrategy) Optional() *mProviderMockStrategy <span class="cov0" title="0">{
        mmStrategy.optional = true
        return mmStrategy
}</span>

// Expect sets up expected params for Provider.Strategy
func (mmStrategy *mProviderMockStrategy) Expect(p1 models.PackageType) *mProviderMockStrategy <span class="cov0" title="0">{
        if mmStrategy.mock.funcStrategy != nil </span><span class="cov0" title="0">{
                mmStrategy.mock.t.Fatalf("ProviderMock.Strategy mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmStrategy.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmStrategy.defaultExpectation = &amp;ProviderMockStrategyExpectation{}
        }</span>

        <span class="cov0" title="0">if mmStrategy.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmStrategy.mock.t.Fatalf("ProviderMock.Strategy mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmStrategy.defaultExpectation.params = &amp;ProviderMockStrategyParams{p1}
        mmStrategy.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmStrategy.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmStrategy.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmStrategy.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStrategy.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmStrategy</span>
}

// ExpectP1Param1 sets up expected param p1 for Provider.Strategy
func (mmStrategy *mProviderMockStrategy) ExpectP1Param1(p1 models.PackageType) *mProviderMockStrategy <span class="cov0" title="0">{
        if mmStrategy.mock.funcStrategy != nil </span><span class="cov0" title="0">{
                mmStrategy.mock.t.Fatalf("ProviderMock.Strategy mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmStrategy.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmStrategy.defaultExpectation = &amp;ProviderMockStrategyExpectation{}
        }</span>

        <span class="cov0" title="0">if mmStrategy.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmStrategy.mock.t.Fatalf("ProviderMock.Strategy mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmStrategy.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmStrategy.defaultExpectation.paramPtrs = &amp;ProviderMockStrategyParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmStrategy.defaultExpectation.paramPtrs.p1 = &amp;p1
        mmStrategy.defaultExpectation.expectationOrigins.originP1 = minimock.CallerInfo(1)

        return mmStrategy</span>
}

// Inspect accepts an inspector function that has same arguments as the Provider.Strategy
func (mmStrategy *mProviderMockStrategy) Inspect(f func(p1 models.PackageType)) *mProviderMockStrategy <span class="cov0" title="0">{
        if mmStrategy.mock.inspectFuncStrategy != nil </span><span class="cov0" title="0">{
                mmStrategy.mock.t.Fatalf("Inspect function is already set for ProviderMock.Strategy")
        }</span>

        <span class="cov0" title="0">mmStrategy.mock.inspectFuncStrategy = f

        return mmStrategy</span>
}

// Return sets up results that will be returned by Provider.Strategy
func (mmStrategy *mProviderMockStrategy) Return(p2 mm_packaging.PackagingStrategy, err error) *ProviderMock <span class="cov0" title="0">{
        if mmStrategy.mock.funcStrategy != nil </span><span class="cov0" title="0">{
                mmStrategy.mock.t.Fatalf("ProviderMock.Strategy mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmStrategy.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmStrategy.defaultExpectation = &amp;ProviderMockStrategyExpectation{mock: mmStrategy.mock}
        }</span>
        <span class="cov0" title="0">mmStrategy.defaultExpectation.results = &amp;ProviderMockStrategyResults{p2, err}
        mmStrategy.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmStrategy.mock</span>
}

// Set uses given function f to mock the Provider.Strategy method
func (mmStrategy *mProviderMockStrategy) Set(f func(p1 models.PackageType) (p2 mm_packaging.PackagingStrategy, err error)) *ProviderMock <span class="cov0" title="0">{
        if mmStrategy.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmStrategy.mock.t.Fatalf("Default expectation is already set for the Provider.Strategy method")
        }</span>

        <span class="cov0" title="0">if len(mmStrategy.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmStrategy.mock.t.Fatalf("Some expectations are already set for the Provider.Strategy method")
        }</span>

        <span class="cov0" title="0">mmStrategy.mock.funcStrategy = f
        mmStrategy.mock.funcStrategyOrigin = minimock.CallerInfo(1)
        return mmStrategy.mock</span>
}

// When sets expectation for the Provider.Strategy which will trigger the result defined by the following
// Then helper
func (mmStrategy *mProviderMockStrategy) When(p1 models.PackageType) *ProviderMockStrategyExpectation <span class="cov0" title="0">{
        if mmStrategy.mock.funcStrategy != nil </span><span class="cov0" title="0">{
                mmStrategy.mock.t.Fatalf("ProviderMock.Strategy mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;ProviderMockStrategyExpectation{
                mock:               mmStrategy.mock,
                params:             &amp;ProviderMockStrategyParams{p1},
                expectationOrigins: ProviderMockStrategyExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmStrategy.expectations = append(mmStrategy.expectations, expectation)
        return expectation</span>
}

// Then sets up Provider.Strategy return parameters for the expectation previously defined by the When method
func (e *ProviderMockStrategyExpectation) Then(p2 mm_packaging.PackagingStrategy, err error) *ProviderMock <span class="cov0" title="0">{
        e.results = &amp;ProviderMockStrategyResults{p2, err}
        return e.mock
}</span>

// Times sets number of times Provider.Strategy should be invoked
func (mmStrategy *mProviderMockStrategy) Times(n uint64) *mProviderMockStrategy <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmStrategy.mock.t.Fatalf("Times of ProviderMock.Strategy mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmStrategy.expectedInvocations, n)
        mmStrategy.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmStrategy</span>
}

func (mmStrategy *mProviderMockStrategy) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmStrategy.expectations) == 0 &amp;&amp; mmStrategy.defaultExpectation == nil &amp;&amp; mmStrategy.mock.funcStrategy == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmStrategy.mock.afterStrategyCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmStrategy.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Strategy implements mm_packaging.Provider
func (mmStrategy *ProviderMock) Strategy(p1 models.PackageType) (p2 mm_packaging.PackagingStrategy, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmStrategy.beforeStrategyCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmStrategy.afterStrategyCounter, 1)

        mmStrategy.t.Helper()

        if mmStrategy.inspectFuncStrategy != nil </span><span class="cov0" title="0">{
                mmStrategy.inspectFuncStrategy(p1)
        }</span>

        <span class="cov0" title="0">mm_params := ProviderMockStrategyParams{p1}

        // Record call args
        mmStrategy.StrategyMock.mutex.Lock()
        mmStrategy.StrategyMock.callArgs = append(mmStrategy.StrategyMock.callArgs, &amp;mm_params)
        mmStrategy.StrategyMock.mutex.Unlock()

        for _, e := range mmStrategy.StrategyMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.p2, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmStrategy.StrategyMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmStrategy.StrategyMock.defaultExpectation.Counter, 1)
                mm_want := mmStrategy.StrategyMock.defaultExpectation.params
                mm_want_ptrs := mmStrategy.StrategyMock.defaultExpectation.paramPtrs

                mm_got := ProviderMockStrategyParams{p1}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.p1 != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.p1, mm_got.p1) </span><span class="cov0" title="0">{
                                mmStrategy.t.Errorf("ProviderMock.Strategy got unexpected parameter p1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmStrategy.StrategyMock.defaultExpectation.expectationOrigins.originP1, *mm_want_ptrs.p1, mm_got.p1, minimock.Diff(*mm_want_ptrs.p1, mm_got.p1))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmStrategy.t.Errorf("ProviderMock.Strategy got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmStrategy.StrategyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmStrategy.StrategyMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmStrategy.t.Fatal("No results are set for the ProviderMock.Strategy")
                }</span>
                <span class="cov0" title="0">return (*mm_results).p2, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmStrategy.funcStrategy != nil </span><span class="cov0" title="0">{
                return mmStrategy.funcStrategy(p1)
        }</span>
        <span class="cov0" title="0">mmStrategy.t.Fatalf("Unexpected call to ProviderMock.Strategy. %v", p1)
        return</span>
}

// StrategyAfterCounter returns a count of finished ProviderMock.Strategy invocations
func (mmStrategy *ProviderMock) StrategyAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmStrategy.afterStrategyCounter)
}</span>

// StrategyBeforeCounter returns a count of ProviderMock.Strategy invocations
func (mmStrategy *ProviderMock) StrategyBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmStrategy.beforeStrategyCounter)
}</span>

// Calls returns a list of arguments used in each call to ProviderMock.Strategy.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStrategy *mProviderMockStrategy) Calls() []*ProviderMockStrategyParams <span class="cov0" title="0">{
        mmStrategy.mutex.RLock()

        argCopy := make([]*ProviderMockStrategyParams, len(mmStrategy.callArgs))
        copy(argCopy, mmStrategy.callArgs)

        mmStrategy.mutex.RUnlock()

        return argCopy
}</span>

// MinimockStrategyDone returns true if the count of the Strategy invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockStrategyDone() bool <span class="cov0" title="0">{
        if m.StrategyMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.StrategyMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.StrategyMock.invocationsDone()</span>
}

// MinimockStrategyInspect logs each unmet expectation
func (m *ProviderMock) MinimockStrategyInspect() <span class="cov0" title="0">{
        for _, e := range m.StrategyMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ProviderMock.Strategy at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterStrategyCounter := mm_atomic.LoadUint64(&amp;m.afterStrategyCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.StrategyMock.defaultExpectation != nil &amp;&amp; afterStrategyCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.StrategyMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ProviderMock.Strategy at\n%s", m.StrategyMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to ProviderMock.Strategy at\n%s with params: %#v", m.StrategyMock.defaultExpectation.expectationOrigins.origin, *m.StrategyMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcStrategy != nil &amp;&amp; afterStrategyCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ProviderMock.Strategy at\n%s", m.funcStrategyOrigin)
        }</span>

        <span class="cov0" title="0">if !m.StrategyMock.invocationsDone() &amp;&amp; afterStrategyCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ProviderMock.Strategy at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.StrategyMock.expectedInvocations), m.StrategyMock.expectedInvocationsOrigin, afterStrategyCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ProviderMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockStrategyInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ProviderMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *ProviderMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockStrategyDone()
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package packaging

import (
        "pvz-cli/internal/domain/codes"
        "pvz-cli/internal/domain/models"
        "sync"
)

type Provider interface {
        Strategy(models.PackageType) (PackagingStrategy, error)
}

type defaultProvider struct {
        mu   sync.RWMutex
        regs map[models.PackageType]PackagingStrategy
}

func NewDefaultProvider() Provider <span class="cov8" title="1">{
        return &amp;defaultProvider{
                regs: map[models.PackageType]PackagingStrategy{
                        models.PackageNone:    NewCompositeStrategy(),
                        models.PackageBag:     NewBagStrategy(),
                        models.PackageBox:     NewBoxStrategy(),
                        models.PackageFilm:    NewFilmStrategy(),
                        models.PackageBagFilm: NewCompositeStrategy(NewBagStrategy(), NewFilmStrategy()),
                        models.PackageBoxFilm: NewCompositeStrategy(NewBoxStrategy(), NewFilmStrategy()),
                },
        }
}</span>

func (p *defaultProvider) Strategy(t models.PackageType) (PackagingStrategy, error) <span class="cov8" title="1">{
        p.mu.RLock()
        strat, ok := p.regs[t]
        p.mu.RUnlock()
        if !ok </span><span class="cov8" title="1">{
                return nil, codes.ErrInvalidPackage
        }</span>
        <span class="cov8" title="1">return strat, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package service

import (
        "context"
        "pvz-cli/internal/domain/models"
        "pvz-cli/pkg/errs"
        "pvz-cli/pkg/txmanager"
        "time"
)

func (s *ServiceImpl) AcceptOrder(
        ctx context.Context,
        orderID, userID string,
        exp time.Time,
        weight float64,
        price models.PriceKopecks,
        pkgType models.PackageType,
) (models.PriceKopecks, error) <span class="cov8" title="1">{
        // валидация входных данных
        if err := validateAccept(orderID, userID, exp, weight); err != nil </span><span class="cov8" title="1">{
                return 0, errs.Wrap(err, errs.CodeValidationError, "validation failed")
        }</span>

        // расчёт наценки
        <span class="cov8" title="1">strat, err := s.strategies.Strategy(pkgType)
        if err != nil </span><span class="cov8" title="1">{
                return 0, errs.Wrap(err, errs.CodeValidationError, "invalid package type")
        }</span>
        <span class="cov8" title="1">if err := strat.Validate(weight); err != nil </span><span class="cov8" title="1">{
                return 0, errs.Wrap(err, errs.CodeValidationError, "weight validation failed")
        }</span>

        <span class="cov8" title="1">total := price + strat.Surcharge()
        now := time.Now()
        o := &amp;models.Order{
                ID:         orderID,
                UserID:     userID,
                Status:     models.StatusAccepted,
                ExpiresAt:  exp,
                CreatedAt:  now,
                Weight:     weight,
                Price:      price,
                TotalPrice: int64(total),
                Package:    pkgType,
        }

        err = s.tx.WithTx(
                ctx,
                txmanager.IsolationLevelReadCommitted,
                txmanager.AccessModeReadWrite,
                func(txCtx context.Context) error </span><span class="cov8" title="1">{
                        if err := s.ordRepo.Create(txCtx, o); err != nil </span><span class="cov8" title="1">{
                                return errs.Wrap(err, errs.CodeDatabaseError, "failed to create order", "order_id", orderID)
                        }</span>
                        <span class="cov8" title="1">evt := &amp;models.HistoryEvent{
                                OrderID: o.ID,
                                Status:  o.Status,
                                Time:    now,
                        }
                        if err := s.hrRepo.AddHistory(txCtx, evt); err != nil </span><span class="cov8" title="1">{
                                return errs.Wrap(err, errs.CodeDatabaseError, "failed to add history", "order_id", orderID)
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                },
        )
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return 0, errs.Wrap(err, errs.CodeDBTransactionError, "transaction failed", "order_id", orderID)
        }</span>

        <span class="cov8" title="1">return total, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package service

import (
        "context"
        "fmt"
        "pvz-cli/internal/domain/models"
        "pvz-cli/pkg/errs"
        "pvz-cli/pkg/txmanager"

        "github.com/xuri/excelize/v2"
)

func (s *ServiceImpl) generateClientReport(
        ctx context.Context,
        sortBy string,
) ([]*models.ClientReport, error) <span class="cov8" title="1">{

        var allOrders []*models.Order

        errTx := s.tx.WithTx(
                ctx,
                txmanager.IsolationLevelReadCommitted,
                txmanager.AccessModeReadOnly,
                func(txCtx context.Context) error </span><span class="cov8" title="1">{
                        var err error

                        allOrders, err = s.ordRepo.ListAllOrders(txCtx)
                        if err != nil </span><span class="cov8" title="1">{
                                return errs.Wrap(err, errs.CodeDatabaseError,
                                        "list all orders failed")
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                },
        )
        <span class="cov8" title="1">if errTx != nil </span><span class="cov8" title="1">{
                return nil, errs.Wrap(errTx, errs.CodeDBTransactionError,
                        "generate client report tx failed")
        }</span>

        <span class="cov8" title="1">clientsMap := make(map[string]*models.ClientReport)
        aggregateOrders(clientsMap, allOrders)

        reports := make([]*models.ClientReport, 0, len(clientsMap))
        for _, r := range clientsMap </span><span class="cov8" title="1">{
                reports = append(reports, r)
        }</span>

        <span class="cov8" title="1">if err := sortReports(reports, sortBy); err != nil </span><span class="cov8" title="1">{
                return nil, errs.Wrap(err, errs.CodeValidationError,
                        "invalid sort parameter")
        }</span>

        <span class="cov8" title="1">return reports, nil</span>
}

func aggregateOrders(
        clientsMap map[string]*models.ClientReport,
        orders []*models.Order,
) <span class="cov8" title="1">{
        for _, o := range orders </span><span class="cov8" title="1">{
                cr, exists := clientsMap[o.UserID]
                if !exists </span><span class="cov8" title="1">{
                        cr = &amp;models.ClientReport{UserID: o.UserID}
                        clientsMap[o.UserID] = cr
                }</span>
                <span class="cov8" title="1">cr.TotalOrders++
                if o.Status == models.StatusReturned </span><span class="cov8" title="1">{
                        cr.ReturnedOrders++
                }</span> else<span class="cov8" title="1"> {
                        cr.TotalPurchaseSum += o.Price
                }</span>
        }
}

func (s *ServiceImpl) GenerateClientReportByte(ctx context.Context, sortBy string) ([]byte, error) <span class="cov8" title="1">{
        reports, err := s.generateClientReport(ctx, sortBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">f := excelize.NewFile()
        sheet := "ClientsReport"
        f.SetSheetName(f.GetSheetName(0), sheet)

        headers := []string{"UserID", "Total Orders", "Returned Orders", "Total Purchase Sum (₽)"}
        for i, h := range headers </span><span class="cov8" title="1">{
                cell, _ := excelize.CoordinatesToCellName(i+1, 1)
                f.SetCellValue(sheet, cell, h)
        }</span>

        <span class="cov8" title="1">for i, r := range reports </span><span class="cov8" title="1">{
                row := i + 2
                f.SetCellValue(sheet, fmt.Sprintf("A%d", row), r.UserID)
                f.SetCellValue(sheet, fmt.Sprintf("B%d", row), r.TotalOrders)
                f.SetCellValue(sheet, fmt.Sprintf("C%d", row), r.ReturnedOrders)
                f.SetCellValue(sheet, fmt.Sprintf("D%d", row), float64(r.TotalPurchaseSum)/100)
        }</span>

        <span class="cov8" title="1">buf, err := f.WriteToBuffer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package service

import (
        "fmt"
        "pvz-cli/internal/domain/codes"
        "pvz-cli/internal/domain/models"
        "pvz-cli/internal/domain/vo"
        "pvz-cli/pkg/errs"
        "sort"
        "time"
)

func sortReports(reports []*models.ClientReport, sortBy string) error <span class="cov8" title="1">{
        switch sortBy </span>{
        case "orders":<span class="cov8" title="1">
                sort.Slice(reports, func(i, j int) bool </span><span class="cov8" title="1">{
                        if reports[i].TotalOrders != reports[j].TotalOrders </span><span class="cov8" title="1">{
                                return reports[i].TotalOrders &gt; reports[j].TotalOrders
                        }</span>
                        // при равенстве количества заказов сравниваю по UserID
                        <span class="cov8" title="1">return reports[i].UserID &lt; reports[j].UserID</span>
                })
        case "sum":<span class="cov8" title="1">
                sort.Slice(reports, func(i, j int) bool </span><span class="cov8" title="1">{
                        if reports[i].TotalPurchaseSum != reports[j].TotalPurchaseSum </span><span class="cov8" title="1">{
                                return reports[i].TotalPurchaseSum &gt; reports[j].TotalPurchaseSum
                        }</span>
                        // тоже самое по id
                        <span class="cov8" title="1">return reports[i].UserID &lt; reports[j].UserID</span>
                })
        default:<span class="cov8" title="1">
                return fmt.Errorf("invalid sort option: %s", sortBy)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func validateAccept(orderID, userID string, exp time.Time, weight float64) error <span class="cov8" title="1">{
        if orderID == "" </span><span class="cov8" title="1">{
                return codes.ErrValidationFailed
        }</span>
        <span class="cov8" title="1">if userID == "" </span><span class="cov8" title="1">{
                return codes.ErrValidationFailed
        }</span>
        <span class="cov8" title="1">if exp.Before(time.Now()) </span><span class="cov8" title="1">{
                return codes.ErrValidationFailed
        }</span>
        <span class="cov8" title="1">if weight &lt;= 0 </span><span class="cov8" title="1">{
                return codes.ErrValidationFailed
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateReturn(o *models.Order) error <span class="cov8" title="1">{
        if o.Status == models.StatusIssued </span><span class="cov8" title="1">{
                return errs.New(errs.CodeValidationError, "cannot return an issued order", "order_id", o.ID)
        }</span>
        <span class="cov8" title="1">if time.Now().Before(o.ExpiresAt) </span><span class="cov8" title="1">{
                return errs.New(errs.CodeValidationError, "storage period not expired yet", "order_id", o.ID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateIssue(o *models.Order, userID string, now time.Time) error <span class="cov8" title="1">{
        if o.UserID != userID </span><span class="cov8" title="1">{
                return errs.New(errs.CodeValidationError, "order belongs to another user", "order_id", o.ID)
        }</span>
        <span class="cov8" title="1">if o.Status != models.StatusAccepted </span><span class="cov8" title="1">{
                return errs.New(errs.CodeValidationError, "order not in accepted status", "order_id", o.ID)
        }</span>
        <span class="cov8" title="1">if now.After(o.ExpiresAt) </span><span class="cov8" title="1">{
                return errs.New(errs.CodeValidationError, "storage period expired", "order_id", o.ID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateClientReturn(o *models.Order, userID string, now time.Time) error <span class="cov8" title="1">{
        if o.UserID != userID </span><span class="cov8" title="1">{
                return errs.New(errs.CodeValidationError,
                        "order belongs to another user", "order_id", o.ID)
        }</span>
        <span class="cov8" title="1">if o.Status != models.StatusIssued || o.IssuedAt == nil </span><span class="cov8" title="1">{
                return errs.New(errs.CodeValidationError,
                        "order not in issued status", "order_id", o.ID)
        }</span>
        <span class="cov8" title="1">if now.Sub(*o.IssuedAt) &gt; 48*time.Hour </span><span class="cov8" title="1">{
                return errs.New(errs.CodeValidationError,
                        "return window expired (&gt;48h)", "order_id", o.ID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func sortOrders(list []*models.Order) <span class="cov8" title="1">{
        sort.Slice(list, func(i, j int) bool </span><span class="cov8" title="1">{
                if !list[i].CreatedAt.Equal(list[j].CreatedAt) </span><span class="cov8" title="1">{
                        return list[i].CreatedAt.Before(list[j].CreatedAt)
                }</span>
                <span class="cov8" title="1">return list[i].ID &lt; list[j].ID</span>
        })
}

func paginate[T any](list []T, lastN int, pg vo.Pagination) ([]T, int) <span class="cov8" title="1">{
        total := len(list)

        if lastN &gt; 0 &amp;&amp; lastN &lt; total </span><span class="cov8" title="1">{
                return list[total-lastN:], total
        }</span>

        <span class="cov8" title="1">if pg.Page &gt; 0 &amp;&amp; pg.Limit &gt; 0 </span><span class="cov8" title="1">{
                start := (pg.Page - 1) * pg.Limit
                if start &gt;= total </span><span class="cov8" title="1">{
                        return []T{}, total
                }</span>
                <span class="cov8" title="1">end := start + pg.Limit
                if end &gt; total </span><span class="cov8" title="1">{
                        end = total
                }</span>
                <span class="cov8" title="1">return list[start:end], total</span>
        }

        <span class="cov8" title="1">return list, total</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package service

import (
        "context"
        "pvz-cli/internal/domain/models"
        "pvz-cli/pkg/errs"
        "pvz-cli/pkg/txmanager"
        "time"
)

func (s *ServiceImpl) ImportOrders(ctx context.Context, orders []*models.Order) (int, error) <span class="cov8" title="1">{

        if len(orders) == 0 </span><span class="cov8" title="1">{
                return 0, errs.New(errs.CodeValidationError, "empty orders slice")
        }</span>

        <span class="cov8" title="1">errTx := s.tx.WithTx(
                ctx,
                txmanager.IsolationLevelReadCommitted,
                txmanager.AccessModeReadWrite,
                func(txCtx context.Context) error </span><span class="cov8" title="1">{
                        if err := s.ordRepo.ImportMany(txCtx, orders); err != nil </span><span class="cov8" title="1">{
                                return errs.Wrap(err,
                                        errs.CodeDatabaseError, "import many failed")
                        }</span>
                        <span class="cov8" title="1">now := time.Now()
                        for _, o := range orders </span><span class="cov8" title="1">{
                                evt := &amp;models.HistoryEvent{
                                        OrderID: o.ID,
                                        Status:  models.StatusAccepted,
                                        Time:    now,
                                }
                                if err := s.hrRepo.AddHistory(txCtx, evt); err != nil </span><span class="cov8" title="1">{
                                        return errs.Wrap(err, errs.CodeDatabaseError,
                                                "failed to add history for imported order", "order_id", o.ID)
                                }</span>
                        }
                        <span class="cov8" title="1">return nil</span>
                },
        )
        <span class="cov8" title="1">if errTx != nil </span><span class="cov8" title="1">{
                return 0, errs.Wrap(errTx,
                        errs.CodeDBTransactionError, "import orders tx failed")
        }</span>

        <span class="cov8" title="1">return len(orders), nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package service

import (
        "context"
        "pvz-cli/internal/domain/models"
        "pvz-cli/pkg/errs"
        "pvz-cli/pkg/txmanager"
        "time"
)

func (s *ServiceImpl) IssueOrders(ctx context.Context, userID string, ids []string) (map[string]error, error) <span class="cov8" title="1">{
        result := make(map[string]error, len(ids))
        now := time.Now()

        for _, orderID := range ids </span><span class="cov8" title="1">{
                // каждая запись — своя транзакция
                errTx := s.tx.WithTx(
                        ctx,
                        txmanager.IsolationLevelRepeatableRead,
                        txmanager.AccessModeReadWrite,
                        func(txCtx context.Context) error </span><span class="cov8" title="1">{
                                o, err := s.ordRepo.Get(txCtx, orderID)
                                if err != nil </span><span class="cov8" title="1">{
                                        result[orderID] = errs.Wrap(err, errs.CodeRecordNotFound,
                                                "order not found", "order_id", orderID)
                                        return nil // не откатываем всю пачку. Норм? Или лучше "всё или ничего"?
                                }</span>

                                <span class="cov8" title="1">if err := validateIssue(o, userID, now); err != nil </span><span class="cov8" title="1">{
                                        result[orderID] = err
                                        return nil
                                }</span>

                                <span class="cov8" title="1">o.Status = models.StatusIssued
                                o.IssuedAt = &amp;now
                                if err := s.ordRepo.Update(txCtx, o); err != nil </span><span class="cov8" title="1">{
                                        result[orderID] = errs.Wrap(err, errs.CodeDatabaseError,
                                                "failed to update order", "order_id", orderID)
                                        return nil
                                }</span>

                                <span class="cov8" title="1">evt := &amp;models.HistoryEvent{
                                        OrderID: o.ID,
                                        Status:  models.StatusIssued,
                                        Time:    now,
                                }
                                if err := s.hrRepo.AddHistory(txCtx, evt); err != nil </span><span class="cov8" title="1">{
                                        result[orderID] = errs.Wrap(err, errs.CodeDatabaseError,
                                                "failed to add history", "order_id", orderID)
                                        return nil
                                }</span>

                                <span class="cov8" title="1">result[orderID] = nil
                                return nil</span>
                        },
                )

                // системная ошибка транзакции
                <span class="cov8" title="1">if errTx != nil </span><span class="cov8" title="1">{
                        return nil, errs.Wrap(errTx, errs.CodeDBTransactionError,
                                "issue order tx failed", "order_id", orderID)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package service

import (
        "context"
        "pvz-cli/internal/domain/models"
        "pvz-cli/internal/domain/vo"
        "pvz-cli/pkg/errs"
        "pvz-cli/pkg/txmanager"
)

func (s *ServiceImpl) ListOrders(ctx context.Context, userID string, onlyInPVZ bool, lastN int, pg vo.Pagination) ([]*models.Order, int, error) <span class="cov8" title="1">{

        if userID == "" </span><span class="cov8" title="1">{
                return nil, 0, errs.New(errs.CodeValidationError, "empty user id")
        }</span>

        <span class="cov8" title="1">var (
                paged []*models.Order
                total int
        )

        errTx := s.tx.WithTx(
                ctx,
                txmanager.IsolationLevelRepeatableRead,
                txmanager.AccessModeReadOnly,
                func(txCtx context.Context) error </span><span class="cov8" title="1">{

                        // активные заказы
                        active, err := s.ordRepo.ListByUser(
                                txCtx, userID, onlyInPVZ, 0, nil, // nil =&gt; без лимита
                        )
                        if err != nil </span><span class="cov8" title="1">{
                                return errs.Wrap(err, errs.CodeDatabaseError,
                                        "listByUser failed", "user_id", userID)
                        }</span>

                        <span class="cov8" title="1">sortOrders(active)
                        paged, total = paginate(active, lastN, pg)

                        return nil</span>
                },
        )

        <span class="cov8" title="1">if errTx != nil </span><span class="cov8" title="1">{
                return nil, 0, errs.Wrap(errTx, errs.CodeDBTransactionError,
                        "list orders tx failed", "user_id", userID)
        }</span>

        <span class="cov8" title="1">return paged, total, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package service

import (
        "context"
        "pvz-cli/internal/domain/models"
        "pvz-cli/internal/domain/vo"
        "pvz-cli/pkg/errs"
)

func (s *ServiceImpl) ListReturns(
        ctx context.Context,
        pg vo.Pagination,
) ([]*models.ReturnRecord, error) <span class="cov8" title="1">{

        roCtx := s.tx.WithReadOnly(ctx)

        records, err := s.hrRepo.ListReturns(roCtx, pg)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs.Wrap(err,
                        errs.CodeDatabaseError, "list returns failed")
        }</span>
        <span class="cov8" title="1">return records, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package service

import (
        "context"
        "pvz-cli/internal/domain/models"
        "pvz-cli/internal/domain/vo"
        "pvz-cli/pkg/errs"
)

func (s *ServiceImpl) OrderHistory(
        ctx context.Context,
        pg vo.Pagination,
) ([]*models.HistoryEvent, int, error) <span class="cov8" title="1">{

        roCtx := s.tx.WithReadOnly(ctx)

        events, err := s.hrRepo.History(roCtx, pg)
        if err != nil </span><span class="cov8" title="1">{
                return nil, 0, errs.Wrap(err,
                        errs.CodeDatabaseError, "list history failed")
        }</span>
        <span class="cov8" title="1">return events, len(events), nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package service

import (
        "context"
        "pvz-cli/internal/domain/models"
        "pvz-cli/pkg/errs"
        "pvz-cli/pkg/txmanager"
        "time"
)

func (s *ServiceImpl) ReturnOrder(ctx context.Context, orderID string) error <span class="cov8" title="1">{
        if orderID == "" </span><span class="cov8" title="1">{
                return errs.New(errs.CodeValidationError, "empty order id")
        }</span>

        <span class="cov8" title="1">err := s.tx.WithTx(
                ctx,
                txmanager.IsolationLevelRepeatableRead,
                txmanager.AccessModeReadWrite,
                func(txCtx context.Context) error </span><span class="cov8" title="1">{
                        o, err := s.ordRepo.Get(txCtx, orderID)
                        if err != nil </span><span class="cov8" title="1">{
                                return errs.Wrap(err, errs.CodeRecordNotFound, "order not found", "order_id", orderID)
                        }</span>

                        <span class="cov8" title="1">if err := validateReturn(o); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">now := time.Now()

                        rec := &amp;models.ReturnRecord{
                                OrderID:    o.ID,
                                UserID:     o.UserID,
                                ReturnedAt: now,
                        }
                        if err := s.hrRepo.AddReturn(txCtx, rec); err != nil </span><span class="cov8" title="1">{
                                return errs.Wrap(err, errs.CodeDatabaseError, "failed to add return", "order_id", orderID)
                        }</span>

                        <span class="cov8" title="1">evt := &amp;models.HistoryEvent{
                                OrderID: o.ID,
                                Status:  models.StatusReturned,
                                Time:    now,
                        }
                        if err := s.hrRepo.AddHistory(txCtx, evt); err != nil </span><span class="cov8" title="1">{
                                return errs.Wrap(err, errs.CodeDatabaseError, "failed to add history", "order_id", orderID)
                        }</span>

                        <span class="cov8" title="1">o.Status = models.StatusReturned
                        o.ReturnedAt = &amp;now
                        if err := s.ordRepo.Update(txCtx, o); err != nil </span><span class="cov8" title="1">{
                                return errs.Wrap(err, errs.CodeDatabaseError,
                                        "failed to mark order returned", "order_id", orderID)
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                },
        )
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return errs.Wrap(err, errs.CodeDBTransactionError, "return order tx failed", "order_id", orderID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package service

import (
        "context"
        "pvz-cli/internal/domain/models"
        "pvz-cli/pkg/errs"
        "pvz-cli/pkg/txmanager"
        "time"
)

func (s *ServiceImpl) ReturnOrdersByClient(ctx context.Context, userID string, ids []string) (map[string]error, error) <span class="cov8" title="1">{
        result := make(map[string]error, len(ids))
        now := time.Now()

        for _, orderID := range ids </span><span class="cov8" title="1">{
                // отдельная транзакция на каждый заказ
                errTx := s.tx.WithTx(
                        ctx,
                        txmanager.IsolationLevelRepeatableRead,
                        txmanager.AccessModeReadWrite,
                        func(txCtx context.Context) error </span><span class="cov8" title="1">{
                                o, err := s.ordRepo.Get(txCtx, orderID)
                                if err != nil </span><span class="cov8" title="1">{
                                        result[orderID] = errs.Wrap(
                                                err, errs.CodeRecordNotFound,
                                                "order not found", "order_id", orderID,
                                        )
                                        return nil
                                }</span>

                                <span class="cov8" title="1">if err := validateClientReturn(o, userID, now); err != nil </span><span class="cov8" title="1">{
                                        result[orderID] = err
                                        return nil
                                }</span>

                                <span class="cov8" title="1">rec := &amp;models.ReturnRecord{
                                        OrderID:    o.ID,
                                        UserID:     o.UserID,
                                        ReturnedAt: now,
                                }
                                if err := s.hrRepo.AddReturn(txCtx, rec); err != nil </span><span class="cov8" title="1">{
                                        result[orderID] = errs.Wrap(
                                                err, errs.CodeDatabaseError,
                                                "failed to add return record", "order_id", orderID,
                                        )
                                        return nil
                                }</span>

                                <span class="cov8" title="1">o.Status = models.StatusReturned
                                o.ReturnedAt = &amp;now
                                if err := s.ordRepo.Update(txCtx, o); err != nil </span><span class="cov8" title="1">{
                                        result[orderID] = errs.Wrap(
                                                err, errs.CodeDatabaseError,
                                                "failed to mark order returned", "order_id", orderID,
                                        )
                                        return nil
                                }</span>

                                <span class="cov8" title="1">evt := &amp;models.HistoryEvent{
                                        OrderID: o.ID,
                                        Status:  models.StatusReturned,
                                        Time:    now,
                                }
                                if err := s.hrRepo.AddHistory(txCtx, evt); err != nil </span><span class="cov8" title="1">{
                                        result[orderID] = errs.Wrap(
                                                err, errs.CodeDatabaseError,
                                                "failed to add history event", "order_id", orderID,
                                        )
                                        return nil
                                }</span>

                                <span class="cov8" title="1">result[orderID] = nil
                                return nil</span>
                        },
                )

                <span class="cov8" title="1">if errTx != nil </span><span class="cov8" title="1">{
                        return nil, errs.Wrap(
                                errTx, errs.CodeDBTransactionError,
                                "return by client tx failed", "order_id", orderID,
                        )
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Package usecase содержит реализацию бизнес-логики приложения.
package service

import (
        "context"
        "pvz-cli/internal/usecase"
        "pvz-cli/internal/usecase/packaging"
        "pvz-cli/pkg/txmanager"
        "time"

        "pvz-cli/internal/domain/models"
        "pvz-cli/internal/domain/vo"
)

// Service определяет бизнес-логику работы Пункта Выдачи Заказов.
type Service interface {
        // AcceptOrder регистрирует новый заказ и рассчитывает итоговую стоимость с учётом упаковки.
        AcceptOrder(ctx context.Context, orderID, userID string, expires time.Time, weight float64, price models.PriceKopecks, pkgType models.PackageType) (models.PriceKopecks, error)

        // ReturnOrder выполняет возврат заказа по его ID (если срок хранения истёк и не был выдан).
        ReturnOrder(ctx context.Context, orderID string) error

        // IssueOrders выполняет массовую выдачу заказов клиенту.
        IssueOrders(ctx context.Context, userID string, ids []string) (map[string]error, error)

        // ReturnOrdersByClient обрабатывает массовый возврат заказов клиентом в течение 48 часов после выдачи.
        ReturnOrdersByClient(ctx context.Context, userID string, ids []string) (map[string]error, error)

        // ListOrders возвращает заказы клиента: активные и (опционально) возвращённые,
        // с фильтрацией onlyInPVZ, lastN, или обычной пагинацией.
        ListOrders(ctx context.Context, userID string, onlyInPVZ bool, lastN int, pg vo.Pagination) ([]*models.Order, int, error)

        // ListReturns возвращает список возвратов (с пагинацией).
        ListReturns(ctx context.Context, pg vo.Pagination) ([]*models.ReturnRecord, error)

        // OrderHistory возвращает историю событий по заказам (с пагинацией).
        OrderHistory(ctx context.Context, pg vo.Pagination) ([]*models.HistoryEvent, int, error)

        // ImportOrders импортирует пачку заказов в одну транзакцию.
        ImportOrders(ctx context.Context, orders []*models.Order) (int, error)

        // GenerateClientReportByte генерирует .xlsx-отчёт по клиентам.
        GenerateClientReportByte(ctx context.Context, sortBy string) ([]byte, error)
}

type ServiceImpl struct {
        tx         txmanager.TxManager
        ordRepo    usecase.OrdersRepository
        hrRepo     usecase.HistoryAndReturnsRepository
        strategies packaging.Provider
}

func NewService(tx txmanager.TxManager, ordRepo usecase.OrdersRepository, hrRepo usecase.HistoryAndReturnsRepository, prov packaging.Provider) *ServiceImpl <span class="cov8" title="1">{
        return &amp;ServiceImpl{
                tx:         tx,
                ordRepo:    ordRepo,
                hrRepo:     hrRepo,
                strategies: prov,
        }
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">// Package closer предоставляет механизм для регистрации и последовательного
// закрытия ресурсов (соединений, файлов и т.д.) при завершении работы приложения.
package closer

import (
        "context"
        "fmt"
        "strings"
        "sync"
)

// Func представляет функцию завершения, принимающую контекст и возвращающую ошибку в случае неудачного завершения.
type Func func(ctx context.Context) error

// Closer управляет списком функций завершения и обеспечивает их вызов в LIFO-порядке.
type Closer struct {
        mu    sync.Mutex
        funcs []Func
}

// NewCloser создает новый экземпляр Closer.
func NewCloser() *Closer <span class="cov0" title="0">{
        return &amp;Closer{}
}</span>

// Add добавляет функцию завершения в стек Closer.
func (c *Closer) Add(f Func) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.funcs = append(c.funcs, f)
}</span>

// Close вызывает все зарегистрированные функции завершения в обратном порядке.
// Если одна или несколько функций возвращают ошибку, ошибки собираются и возвращаются одной.
// Если контекст истекает до завершения всех функций, возвращается ошибка таймаута.
func (c *Closer) Close(ctx context.Context) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        var (
                msgs    = make([]string, 0, len(c.funcs))
                wg      sync.WaitGroup
                errorCh = make(chan error, len(c.funcs))
                done    = make(chan struct{})
        )

        // We finish in LIFO order
        for i := len(c.funcs) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(f Func) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        if err := f(ctx); err != nil </span><span class="cov0" title="0">{
                                errorCh &lt;- err
                        }</span>
                }(c.funcs[i])
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(done)
                close(errorCh)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                break</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("shutdown timeout: %v", ctx.Err())</span>
        }

        <span class="cov0" title="0">for err := range errorCh </span><span class="cov0" title="0">{
                msgs = append(msgs, fmt.Sprintf("[!] %v", err))
        }</span>

        <span class="cov0" title="0">if len(msgs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "shutdown completed with errors:\n%s",
                        strings.Join(msgs, "\n"),
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Package errs предоставляет расширенную структуру ошибок AppError,
// включающую код, сообщение, исходную ошибку и произвольные поля.
// Поддерживаются обёртки ошибок, соответствующие стандарту Go 1.13 (Unwrap).
package errs

import (
        "fmt"
        "strings"
)

type Field struct {
        Key   string
        Value interface{}
}

type AppError struct {
        Code    string
        Message string
        Err     error
        Fields  []Field
}

func (e *AppError) Error() string <span class="cov0" title="0">{
        var b strings.Builder
        b.WriteString(fmt.Sprintf("code=%s message=%s", e.Code, e.Message))
        for _, f := range e.Fields </span><span class="cov0" title="0">{
                b.WriteString(fmt.Sprintf(" %s=%v", f.Key, f.Value))
        }</span>
        <span class="cov0" title="0">if e.Err != nil </span><span class="cov0" title="0">{
                b.WriteString(fmt.Sprintf(" | cause=%v", e.Err))
        }</span>
        <span class="cov0" title="0">return b.String()</span>
}

func (e *AppError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// New creates an AppError without the "original" error, but with any number of fields
func New(code, message string, args ...interface{}) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                Code:    code,
                Message: message,
                Fields:  parseFields(args...),
        }
}</span>

// Wrap creates an AppError by wrapping an existing error and adding fields
func Wrap(err error, code, message string, args ...interface{}) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                Code:    code,
                Message: message,
                Err:     err,
                Fields:  parseFields(args...),
        }
}</span>

// parseFields is waiting for an even number of args: key, value, key, value, ...
// If odd, the last key drops without value
func parseFields(args ...interface{}) []Field <span class="cov0" title="0">{
        var fs []Field
        for i := 0; i+1 &lt; len(args); i += 2 </span><span class="cov0" title="0">{
                key, ok := args[i].(string)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">fs = append(fs, Field{Key: key, Value: args[i+1]})</span>
        }
        <span class="cov0" title="0">return fs</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package errs

import (
        "encoding/json"
        "errors"
        "net/http"

        "google.golang.org/grpc/codes"
        grpcstatus "google.golang.org/grpc/status"
)

func IsCode(err error, code string) bool <span class="cov0" title="0">{
        for err != nil </span><span class="cov0" title="0">{
                var ae *AppError
                if errors.As(err, &amp;ae) &amp;&amp; ae.Code == code </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">err = errors.Unwrap(err)</span>
        }
        <span class="cov0" title="0">return false</span>
}

// HTTPErrorResponse — the structure of the JSON response for the HTTP API
type HTTPErrorResponse struct {
        Code    string                 `json:"code"`
        Message string                 `json:"message"`
        Fields  map[string]interface{} `json:"fields,omitempty"`
}

func (e *AppError) HTTPStatus() int <span class="cov0" title="0">{
        switch e.Code </span>{
        // 400 Bad Request
        case CodeBadRequest, CodeValidationError, CodeMissingParameter, CodeInvalidParameter,
                CodeParsingError, CodeSerializationError, CodePasswordTooWeak:<span class="cov0" title="0">
                return http.StatusBadRequest</span>

        // 401 Unauthorized
        case CodeUnauthorized, CodeInvalidCredentials, CodeTokenExpired, CodeTokenInvalid,
                CodeOAuthError, CodeJWTError:<span class="cov0" title="0">
                return http.StatusUnauthorized</span>

        // 403 Forbidden
        case CodeForbidden, CodeAccountDisabled, CodeAccountLocked, CodePermissionDenied:<span class="cov0" title="0">
                return http.StatusForbidden</span>

        // 404 Not Found
        case CodeNotFound, CodeRecordNotFound, CodeFileNotFound:<span class="cov0" title="0">
                return http.StatusNotFound</span>

        // 405 Method Not Allowed
        case CodeMethodNotAllowed:<span class="cov0" title="0">
                return http.StatusMethodNotAllowed</span>

        // 409 Conflict
        case CodeConflict, CodeRecordAlreadyExists:<span class="cov0" title="0">
                return http.StatusConflict</span>

        // 413 Payload Too Large
        case CodePayloadTooLarge:<span class="cov0" title="0">
                return http.StatusRequestEntityTooLarge</span>

        // 414 URI Too Long
        case CodeRequestURITooLong:<span class="cov0" title="0">
                return http.StatusRequestURITooLong</span>

        // 415 Unsupported Media Type
        case CodeUnsupportedMediaType:<span class="cov0" title="0">
                return http.StatusUnsupportedMediaType</span>

        // 429 Too Many Requests
        case CodeTooManyRequests:<span class="cov0" title="0">
                return http.StatusTooManyRequests</span>

        // 503 Service Unavailable
        case CodeServiceUnavailable, CodeDependencyFailure, CodeExternalServiceError,
                CodeNetworkError, CodeConnectionError, CodeDNSError, CodeTLSHandshakeError:<span class="cov0" title="0">
                return http.StatusServiceUnavailable</span>

        // 408 Request Timeout
        case CodeTimeout:<span class="cov0" title="0">
                return http.StatusRequestTimeout</span>

        // 402 Payment Required
        case CodePaymentDeclined, CodeInsufficientFunds:<span class="cov0" title="0">
                return http.StatusPaymentRequired</span>

        // 409 Conflict
        case CodeBusinessRuleViolation:<span class="cov0" title="0">
                return http.StatusConflict</span>

        // 423 Locked
        case CodeResourceLocked:<span class="cov0" title="0">
                return http.StatusLocked</span>

        // Default: 500 Internal Server Error
        default:<span class="cov0" title="0">
                return http.StatusInternalServerError</span>
        }
}

// ToHTTPResponseBody returns the JSON-encoded bytes for an HTTPErrorResponse
func (e *AppError) ToHTTPResponseBody() []byte <span class="cov0" title="0">{
        resp := HTTPErrorResponse{
                Code:    e.Code,
                Message: e.Message,
        }
        if len(e.Fields) &gt; 0 </span><span class="cov0" title="0">{
                resp.Fields = make(map[string]interface{}, len(e.Fields))
                for _, f := range e.Fields </span><span class="cov0" title="0">{
                        resp.Fields[f.Key] = f.Value
                }</span>
        }
        <span class="cov0" title="0">data, _ := json.Marshal(resp)
        return data</span>
}

func GrpcError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">var ae *AppError
        if errors.As(err, &amp;ae) </span><span class="cov0" title="0">{
                switch ae.Code </span>{
                case CodeMissingParameter, CodeInvalidParameter:<span class="cov0" title="0">
                        return grpcstatus.Error(codes.InvalidArgument, ae.Message)</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// ErrorCause возвращает текст глубинной ошибки
func ErrorCause(err error) string <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">root := err
        for </span><span class="cov0" title="0">{
                next := errors.Unwrap(root)
                if next == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">root = next</span>
        }

        <span class="cov0" title="0">var ae *AppError
        if errors.As(root, &amp;ae) </span><span class="cov0" title="0">{
                return ae.Message
        }</span>

        <span class="cov0" title="0">return root.Error()</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Package logger provides a flexible, functional-options-based wrapper around Uber's zap logger.
//
// Recommended order of options when calling NewLogger:
// 1. Profile options (sets base config):
//    - WithMode("dev" / "production")
// 2. Core settings (override profile defaults):
//    - WithLevel(zapcore.DebugLevel / InfoLevel / WarnLevel / ErrorLevel / DPanicLevel / PanicLevel / FatalLevel)
//    - WithEncoding("console" / "json")
//    - WithSampling(&amp;zap.SamplingConfig{Initial: int, Thereafter: int}) or WithSampling(nil)
// 3. Output and fields:
//    - WithOutputPaths("stdout", "/path/to/filerepo.log")
//    - WithErrorOutputPaths("stderr", "/path/to/error.log")
//    - WithInitialFields(map[string]interface{}{"service": "my-service"})
// 4. Fine-tuning encoder and metadata:
//    - WithDisableCaller(true / false)
//    - WithDisableStacktrace(true / false)
//    - WithEncoderConfig(func(ec *zapcore.EncoderConfig) { ... })
//    - WithEncoderConfig examples:
//        ec.TimeKey = "timestamp"
//        ec.EncodeTime = zapcore.ISO8601TimeEncoder
//        ec.EncodeLevel = zapcore.CapitalColorLevelEncoder  // for colored levels
//
// Example usage:
// log, err := logger.NewLogger(
//     // 1) Profile
//     logger.WithMode("dev"),
//     // 2) Core settings
//     logger.WithLevel(zapcore.DebugLevel),
//     logger.WithEncoding("console"),
//     logger.WithSampling(&amp;zap.SamplingConfig{Initial:50, Thereafter:100}),
//     // 3) Output and fields
//     logger.WithOutputPaths("stdout", "/var/log/app.log"),
//     logger.WithErrorOutputPaths("stderr"),
//     logger.WithInitialFields(map[string]interface{}{"service":"auth"}),
//     // 4) Fine-tuning
//     logger.WithDisableCaller(false),
//     logger.WithDisableStacktrace(false),
//     logger.WithEncoderConfig(func(ec *zapcore.EncoderConfig) {
//         ec.TimeKey = "ts"
//         ec.EncodeLevel = zapcore.CapitalColorLevelEncoder
//     }),
// )
// if err != nil {
//     panic(err)
// }
// defer log.Sync()

package logger

import (
        "fmt"
        "os"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// Logger defines an abstraction for a structured logger with logging levels.
type Logger interface {
        Debug(msg string, fields ...zap.Field)
        Info(msg string, fields ...zap.Field)
        Warn(msg string, fields ...zap.Field)
        Error(msg string, fields ...zap.Field)
        Fatal(msg string, fields ...zap.Field)
        Debugw(msg string, keysAndValues ...interface{})
        Infow(msg string, keysAndValues ...interface{})
        Warnw(msg string, keysAndValues ...interface{})
        Errorw(msg string, keysAndValues ...interface{})
        Fatalw(msg string, keysAndValues ...interface{})
        Sync()
}

// ZapLogger is an implementation of the Logger interface based on Uber Zap.
type ZapLogger struct {
        logger *zap.Logger
        sugar  *zap.SugaredLogger
}

// Option is the configuration function applied to zap.Config when creating the logger.
type Option func(cfg *zap.Config)

// WithMode sets the logging mode on the zap.Config.
func WithMode(mode string) Option <span class="cov0" title="0">{
        return func(cfg *zap.Config) </span><span class="cov0" title="0">{
                switch mode </span>{
                case "dev", "development":<span class="cov0" title="0">
                        *cfg = zap.NewDevelopmentConfig()
                        cfg.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder</span>

                case "prod", "production":<span class="cov0" title="0">
                        *cfg = zap.NewProductionConfig()
                        cfg.EncoderConfig.EncodeLevel = zapcore.LowercaseLevelEncoder</span>

                default:<span class="cov0" title="0">
                        fmt.Fprintf(os.Stderr,
                                "[logger] warning: unknown mode %q, defaulting to production\n",
                                mode,
                        )</span>
                }

                <span class="cov0" title="0">cfg.EncoderConfig.TimeKey = "timestamp"
                cfg.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder</span>
        }
}

// WithLevel sets the minimum logging level
func WithLevel(l zapcore.Level) Option <span class="cov0" title="0">{
        return func(cfg *zap.Config) </span><span class="cov0" title="0">{
                cfg.Level = zap.NewAtomicLevelAt(l)
        }</span>
}

// WithDisableCaller enables or disables caller annotation
func WithDisableCaller(disable bool) Option <span class="cov0" title="0">{
        return func(cfg *zap.Config) </span><span class="cov0" title="0">{
                cfg.DisableCaller = disable
                if disable </span><span class="cov0" title="0">{
                        cfg.EncoderConfig.CallerKey = ""
                }</span> else<span class="cov0" title="0"> if cfg.EncoderConfig.CallerKey == "" </span><span class="cov0" title="0">{
                        cfg.EncoderConfig.CallerKey = "caller"
                }</span>
        }
}

// WithDisableStacktrace enables or disables automatic stacktrace collection
func WithDisableStacktrace(disable bool) Option <span class="cov0" title="0">{
        return func(cfg *zap.Config) </span><span class="cov0" title="0">{
                cfg.DisableStacktrace = disable
        }</span>
}

// WithSampling sets the sampling policy
func WithSampling(s *zap.SamplingConfig) Option <span class="cov0" title="0">{
        return func(cfg *zap.Config) </span><span class="cov0" title="0">{
                cfg.Sampling = s
        }</span>
}

// WithEncoding selects the encoder: "console" or "json"
func WithEncoding(enc string) Option <span class="cov0" title="0">{
        return func(cfg *zap.Config) </span><span class="cov0" title="0">{
                cfg.Encoding = enc
        }</span>
}

// WithEncoderConfig provides full access to zapcore.EncoderConfig fields
func WithEncoderConfig(f func(ec *zapcore.EncoderConfig)) Option <span class="cov0" title="0">{
        return func(cfg *zap.Config) </span><span class="cov0" title="0">{
                f(&amp;cfg.EncoderConfig)
        }</span>
}

// WithOutputPaths specifies where to write logs (stdout, files, etc.)
func WithOutputPaths(paths ...string) Option <span class="cov0" title="0">{
        return func(cfg *zap.Config) </span><span class="cov0" title="0">{
                cfg.OutputPaths = paths
        }</span>
}

// WithErrorOutputPaths specifies where to write internal logger errors
func WithErrorOutputPaths(paths ...string) Option <span class="cov0" title="0">{
        return func(cfg *zap.Config) </span><span class="cov0" title="0">{
                cfg.ErrorOutputPaths = paths
        }</span>
}

// WithInitialFields adds fields to every log entry
func WithInitialFields(fields map[string]interface{}) Option <span class="cov0" title="0">{
        return func(cfg *zap.Config) </span><span class="cov0" title="0">{
                cfg.InitialFields = fields
        }</span>
}

// NewLogger assembles the zap.Config and constructs the Logger
func NewLogger(opts ...Option) (Logger, error) <span class="cov0" title="0">{
        cfg := zap.NewProductionConfig()

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(&amp;cfg)
        }</span>

        <span class="cov0" title="0">z, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ZapLogger{
                logger: z,
                sugar:  z.Sugar(),
        }, nil</span>
}

func (l *ZapLogger) Debug(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.logger.Debug(msg, fields...)
}</span>

func (l *ZapLogger) Info(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.logger.Info(msg, fields...)
}</span>

func (l *ZapLogger) Warn(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.logger.Warn(msg, fields...)
}</span>

func (l *ZapLogger) Error(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.logger.Error(msg, fields...)
}</span>

func (l *ZapLogger) Fatal(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.logger.Fatal(msg, fields...)
}</span>

func (l *ZapLogger) Debugw(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.sugar.Debugw(msg, keysAndValues...)
}</span>

func (l *ZapLogger) Infow(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.sugar.Infow(msg, keysAndValues...)
}</span>

func (l *ZapLogger) Warnw(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.sugar.Warnw(msg, keysAndValues...)
}</span>

func (l *ZapLogger) Errorw(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.sugar.Errorw(msg, keysAndValues...)
}</span>

func (l *ZapLogger) Fatalw(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.sugar.Fatalw(msg, keysAndValues...)
}</span>

func (l *ZapLogger) Sync() <span class="cov0" title="0">{
        _ = l.logger.Sync()
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v6.30.1
// source: pvz/order_service.proto

package pvzpb

import (
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"

        _ "github.com/envoyproxy/protoc-gen-validate/validate"
        _ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
        _ "google.golang.org/genproto/googleapis/api/annotations"
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type AcceptOrderRequest struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // ID заказа, обязателен, &gt; 0
        OrderId uint64 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
        // ID пользователя, обязателен, &gt; 0
        UserId uint64 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        // Срок хранения, обязателен (будущая дата проверяется бизнес-логикой)
        ExpiresAt *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
        // Тип упаковки — валидный enum (может быть не задан)
        Package *PackageType `protobuf:"varint,4,opt,name=package,proto3,enum=orders.PackageType,oneof" json:"package,omitempty"`
        // Вес &gt; 0 (проверка максимального веса зависит от упаковки и выполняется бизнес-логикой)
        Weight float32 `protobuf:"fixed32,5,opt,name=weight,proto3" json:"weight,omitempty"`
        // Цена &gt; 0 (в рублях, переводится в копейки бизнес-логикой)
        Price         float32 `protobuf:"fixed32,6,opt,name=price,proto3" json:"price,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AcceptOrderRequest) Reset() <span class="cov0" title="0">{
        *x = AcceptOrderRequest{}
        mi := &amp;file_pvz_order_service_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AcceptOrderRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AcceptOrderRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AcceptOrderRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pvz_order_service_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AcceptOrderRequest.ProtoReflect.Descriptor instead.
func (*AcceptOrderRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_service_proto_rawDescGZIP(), []int{0}
}</span>

func (x *AcceptOrderRequest) GetOrderId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *AcceptOrderRequest) GetUserId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *AcceptOrderRequest) GetExpiresAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *AcceptOrderRequest) GetPackage() PackageType <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Package != nil </span><span class="cov0" title="0">{
                return *x.Package
        }</span>
        <span class="cov0" title="0">return PackageType_PACKAGE_TYPE_UNSPECIFIED</span>
}

func (x *AcceptOrderRequest) GetWeight() float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Weight
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *AcceptOrderRequest) GetPrice() float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Price
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type OrderIdRequest struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // ID заказа, обязателен, &gt; 0
        OrderId       uint64 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *OrderIdRequest) Reset() <span class="cov0" title="0">{
        *x = OrderIdRequest{}
        mi := &amp;file_pvz_order_service_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *OrderIdRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrderIdRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrderIdRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pvz_order_service_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrderIdRequest.ProtoReflect.Descriptor instead.
func (*OrderIdRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_service_proto_rawDescGZIP(), []int{1}
}</span>

func (x *OrderIdRequest) GetOrderId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ProcessOrdersRequest struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // ID пользователя, обязателен, &gt; 0
        UserId uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        // Тип действия (ISSUE или RETURN)
        Action ActionType `protobuf:"varint,2,opt,name=action,proto3,enum=orders.ActionType" json:"action,omitempty"`
        // Список ID заказов, каждый &gt; 0, минимум один
        OrderIds      []uint64 `protobuf:"varint,3,rep,packed,name=order_ids,json=orderIds,proto3" json:"order_ids,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ProcessOrdersRequest) Reset() <span class="cov0" title="0">{
        *x = ProcessOrdersRequest{}
        mi := &amp;file_pvz_order_service_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ProcessOrdersRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ProcessOrdersRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ProcessOrdersRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pvz_order_service_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ProcessOrdersRequest.ProtoReflect.Descriptor instead.
func (*ProcessOrdersRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_service_proto_rawDescGZIP(), []int{2}
}</span>

func (x *ProcessOrdersRequest) GetUserId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ProcessOrdersRequest) GetAction() ActionType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Action
        }</span>
        <span class="cov0" title="0">return ActionType_ACTION_TYPE_UNSPECIFIED</span>
}

func (x *ProcessOrdersRequest) GetOrderIds() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderIds
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListOrdersRequest struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Требует user_id &gt; 0
        UserId uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        InPvz  bool   `protobuf:"varint,2,opt,name=in_pvz,json=inPvz,proto3" json:"in_pvz,omitempty"`
        // Если задан last_n, то &gt; 0
        LastN         *uint32     `protobuf:"varint,3,opt,name=last_n,json=lastN,proto3,oneof" json:"last_n,omitempty"`
        Pagination    *Pagination `protobuf:"bytes,4,opt,name=pagination,proto3,oneof" json:"pagination,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListOrdersRequest) Reset() <span class="cov0" title="0">{
        *x = ListOrdersRequest{}
        mi := &amp;file_pvz_order_service_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListOrdersRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListOrdersRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListOrdersRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pvz_order_service_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListOrdersRequest.ProtoReflect.Descriptor instead.
func (*ListOrdersRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_service_proto_rawDescGZIP(), []int{3}
}</span>

func (x *ListOrdersRequest) GetUserId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListOrdersRequest) GetInPvz() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.InPvz
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ListOrdersRequest) GetLastN() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.LastN != nil </span><span class="cov0" title="0">{
                return *x.LastN
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListOrdersRequest) GetPagination() *Pagination <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Pagination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ImportOrdersRequest struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Список заказов, минимум один элемент
        Orders        []*AcceptOrderRequest `protobuf:"bytes,1,rep,name=orders,proto3" json:"orders,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ImportOrdersRequest) Reset() <span class="cov0" title="0">{
        *x = ImportOrdersRequest{}
        mi := &amp;file_pvz_order_service_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ImportOrdersRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ImportOrdersRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ImportOrdersRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pvz_order_service_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ImportOrdersRequest.ProtoReflect.Descriptor instead.
func (*ImportOrdersRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_service_proto_rawDescGZIP(), []int{4}
}</span>

func (x *ImportOrdersRequest) GetOrders() []*AcceptOrderRequest <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Orders
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetHistoryRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Pagination    *Pagination            `protobuf:"bytes,1,opt,name=pagination,proto3,oneof" json:"pagination,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetHistoryRequest) Reset() <span class="cov0" title="0">{
        *x = GetHistoryRequest{}
        mi := &amp;file_pvz_order_service_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetHistoryRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetHistoryRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetHistoryRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pvz_order_service_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetHistoryRequest.ProtoReflect.Descriptor instead.
func (*GetHistoryRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_service_proto_rawDescGZIP(), []int{5}
}</span>

func (x *GetHistoryRequest) GetPagination() *Pagination <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Pagination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type OrderResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Status        OrderStatus            `protobuf:"varint,1,opt,name=status,proto3,enum=orders.OrderStatus" json:"status,omitempty"`
        OrderId       uint64                 `protobuf:"varint,2,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *OrderResponse) Reset() <span class="cov0" title="0">{
        *x = OrderResponse{}
        mi := &amp;file_pvz_order_service_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *OrderResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrderResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrderResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pvz_order_service_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrderResponse.ProtoReflect.Descriptor instead.
func (*OrderResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_service_proto_rawDescGZIP(), []int{6}
}</span>

func (x *OrderResponse) GetStatus() OrderStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return OrderStatus_ORDER_STATUS_UNSPECIFIED</span>
}

func (x *OrderResponse) GetOrderId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ProcessResult struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Processed     []uint64               `protobuf:"varint,1,rep,packed,name=processed,proto3" json:"processed,omitempty"`
        Errors        []uint64               `protobuf:"varint,2,rep,packed,name=errors,proto3" json:"errors,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ProcessResult) Reset() <span class="cov0" title="0">{
        *x = ProcessResult{}
        mi := &amp;file_pvz_order_service_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ProcessResult) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ProcessResult) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ProcessResult) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pvz_order_service_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ProcessResult.ProtoReflect.Descriptor instead.
func (*ProcessResult) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_service_proto_rawDescGZIP(), []int{7}
}</span>

func (x *ProcessResult) GetProcessed() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Processed
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ProcessResult) GetErrors() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type OrdersList struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Orders        []*Order               `protobuf:"bytes,1,rep,name=orders,proto3" json:"orders,omitempty"`
        Total         int32                  `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *OrdersList) Reset() <span class="cov0" title="0">{
        *x = OrdersList{}
        mi := &amp;file_pvz_order_service_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *OrdersList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrdersList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrdersList) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pvz_order_service_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrdersList.ProtoReflect.Descriptor instead.
func (*OrdersList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_service_proto_rawDescGZIP(), []int{8}
}</span>

func (x *OrdersList) GetOrders() []*Order <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Orders
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *OrdersList) GetTotal() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Total
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type OrderHistoryList struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        History       []*OrderHistory        `protobuf:"bytes,1,rep,name=history,proto3" json:"history,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *OrderHistoryList) Reset() <span class="cov0" title="0">{
        *x = OrderHistoryList{}
        mi := &amp;file_pvz_order_service_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *OrderHistoryList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrderHistoryList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrderHistoryList) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pvz_order_service_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrderHistoryList.ProtoReflect.Descriptor instead.
func (*OrderHistoryList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_service_proto_rawDescGZIP(), []int{9}
}</span>

func (x *OrderHistoryList) GetHistory() []*OrderHistory <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.History
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ImportResult struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Imported      int32                  `protobuf:"varint,1,opt,name=imported,proto3" json:"imported,omitempty"`
        Errors        []uint64               `protobuf:"varint,2,rep,packed,name=errors,proto3" json:"errors,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ImportResult) Reset() <span class="cov0" title="0">{
        *x = ImportResult{}
        mi := &amp;file_pvz_order_service_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ImportResult) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ImportResult) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ImportResult) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pvz_order_service_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ImportResult.ProtoReflect.Descriptor instead.
func (*ImportResult) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_service_proto_rawDescGZIP(), []int{10}
}</span>

func (x *ImportResult) GetImported() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Imported
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ImportResult) GetErrors() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Order struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        OrderId       uint64                 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
        UserId        uint64                 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Status        OrderStatus            `protobuf:"varint,3,opt,name=status,proto3,enum=orders.OrderStatus" json:"status,omitempty"`
        ExpiresAt     *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
        Weight        float32                `protobuf:"fixed32,5,opt,name=weight,proto3" json:"weight,omitempty"`
        TotalPrice    float32                `protobuf:"fixed32,6,opt,name=total_price,json=totalPrice,proto3" json:"total_price,omitempty"`
        Package       *PackageType           `protobuf:"varint,7,opt,name=package,proto3,enum=orders.PackageType,oneof" json:"package,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Order) Reset() <span class="cov0" title="0">{
        *x = Order{}
        mi := &amp;file_pvz_order_service_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Order) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Order) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Order) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pvz_order_service_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Order.ProtoReflect.Descriptor instead.
func (*Order) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_service_proto_rawDescGZIP(), []int{11}
}</span>

func (x *Order) GetOrderId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Order) GetUserId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Order) GetStatus() OrderStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return OrderStatus_ORDER_STATUS_UNSPECIFIED</span>
}

func (x *Order) GetExpiresAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Order) GetWeight() float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Weight
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Order) GetTotalPrice() float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalPrice
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Order) GetPackage() PackageType <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Package != nil </span><span class="cov0" title="0">{
                return *x.Package
        }</span>
        <span class="cov0" title="0">return PackageType_PACKAGE_TYPE_UNSPECIFIED</span>
}

type OrderHistory struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        OrderId       uint64                 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
        Status        OrderStatus            `protobuf:"varint,2,opt,name=status,proto3,enum=orders.OrderStatus" json:"status,omitempty"`
        CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *OrderHistory) Reset() <span class="cov0" title="0">{
        *x = OrderHistory{}
        mi := &amp;file_pvz_order_service_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *OrderHistory) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrderHistory) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrderHistory) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pvz_order_service_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrderHistory.ProtoReflect.Descriptor instead.
func (*OrderHistory) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_service_proto_rawDescGZIP(), []int{12}
}</span>

func (x *OrderHistory) GetOrderId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *OrderHistory) GetStatus() OrderStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return OrderStatus_ORDER_STATUS_UNSPECIFIED</span>
}

func (x *OrderHistory) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Pagination struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Page          uint32                 `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty"`
        CountOnPage   uint32                 `protobuf:"varint,2,opt,name=count_on_page,json=countOnPage,proto3" json:"count_on_page,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Pagination) Reset() <span class="cov0" title="0">{
        *x = Pagination{}
        mi := &amp;file_pvz_order_service_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Pagination) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Pagination) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Pagination) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pvz_order_service_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Pagination.ProtoReflect.Descriptor instead.
func (*Pagination) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_service_proto_rawDescGZIP(), []int{13}
}</span>

func (x *Pagination) GetPage() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Page
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Pagination) GetCountOnPage() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CountOnPage
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ListReturnsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Pagination    *Pagination            `protobuf:"bytes,1,opt,name=pagination,proto3,oneof" json:"pagination,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListReturnsRequest) Reset() <span class="cov0" title="0">{
        *x = ListReturnsRequest{}
        mi := &amp;file_pvz_order_service_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListReturnsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListReturnsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListReturnsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pvz_order_service_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListReturnsRequest.ProtoReflect.Descriptor instead.
func (*ListReturnsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_service_proto_rawDescGZIP(), []int{14}
}</span>

func (x *ListReturnsRequest) GetPagination() *Pagination <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Pagination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ReturnsList struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Returns       []*ReturnRecord        `protobuf:"bytes,1,rep,name=returns,proto3" json:"returns,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ReturnsList) Reset() <span class="cov0" title="0">{
        *x = ReturnsList{}
        mi := &amp;file_pvz_order_service_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ReturnsList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ReturnsList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ReturnsList) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pvz_order_service_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ReturnsList.ProtoReflect.Descriptor instead.
func (*ReturnsList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_service_proto_rawDescGZIP(), []int{15}
}</span>

func (x *ReturnsList) GetReturns() []*ReturnRecord <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Returns
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ReturnRecord struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        OrderId       uint64                 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
        UserId        uint64                 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        ReturnedAt    *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=returned_at,json=returnedAt,proto3" json:"returned_at,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ReturnRecord) Reset() <span class="cov0" title="0">{
        *x = ReturnRecord{}
        mi := &amp;file_pvz_order_service_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ReturnRecord) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ReturnRecord) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ReturnRecord) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pvz_order_service_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ReturnRecord.ProtoReflect.Descriptor instead.
func (*ReturnRecord) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_service_proto_rawDescGZIP(), []int{16}
}</span>

func (x *ReturnRecord) GetOrderId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ReturnRecord) GetUserId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ReturnRecord) GetReturnedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReturnedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_pvz_order_service_proto protoreflect.FileDescriptor

const file_pvz_order_service_proto_rawDesc = "" +
        "\n" +
        "\x17pvz/order_service.proto\x12\x06orders\x1a\x15pvz/order_types.proto\x1a\x1cgoogle/api/annotations.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a.protoc-gen-openapiv2/options/annotations.proto\x1a\x17validate/validate.proto\"\xb4\x03\n" +
        "\x12AcceptOrderRequest\x12\"\n" +
        "\border_id\x18\x01 \x01(\x04B\a\xfaB\x042\x02 \x00R\aorderId\x12 \n" +
        "\auser_id\x18\x02 \x01(\x04B\a\xfaB\x042\x02 \x00R\x06userId\x129\n" +
        "\n" +
        "expires_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\texpiresAt\x12&lt;\n" +
        "\apackage\x18\x04 \x01(\x0e2\x13.orders.PackageTypeB\b\xfaB\x05\x82\x01\x02\x10\x01H\x00R\apackage\x88\x01\x01\x12\"\n" +
        "\x06weight\x18\x05 \x01(\x02B\n" +
        "\xfaB\a\n" +
        "\x05%\x00\x00\x00\x00R\x06weight\x12 \n" +
        "\x05price\x18\x06 \x01(\x02B\n" +
        "\xfaB\a\n" +
        "\x05%\x00\x00\x00\x00R\x05price:\x8c\x01\x92A\x88\x01\n" +
        "\x85\x01J\x82\x01{\"order_id\":\"12345\",\"user_id\":\"67890\",\"expires_at\":\"2025-12-31T12:00:00Z\",\"package\":\"PACKAGE_TYPE_BOX\",\"weight\":1.5,\"price\":100.0}B\n" +
        "\n" +
        "\b_package\"Q\n" +
        "\x0eOrderIdRequest\x12\"\n" +
        "\border_id\x18\x01 \x01(\x04B\a\xfaB\x042\x02 \x00R\aorderId:\x1b\x92A\x18\n" +
        "\x16J\x14{\"order_id\":\"12345\"}\"\xec\x01\n" +
        "\x14ProcessOrdersRequest\x12 \n" +
        "\auser_id\x18\x01 \x01(\x04B\a\xfaB\x042\x02 \x00R\x06userId\x124\n" +
        "\x06action\x18\x02 \x01(\x0e2\x12.orders.ActionTypeB\b\xfaB\x05\x82\x01\x02\x10\x01R\x06action\x12+\n" +
        "\torder_ids\x18\x03 \x03(\x04B\x0e\xfaB\v\x92\x01\b\b\x01\"\x042\x02 \x00R\borderIds:O\x92AL\n" +
        "JJH{\"user_id\":\"123\",\"action\":\"ACTION_TYPE_ISSUE\",\"order_ids\":[\"1\",\"2\",\"3\"]}\"\xa3\x02\n" +
        "\x11ListOrdersRequest\x12 \n" +
        "\auser_id\x18\x01 \x01(\x04B\a\xfaB\x042\x02 \x00R\x06userId\x12\x15\n" +
        "\x06in_pvz\x18\x02 \x01(\bR\x05inPvz\x12#\n" +
        "\x06last_n\x18\x03 \x01(\rB\a\xfaB\x04*\x02 \x00H\x00R\x05lastN\x88\x01\x01\x127\n" +
        "\n" +
        "pagination\x18\x04 \x01(\v2\x12.orders.PaginationH\x01R\n" +
        "pagination\x88\x01\x01:]\x92AZ\n" +
        "XJV{\"user_id\":\"123\",\"in_pvz\":true,\"last_n\":10,\"pagination\":{\"page\":1,\"count_on_page\":20}}B\t\n" +
        "\a_last_nB\r\n" +
        "\v_pagination\"\xee\x02\n" +
        "\x13ImportOrdersRequest\x12A\n" +
        "\x06orders\x18\x01 \x03(\v2\x1a.orders.AcceptOrderRequestB\r\xfaB\n" +
        "\x92\x01\a\b\x01\"\x03\x8a\x01\x00R\x06orders:\x93\x02\x92A\x8f\x02\n" +
        "\x8c\x02J\x89\x02{\"orders\":[{\"order_id\":\"100\",\"user_id\":\"200\",\"expires_at\":\"2025-12-15T10:00:00Z\",\"package\":\"PACKAGE_TYPE_BAG\",\"weight\":1.0,\"price\":50.0},{\"order_id\":\"101\",\"user_id\":\"201\",\"expires_at\":\"2025-11-30T15:00:00Z\",\"package\":\"PACKAGE_TYPE_BOX\",\"weight\":2.0,\"price\":150.0}]}\"\x90\x01\n" +
        "\x11GetHistoryRequest\x127\n" +
        "\n" +
        "pagination\x18\x01 \x01(\v2\x12.orders.PaginationH\x00R\n" +
        "pagination\x88\x01\x01:3\x92A0\n" +
        ".J,{\"pagination\":{\"page\":1,\"count_on_page\":50}}B\r\n" +
        "\v_pagination\"\x95\x01\n" +
        "\rOrderResponse\x12+\n" +
        "\x06status\x18\x01 \x01(\x0e2\x13.orders.OrderStatusR\x06status\x12\x19\n" +
        "\border_id\x18\x02 \x01(\x04R\aorderId:&lt;\x92A9\n" +
        "7J5{\"status\":\"ORDER_STATUS_RETURNED\",\"order_id\":\"12345\"}\"t\n" +
        "\rProcessResult\x12\x1c\n" +
        "\tprocessed\x18\x01 \x03(\x04R\tprocessed\x12\x16\n" +
        "\x06errors\x18\x02 \x03(\x04R\x06errors:-\x92A*\n" +
        "(J&amp;{\"processed\":[\"1\",\"2\"],\"errors\":[\"3\"]}\"\x91\x02\n" +
        "\n" +
        "OrdersList\x12%\n" +
        "\x06orders\x18\x01 \x03(\v2\r.orders.OrderR\x06orders\x12\x14\n" +
        "\x05total\x18\x02 \x01(\x05R\x05total:\xc5\x01\x92A\xc1\x01\n" +
        "\xbe\x01J\xbb\x01{\"orders\":[{\"order_id\":\"1\",\"user_id\":\"123\",\"status\":\"ORDER_STATUS_EXPECTS\",\"expires_at\":\"2025-12-05T10:00:00Z\",\"weight\":1.5,\"total_price\":120.0,\"package\":\"PACKAGE_TYPE_BOX\"}],\"total\":100}\"\xae\x01\n" +
        "\x10OrderHistoryList\x12.\n" +
        "\ahistory\x18\x01 \x03(\v2\x14.orders.OrderHistoryR\ahistory:j\x92Ag\n" +
        "eJc{\"history\":[{\"order_id\":\"1\",\"status\":\"ORDER_STATUS_ACCEPTED\",\"created_at\":\"2025-12-03T14:20:00Z\"}]}\"e\n" +
        "\fImportResult\x12\x1a\n" +
        "\bimported\x18\x01 \x01(\x05R\bimported\x12\x16\n" +
        "\x06errors\x18\x02 \x03(\x04R\x06errors:!\x92A\x1e\n" +
        "\x1cJ\x1a{\"imported\":2,\"errors\":[]}\"\xcc\x03\n" +
        "\x05Order\x12\x19\n" +
        "\border_id\x18\x01 \x01(\x04R\aorderId\x12\x17\n" +
        "\auser_id\x18\x02 \x01(\x04R\x06userId\x12+\n" +
        "\x06status\x18\x03 \x01(\x0e2\x13.orders.OrderStatusR\x06status\x129\n" +
        "\n" +
        "expires_at\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\texpiresAt\x12\x16\n" +
        "\x06weight\x18\x05 \x01(\x02R\x06weight\x12\x1f\n" +
        "\vtotal_price\x18\x06 \x01(\x02R\n" +
        "totalPrice\x122\n" +
        "\apackage\x18\a \x01(\x0e2\x13.orders.PackageTypeH\x00R\apackage\x88\x01\x01:\xad\x01\x92A\xa9\x01\n" +
        "\xa6\x01J\xa3\x01{\"order_id\":\"1\",\"user_id\":\"123\",\"status\":\"ORDER_STATUS_ACCEPTED\",\"expires_at\":\"2025-12-05T10:00:00Z\",\"weight\":1.5,\"total_price\":120.0,\"package\":\"PACKAGE_TYPE_BAG\"}B\n" +
        "\n" +
        "\b_package\"\xef\x01\n" +
        "\fOrderHistory\x12\x19\n" +
        "\border_id\x18\x01 \x01(\x04R\aorderId\x12+\n" +
        "\x06status\x18\x02 \x01(\x0e2\x13.orders.OrderStatusR\x06status\x129\n" +
        "\n" +
        "created_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt:\\\x92AY\n" +
        "WJU{\"order_id\":\"1\",\"status\":\"ORDER_STATUS_ACCEPTED\",\"created_at\":\"2025-12-03T14:20:00Z\"}\"j\n" +
        "\n" +
        "Pagination\x12\x12\n" +
        "\x04page\x18\x01 \x01(\rR\x04page\x12\"\n" +
        "\rcount_on_page\x18\x02 \x01(\rR\vcountOnPage:$\x92A!\n" +
        "\x1fJ\x1d{\"page\":1,\"count_on_page\":20}\"\x91\x01\n" +
        "\x12ListReturnsRequest\x127\n" +
        "\n" +
        "pagination\x18\x01 \x01(\v2\x12.orders.PaginationH\x00R\n" +
        "pagination\x88\x01\x01:3\x92A0\n" +
        ".J,{\"pagination\":{\"page\":1,\"count_on_page\":20}}B\r\n" +
        "\v_pagination\"\x99\x01\n" +
        "\vReturnsList\x12.\n" +
        "\areturns\x18\x01 \x03(\v2\x14.orders.ReturnRecordR\areturns:Z\x92AW\n" +
        "UJS{\"returns\":[{\"order_id\":\"1\",\"user_id\":\"123\",\"returned_at\":\"2025-12-01T13:45:00Z\"}]}\"\xcd\x01\n" +
        "\fReturnRecord\x12\x19\n" +
        "\border_id\x18\x01 \x01(\x04R\aorderId\x12\x17\n" +
        "\auser_id\x18\x02 \x01(\x04R\x06userId\x12;\n" +
        "\vreturned_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
        "returnedAt:L\x92AI\n" +
        "GJE{\"order_id\":\"1\",\"user_id\":\"123\",\"returned_at\":\"2025-12-01T13:45:00Z\"}2\xa5\x05\n" +
        "\rOrdersService\x12^\n" +
        "\vAcceptOrder\x12\x1a.orders.AcceptOrderRequest\x1a\x15.orders.OrderResponse\"\x1c\x82\xd3\xe4\x93\x02\x16:\x01*\"\x11/v1/orders/accept\x12b\n" +
        "\vReturnOrder\x12\x16.orders.OrderIdRequest\x1a\x15.orders.OrderResponse\"$\x82\xd3\xe4\x93\x02\x1e\"\x1c/v1/orders/{order_id}/return\x12c\n" +
        "\rProcessOrders\x12\x1c.orders.ProcessOrdersRequest\x1a\x15.orders.ProcessResult\"\x1d\x82\xd3\xe4\x93\x02\x17:\x01*\"\x12/v1/orders/process\x12O\n" +
        "\n" +
        "ListOrders\x12\x19.orders.ListOrdersRequest\x1a\x12.orders.OrdersList\"\x12\x82\xd3\xe4\x93\x02\f\x12\n" +
        "/v1/orders\x12Z\n" +
        "\vListReturns\x12\x1a.orders.ListReturnsRequest\x1a\x13.orders.ReturnsList\"\x1a\x82\xd3\xe4\x93\x02\x14\x12\x12/v1/orders/returns\x12]\n" +
        "\n" +
        "GetHistory\x12\x19.orders.GetHistoryRequest\x1a\x18.orders.OrderHistoryList\"\x1a\x82\xd3\xe4\x93\x02\x14\x12\x12/v1/orders/history\x12_\n" +
        "\fImportOrders\x12\x1b.orders.ImportOrdersRequest\x1a\x14.orders.ImportResult\"\x1c\x82\xd3\xe4\x93\x02\x16:\x01*\"\x11/v1/orders/importB\x8f\x02\x92A\xf8\x01\x12\xbe\x01\n" +
        "\x13Order Pick-Up Point\x12]API для управления процессами Пункта Выдачи Заказов\"C\n" +
        "\fEgor Ponyaev\x12\x1dhttps://github.com/epchamp001\x1a\x14epchamp001@gmail.com2\x031.0\x1a\x0elocalhost:8080*\x01\x012\x10application/json:\x10application/jsonZ\x11api/pkg/pvz;pvzpbb\x06proto3"

var (
        file_pvz_order_service_proto_rawDescOnce sync.Once
        file_pvz_order_service_proto_rawDescData []byte
)

func file_pvz_order_service_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_pvz_order_service_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_pvz_order_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_pvz_order_service_proto_rawDesc), len(file_pvz_order_service_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_pvz_order_service_proto_rawDescData</span>
}

var file_pvz_order_service_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_pvz_order_service_proto_goTypes = []any{
        (*AcceptOrderRequest)(nil),    // 0: orders.AcceptOrderRequest
        (*OrderIdRequest)(nil),        // 1: orders.OrderIdRequest
        (*ProcessOrdersRequest)(nil),  // 2: orders.ProcessOrdersRequest
        (*ListOrdersRequest)(nil),     // 3: orders.ListOrdersRequest
        (*ImportOrdersRequest)(nil),   // 4: orders.ImportOrdersRequest
        (*GetHistoryRequest)(nil),     // 5: orders.GetHistoryRequest
        (*OrderResponse)(nil),         // 6: orders.OrderResponse
        (*ProcessResult)(nil),         // 7: orders.ProcessResult
        (*OrdersList)(nil),            // 8: orders.OrdersList
        (*OrderHistoryList)(nil),      // 9: orders.OrderHistoryList
        (*ImportResult)(nil),          // 10: orders.ImportResult
        (*Order)(nil),                 // 11: orders.Order
        (*OrderHistory)(nil),          // 12: orders.OrderHistory
        (*Pagination)(nil),            // 13: orders.Pagination
        (*ListReturnsRequest)(nil),    // 14: orders.ListReturnsRequest
        (*ReturnsList)(nil),           // 15: orders.ReturnsList
        (*ReturnRecord)(nil),          // 16: orders.ReturnRecord
        (*timestamppb.Timestamp)(nil), // 17: google.protobuf.Timestamp
        (PackageType)(0),              // 18: orders.PackageType
        (ActionType)(0),               // 19: orders.ActionType
        (OrderStatus)(0),              // 20: orders.OrderStatus
}
var file_pvz_order_service_proto_depIdxs = []int32{
        17, // 0: orders.AcceptOrderRequest.expires_at:type_name -&gt; google.protobuf.Timestamp
        18, // 1: orders.AcceptOrderRequest.package:type_name -&gt; orders.PackageType
        19, // 2: orders.ProcessOrdersRequest.action:type_name -&gt; orders.ActionType
        13, // 3: orders.ListOrdersRequest.pagination:type_name -&gt; orders.Pagination
        0,  // 4: orders.ImportOrdersRequest.orders:type_name -&gt; orders.AcceptOrderRequest
        13, // 5: orders.GetHistoryRequest.pagination:type_name -&gt; orders.Pagination
        20, // 6: orders.OrderResponse.status:type_name -&gt; orders.OrderStatus
        11, // 7: orders.OrdersList.orders:type_name -&gt; orders.Order
        12, // 8: orders.OrderHistoryList.history:type_name -&gt; orders.OrderHistory
        20, // 9: orders.Order.status:type_name -&gt; orders.OrderStatus
        17, // 10: orders.Order.expires_at:type_name -&gt; google.protobuf.Timestamp
        18, // 11: orders.Order.package:type_name -&gt; orders.PackageType
        20, // 12: orders.OrderHistory.status:type_name -&gt; orders.OrderStatus
        17, // 13: orders.OrderHistory.created_at:type_name -&gt; google.protobuf.Timestamp
        13, // 14: orders.ListReturnsRequest.pagination:type_name -&gt; orders.Pagination
        16, // 15: orders.ReturnsList.returns:type_name -&gt; orders.ReturnRecord
        17, // 16: orders.ReturnRecord.returned_at:type_name -&gt; google.protobuf.Timestamp
        0,  // 17: orders.OrdersService.AcceptOrder:input_type -&gt; orders.AcceptOrderRequest
        1,  // 18: orders.OrdersService.ReturnOrder:input_type -&gt; orders.OrderIdRequest
        2,  // 19: orders.OrdersService.ProcessOrders:input_type -&gt; orders.ProcessOrdersRequest
        3,  // 20: orders.OrdersService.ListOrders:input_type -&gt; orders.ListOrdersRequest
        14, // 21: orders.OrdersService.ListReturns:input_type -&gt; orders.ListReturnsRequest
        5,  // 22: orders.OrdersService.GetHistory:input_type -&gt; orders.GetHistoryRequest
        4,  // 23: orders.OrdersService.ImportOrders:input_type -&gt; orders.ImportOrdersRequest
        6,  // 24: orders.OrdersService.AcceptOrder:output_type -&gt; orders.OrderResponse
        6,  // 25: orders.OrdersService.ReturnOrder:output_type -&gt; orders.OrderResponse
        7,  // 26: orders.OrdersService.ProcessOrders:output_type -&gt; orders.ProcessResult
        8,  // 27: orders.OrdersService.ListOrders:output_type -&gt; orders.OrdersList
        15, // 28: orders.OrdersService.ListReturns:output_type -&gt; orders.ReturnsList
        9,  // 29: orders.OrdersService.GetHistory:output_type -&gt; orders.OrderHistoryList
        10, // 30: orders.OrdersService.ImportOrders:output_type -&gt; orders.ImportResult
        24, // [24:31] is the sub-list for method output_type
        17, // [17:24] is the sub-list for method input_type
        17, // [17:17] is the sub-list for extension type_name
        17, // [17:17] is the sub-list for extension extendee
        0,  // [0:17] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_pvz_order_service_proto_init() }</span>
func file_pvz_order_service_proto_init() <span class="cov0" title="0">{
        if File_pvz_order_service_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_pvz_order_types_proto_init()
        file_pvz_order_service_proto_msgTypes[0].OneofWrappers = []any{}
        file_pvz_order_service_proto_msgTypes[3].OneofWrappers = []any{}
        file_pvz_order_service_proto_msgTypes[5].OneofWrappers = []any{}
        file_pvz_order_service_proto_msgTypes[11].OneofWrappers = []any{}
        file_pvz_order_service_proto_msgTypes[14].OneofWrappers = []any{}
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_pvz_order_service_proto_rawDesc), len(file_pvz_order_service_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   17,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_pvz_order_service_proto_goTypes,
                DependencyIndexes: file_pvz_order_service_proto_depIdxs,
                MessageInfos:      file_pvz_order_service_proto_msgTypes,
        }.Build()
        File_pvz_order_service_proto = out.File
        file_pvz_order_service_proto_goTypes = nil
        file_pvz_order_service_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: pvz/order_service.proto

/*
Package pvzpb is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package pvzpb

import (
        "context"
        "errors"
        "io"
        "net/http"

        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/v2/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/proto"
)

// Suppress "imported and not used" errors
var (
        _ codes.Code
        _ io.Reader
        _ status.Status
        _ = errors.New
        _ = runtime.String
        _ = utilities.NewDoubleArray
        _ = metadata.Join
)

func request_OrdersService_AcceptOrder_0(ctx context.Context, marshaler runtime.Marshaler, client OrdersServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq AcceptOrderRequest
                metadata runtime.ServerMetadata
        )
        if err := marshaler.NewDecoder(req.Body).Decode(&amp;protoReq); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := client.AcceptOrder(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>
}

func local_request_OrdersService_AcceptOrder_0(ctx context.Context, marshaler runtime.Marshaler, server OrdersServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq AcceptOrderRequest
                metadata runtime.ServerMetadata
        )
        if err := marshaler.NewDecoder(req.Body).Decode(&amp;protoReq); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := server.AcceptOrder(ctx, &amp;protoReq)
        return msg, metadata, err</span>
}

func request_OrdersService_ReturnOrder_0(ctx context.Context, marshaler runtime.Marshaler, client OrdersServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq OrderIdRequest
                metadata runtime.ServerMetadata
                err      error
        )
        io.Copy(io.Discard, req.Body)
        val, ok := pathParams["order_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "order_id")
        }</span>
        <span class="cov0" title="0">protoReq.OrderId, err = runtime.Uint64(val)
        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "order_id", err)
        }</span>
        <span class="cov0" title="0">msg, err := client.ReturnOrder(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>
}

func local_request_OrdersService_ReturnOrder_0(ctx context.Context, marshaler runtime.Marshaler, server OrdersServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq OrderIdRequest
                metadata runtime.ServerMetadata
                err      error
        )
        val, ok := pathParams["order_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "order_id")
        }</span>
        <span class="cov0" title="0">protoReq.OrderId, err = runtime.Uint64(val)
        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "order_id", err)
        }</span>
        <span class="cov0" title="0">msg, err := server.ReturnOrder(ctx, &amp;protoReq)
        return msg, metadata, err</span>
}

func request_OrdersService_ProcessOrders_0(ctx context.Context, marshaler runtime.Marshaler, client OrdersServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq ProcessOrdersRequest
                metadata runtime.ServerMetadata
        )
        if err := marshaler.NewDecoder(req.Body).Decode(&amp;protoReq); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := client.ProcessOrders(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>
}

func local_request_OrdersService_ProcessOrders_0(ctx context.Context, marshaler runtime.Marshaler, server OrdersServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq ProcessOrdersRequest
                metadata runtime.ServerMetadata
        )
        if err := marshaler.NewDecoder(req.Body).Decode(&amp;protoReq); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := server.ProcessOrders(ctx, &amp;protoReq)
        return msg, metadata, err</span>
}

var filter_OrdersService_ListOrders_0 = &amp;utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

func request_OrdersService_ListOrders_0(ctx context.Context, marshaler runtime.Marshaler, client OrdersServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq ListOrdersRequest
                metadata runtime.ServerMetadata
        )
        io.Copy(io.Discard, req.Body)
        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_OrdersService_ListOrders_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := client.ListOrders(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>
}

func local_request_OrdersService_ListOrders_0(ctx context.Context, marshaler runtime.Marshaler, server OrdersServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq ListOrdersRequest
                metadata runtime.ServerMetadata
        )
        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_OrdersService_ListOrders_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := server.ListOrders(ctx, &amp;protoReq)
        return msg, metadata, err</span>
}

var filter_OrdersService_ListReturns_0 = &amp;utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

func request_OrdersService_ListReturns_0(ctx context.Context, marshaler runtime.Marshaler, client OrdersServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq ListReturnsRequest
                metadata runtime.ServerMetadata
        )
        io.Copy(io.Discard, req.Body)
        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_OrdersService_ListReturns_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := client.ListReturns(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>
}

func local_request_OrdersService_ListReturns_0(ctx context.Context, marshaler runtime.Marshaler, server OrdersServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq ListReturnsRequest
                metadata runtime.ServerMetadata
        )
        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_OrdersService_ListReturns_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := server.ListReturns(ctx, &amp;protoReq)
        return msg, metadata, err</span>
}

var filter_OrdersService_GetHistory_0 = &amp;utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

func request_OrdersService_GetHistory_0(ctx context.Context, marshaler runtime.Marshaler, client OrdersServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq GetHistoryRequest
                metadata runtime.ServerMetadata
        )
        io.Copy(io.Discard, req.Body)
        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_OrdersService_GetHistory_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := client.GetHistory(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>
}

func local_request_OrdersService_GetHistory_0(ctx context.Context, marshaler runtime.Marshaler, server OrdersServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq GetHistoryRequest
                metadata runtime.ServerMetadata
        )
        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_OrdersService_GetHistory_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := server.GetHistory(ctx, &amp;protoReq)
        return msg, metadata, err</span>
}

func request_OrdersService_ImportOrders_0(ctx context.Context, marshaler runtime.Marshaler, client OrdersServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq ImportOrdersRequest
                metadata runtime.ServerMetadata
        )
        if err := marshaler.NewDecoder(req.Body).Decode(&amp;protoReq); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := client.ImportOrders(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>
}

func local_request_OrdersService_ImportOrders_0(ctx context.Context, marshaler runtime.Marshaler, server OrdersServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq ImportOrdersRequest
                metadata runtime.ServerMetadata
        )
        if err := marshaler.NewDecoder(req.Body).Decode(&amp;protoReq); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := server.ImportOrders(ctx, &amp;protoReq)
        return msg, metadata, err</span>
}

// RegisterOrdersServiceHandlerServer registers the http handlers for service OrdersService to "mux".
// UnaryRPC     :call OrdersServiceServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterOrdersServiceHandlerFromEndpoint instead.
// GRPC interceptors will not work for this type of registration. To use interceptors, you must use the "runtime.WithMiddlewares" option in the "runtime.NewServeMux" call.
func RegisterOrdersServiceHandlerServer(ctx context.Context, mux *runtime.ServeMux, server OrdersServiceServer) error <span class="cov0" title="0">{
        mux.Handle(http.MethodPost, pattern_OrdersService_AcceptOrder_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateIncomingContext(ctx, mux, req, "/orders.OrdersService/AcceptOrder", runtime.WithHTTPPathPattern("/v1/orders/accept"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_OrdersService_AcceptOrder_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_AcceptOrder_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodPost, pattern_OrdersService_ReturnOrder_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateIncomingContext(ctx, mux, req, "/orders.OrdersService/ReturnOrder", runtime.WithHTTPPathPattern("/v1/orders/{order_id}/return"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_OrdersService_ReturnOrder_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ReturnOrder_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodPost, pattern_OrdersService_ProcessOrders_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateIncomingContext(ctx, mux, req, "/orders.OrdersService/ProcessOrders", runtime.WithHTTPPathPattern("/v1/orders/process"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_OrdersService_ProcessOrders_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ProcessOrders_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodGet, pattern_OrdersService_ListOrders_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateIncomingContext(ctx, mux, req, "/orders.OrdersService/ListOrders", runtime.WithHTTPPathPattern("/v1/orders"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_OrdersService_ListOrders_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ListOrders_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodGet, pattern_OrdersService_ListReturns_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateIncomingContext(ctx, mux, req, "/orders.OrdersService/ListReturns", runtime.WithHTTPPathPattern("/v1/orders/returns"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_OrdersService_ListReturns_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ListReturns_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodGet, pattern_OrdersService_GetHistory_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateIncomingContext(ctx, mux, req, "/orders.OrdersService/GetHistory", runtime.WithHTTPPathPattern("/v1/orders/history"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_OrdersService_GetHistory_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_GetHistory_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodPost, pattern_OrdersService_ImportOrders_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateIncomingContext(ctx, mux, req, "/orders.OrdersService/ImportOrders", runtime.WithHTTPPathPattern("/v1/orders/import"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_OrdersService_ImportOrders_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ImportOrders_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })

        <span class="cov0" title="0">return nil</span>
}

// RegisterOrdersServiceHandlerFromEndpoint is same as RegisterOrdersServiceHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterOrdersServiceHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov0" title="0">{
        conn, err := grpc.NewClient(endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Errorf("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Errorf("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()
        <span class="cov0" title="0">return RegisterOrdersServiceHandler(ctx, mux, conn)</span>
}

// RegisterOrdersServiceHandler registers the http handlers for service OrdersService to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterOrdersServiceHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov0" title="0">{
        return RegisterOrdersServiceHandlerClient(ctx, mux, NewOrdersServiceClient(conn))
}</span>

// RegisterOrdersServiceHandlerClient registers the http handlers for service OrdersService
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "OrdersServiceClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "OrdersServiceClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "OrdersServiceClient" to call the correct interceptors. This client ignores the HTTP middlewares.
func RegisterOrdersServiceHandlerClient(ctx context.Context, mux *runtime.ServeMux, client OrdersServiceClient) error <span class="cov0" title="0">{
        mux.Handle(http.MethodPost, pattern_OrdersService_AcceptOrder_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateContext(ctx, mux, req, "/orders.OrdersService/AcceptOrder", runtime.WithHTTPPathPattern("/v1/orders/accept"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_OrdersService_AcceptOrder_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_AcceptOrder_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodPost, pattern_OrdersService_ReturnOrder_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateContext(ctx, mux, req, "/orders.OrdersService/ReturnOrder", runtime.WithHTTPPathPattern("/v1/orders/{order_id}/return"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_OrdersService_ReturnOrder_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ReturnOrder_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodPost, pattern_OrdersService_ProcessOrders_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateContext(ctx, mux, req, "/orders.OrdersService/ProcessOrders", runtime.WithHTTPPathPattern("/v1/orders/process"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_OrdersService_ProcessOrders_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ProcessOrders_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodGet, pattern_OrdersService_ListOrders_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateContext(ctx, mux, req, "/orders.OrdersService/ListOrders", runtime.WithHTTPPathPattern("/v1/orders"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_OrdersService_ListOrders_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ListOrders_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodGet, pattern_OrdersService_ListReturns_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateContext(ctx, mux, req, "/orders.OrdersService/ListReturns", runtime.WithHTTPPathPattern("/v1/orders/returns"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_OrdersService_ListReturns_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ListReturns_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodGet, pattern_OrdersService_GetHistory_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateContext(ctx, mux, req, "/orders.OrdersService/GetHistory", runtime.WithHTTPPathPattern("/v1/orders/history"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_OrdersService_GetHistory_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_GetHistory_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodPost, pattern_OrdersService_ImportOrders_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateContext(ctx, mux, req, "/orders.OrdersService/ImportOrders", runtime.WithHTTPPathPattern("/v1/orders/import"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_OrdersService_ImportOrders_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ImportOrders_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">return nil</span>
}

var (
        pattern_OrdersService_AcceptOrder_0   = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"v1", "orders", "accept"}, ""))
        pattern_OrdersService_ReturnOrder_0   = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 4, 1, 5, 2, 2, 3}, []string{"v1", "orders", "order_id", "return"}, ""))
        pattern_OrdersService_ProcessOrders_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"v1", "orders", "process"}, ""))
        pattern_OrdersService_ListOrders_0    = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"v1", "orders"}, ""))
        pattern_OrdersService_ListReturns_0   = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"v1", "orders", "returns"}, ""))
        pattern_OrdersService_GetHistory_0    = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"v1", "orders", "history"}, ""))
        pattern_OrdersService_ImportOrders_0  = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"v1", "orders", "import"}, ""))
)

var (
        forward_OrdersService_AcceptOrder_0   = runtime.ForwardResponseMessage
        forward_OrdersService_ReturnOrder_0   = runtime.ForwardResponseMessage
        forward_OrdersService_ProcessOrders_0 = runtime.ForwardResponseMessage
        forward_OrdersService_ListOrders_0    = runtime.ForwardResponseMessage
        forward_OrdersService_ListReturns_0   = runtime.ForwardResponseMessage
        forward_OrdersService_GetHistory_0    = runtime.ForwardResponseMessage
        forward_OrdersService_ImportOrders_0  = runtime.ForwardResponseMessage
)
</pre>
		
		<pre class="file" id="file54" style="display: none">// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pvz/order_service.proto

package pvzpb

import (
        "bytes"
        "errors"
        "fmt"
        "net"
        "net/mail"
        "net/url"
        "regexp"
        "sort"
        "strings"
        "time"
        "unicode/utf8"

        "google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
        _ = bytes.MinRead
        _ = errors.New("")
        _ = fmt.Print
        _ = utf8.UTFMax
        _ = (*regexp.Regexp)(nil)
        _ = (*strings.Reader)(nil)
        _ = net.IPv4len
        _ = time.Duration(0)
        _ = (*url.URL)(nil)
        _ = (*mail.Address)(nil)
        _ = anypb.Any{}
        _ = sort.Sort
)

// Validate checks the field values on AcceptOrderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AcceptOrderRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on AcceptOrderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AcceptOrderRequestMultiError, or nil if none found.
func (m *AcceptOrderRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *AcceptOrderRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if m.GetOrderId() &lt;= 0 </span><span class="cov0" title="0">{
                err := AcceptOrderRequestValidationError{
                        field:  "OrderId",
                        reason: "value must be greater than 0",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if m.GetUserId() &lt;= 0 </span><span class="cov0" title="0">{
                err := AcceptOrderRequestValidationError{
                        field:  "UserId",
                        reason: "value must be greater than 0",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetExpiresAt()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, AcceptOrderRequestValidationError{
                                        field:  "ExpiresAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, AcceptOrderRequestValidationError{
                                        field:  "ExpiresAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetExpiresAt()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return AcceptOrderRequestValidationError{
                                field:  "ExpiresAt",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if m.GetWeight() &lt;= 0 </span><span class="cov0" title="0">{
                err := AcceptOrderRequestValidationError{
                        field:  "Weight",
                        reason: "value must be greater than 0",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if m.GetPrice() &lt;= 0 </span><span class="cov0" title="0">{
                err := AcceptOrderRequestValidationError{
                        field:  "Price",
                        reason: "value must be greater than 0",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if m.Package != nil </span><span class="cov0" title="0">{

                if _, ok := PackageType_name[int32(m.GetPackage())]; !ok </span><span class="cov0" title="0">{
                        err := AcceptOrderRequestValidationError{
                                field:  "Package",
                                reason: "value must be one of the defined enum values",
                        }
                        if !all </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">errors = append(errors, err)</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return AcceptOrderRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AcceptOrderRequestMultiError is an error wrapping multiple validation errors
// returned by AcceptOrderRequest.ValidateAll() if the designated constraints
// aren't met.
type AcceptOrderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AcceptOrderRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m AcceptOrderRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// AcceptOrderRequestValidationError is the validation error returned by
// AcceptOrderRequest.Validate if the designated constraints aren't met.
type AcceptOrderRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e AcceptOrderRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e AcceptOrderRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e AcceptOrderRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e AcceptOrderRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e AcceptOrderRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "AcceptOrderRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e AcceptOrderRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sAcceptOrderRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = AcceptOrderRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = AcceptOrderRequestValidationError{}

// Validate checks the field values on OrderIdRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderIdRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on OrderIdRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderIdRequestMultiError,
// or nil if none found.
func (m *OrderIdRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *OrderIdRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if m.GetOrderId() &lt;= 0 </span><span class="cov0" title="0">{
                err := OrderIdRequestValidationError{
                        field:  "OrderId",
                        reason: "value must be greater than 0",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return OrderIdRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OrderIdRequestMultiError is an error wrapping multiple validation errors
// returned by OrderIdRequest.ValidateAll() if the designated constraints
// aren't met.
type OrderIdRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderIdRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m OrderIdRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// OrderIdRequestValidationError is the validation error returned by
// OrderIdRequest.Validate if the designated constraints aren't met.
type OrderIdRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e OrderIdRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e OrderIdRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e OrderIdRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e OrderIdRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e OrderIdRequestValidationError) ErrorName() string <span class="cov0" title="0">{ return "OrderIdRequestValidationError" }</span>

// Error satisfies the builtin error interface
func (e OrderIdRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sOrderIdRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = OrderIdRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = OrderIdRequestValidationError{}

// Validate checks the field values on ProcessOrdersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProcessOrdersRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ProcessOrdersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProcessOrdersRequestMultiError, or nil if none found.
func (m *ProcessOrdersRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ProcessOrdersRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if m.GetUserId() &lt;= 0 </span><span class="cov0" title="0">{
                err := ProcessOrdersRequestValidationError{
                        field:  "UserId",
                        reason: "value must be greater than 0",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if _, ok := ActionType_name[int32(m.GetAction())]; !ok </span><span class="cov0" title="0">{
                err := ProcessOrdersRequestValidationError{
                        field:  "Action",
                        reason: "value must be one of the defined enum values",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if len(m.GetOrderIds()) &lt; 1 </span><span class="cov0" title="0">{
                err := ProcessOrdersRequestValidationError{
                        field:  "OrderIds",
                        reason: "value must contain at least 1 item(s)",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">for idx, item := range m.GetOrderIds() </span><span class="cov0" title="0">{
                _, _ = idx, item

                if item &lt;= 0 </span><span class="cov0" title="0">{
                        err := ProcessOrdersRequestValidationError{
                                field:  fmt.Sprintf("OrderIds[%v]", idx),
                                reason: "value must be greater than 0",
                        }
                        if !all </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">errors = append(errors, err)</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ProcessOrdersRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ProcessOrdersRequestMultiError is an error wrapping multiple validation
// errors returned by ProcessOrdersRequest.ValidateAll() if the designated
// constraints aren't met.
type ProcessOrdersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessOrdersRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ProcessOrdersRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ProcessOrdersRequestValidationError is the validation error returned by
// ProcessOrdersRequest.Validate if the designated constraints aren't met.
type ProcessOrdersRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ProcessOrdersRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ProcessOrdersRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ProcessOrdersRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ProcessOrdersRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ProcessOrdersRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "ProcessOrdersRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e ProcessOrdersRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sProcessOrdersRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ProcessOrdersRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ProcessOrdersRequestValidationError{}

// Validate checks the field values on ListOrdersRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListOrdersRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ListOrdersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListOrdersRequestMultiError, or nil if none found.
func (m *ListOrdersRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ListOrdersRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if m.GetUserId() &lt;= 0 </span><span class="cov0" title="0">{
                err := ListOrdersRequestValidationError{
                        field:  "UserId",
                        reason: "value must be greater than 0",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        // no validation rules for InPvz

        <span class="cov0" title="0">if m.LastN != nil </span><span class="cov0" title="0">{

                if m.GetLastN() &lt;= 0 </span><span class="cov0" title="0">{
                        err := ListOrdersRequestValidationError{
                                field:  "LastN",
                                reason: "value must be greater than 0",
                        }
                        if !all </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">errors = append(errors, err)</span>
                }

        }

        <span class="cov0" title="0">if m.Pagination != nil </span><span class="cov0" title="0">{

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(m.GetPagination()).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListOrdersRequestValidationError{
                                                field:  "Pagination",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListOrdersRequestValidationError{
                                                field:  "Pagination",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return ListOrdersRequestValidationError{
                                        field:  "Pagination",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ListOrdersRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListOrdersRequestMultiError is an error wrapping multiple validation errors
// returned by ListOrdersRequest.ValidateAll() if the designated constraints
// aren't met.
type ListOrdersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOrdersRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ListOrdersRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ListOrdersRequestValidationError is the validation error returned by
// ListOrdersRequest.Validate if the designated constraints aren't met.
type ListOrdersRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ListOrdersRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ListOrdersRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ListOrdersRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ListOrdersRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ListOrdersRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "ListOrdersRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e ListOrdersRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sListOrdersRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ListOrdersRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ListOrdersRequestValidationError{}

// Validate checks the field values on ImportOrdersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportOrdersRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ImportOrdersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportOrdersRequestMultiError, or nil if none found.
func (m *ImportOrdersRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ImportOrdersRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if len(m.GetOrders()) &lt; 1 </span><span class="cov0" title="0">{
                err := ImportOrdersRequestValidationError{
                        field:  "Orders",
                        reason: "value must contain at least 1 item(s)",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">for idx, item := range m.GetOrders() </span><span class="cov0" title="0">{
                _, _ = idx, item

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(item).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ImportOrdersRequestValidationError{
                                                field:  fmt.Sprintf("Orders[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ImportOrdersRequestValidationError{
                                                field:  fmt.Sprintf("Orders[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(item).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return ImportOrdersRequestValidationError{
                                        field:  fmt.Sprintf("Orders[%v]", idx),
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ImportOrdersRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ImportOrdersRequestMultiError is an error wrapping multiple validation
// errors returned by ImportOrdersRequest.ValidateAll() if the designated
// constraints aren't met.
type ImportOrdersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportOrdersRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ImportOrdersRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ImportOrdersRequestValidationError is the validation error returned by
// ImportOrdersRequest.Validate if the designated constraints aren't met.
type ImportOrdersRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ImportOrdersRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ImportOrdersRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ImportOrdersRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ImportOrdersRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ImportOrdersRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "ImportOrdersRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e ImportOrdersRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sImportOrdersRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ImportOrdersRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ImportOrdersRequestValidationError{}

// Validate checks the field values on GetHistoryRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetHistoryRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on GetHistoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetHistoryRequestMultiError, or nil if none found.
func (m *GetHistoryRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *GetHistoryRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if m.Pagination != nil </span><span class="cov0" title="0">{

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(m.GetPagination()).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, GetHistoryRequestValidationError{
                                                field:  "Pagination",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, GetHistoryRequestValidationError{
                                                field:  "Pagination",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return GetHistoryRequestValidationError{
                                        field:  "Pagination",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return GetHistoryRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetHistoryRequestMultiError is an error wrapping multiple validation errors
// returned by GetHistoryRequest.ValidateAll() if the designated constraints
// aren't met.
type GetHistoryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetHistoryRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m GetHistoryRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// GetHistoryRequestValidationError is the validation error returned by
// GetHistoryRequest.Validate if the designated constraints aren't met.
type GetHistoryRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e GetHistoryRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e GetHistoryRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e GetHistoryRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e GetHistoryRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e GetHistoryRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "GetHistoryRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e GetHistoryRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sGetHistoryRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = GetHistoryRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = GetHistoryRequestValidationError{}

// Validate checks the field values on OrderResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on OrderResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderResponseMultiError, or
// nil if none found.
func (m *OrderResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *OrderResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Status

        // no validation rules for OrderId

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return OrderResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OrderResponseMultiError is an error wrapping multiple validation errors
// returned by OrderResponse.ValidateAll() if the designated constraints
// aren't met.
type OrderResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m OrderResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// OrderResponseValidationError is the validation error returned by
// OrderResponse.Validate if the designated constraints aren't met.
type OrderResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e OrderResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e OrderResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e OrderResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e OrderResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e OrderResponseValidationError) ErrorName() string <span class="cov0" title="0">{ return "OrderResponseValidationError" }</span>

// Error satisfies the builtin error interface
func (e OrderResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sOrderResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = OrderResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = OrderResponseValidationError{}

// Validate checks the field values on ProcessResult with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProcessResult) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ProcessResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProcessResultMultiError, or
// nil if none found.
func (m *ProcessResult) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ProcessResult) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ProcessResultMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ProcessResultMultiError is an error wrapping multiple validation errors
// returned by ProcessResult.ValidateAll() if the designated constraints
// aren't met.
type ProcessResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessResultMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ProcessResultMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ProcessResultValidationError is the validation error returned by
// ProcessResult.Validate if the designated constraints aren't met.
type ProcessResultValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ProcessResultValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ProcessResultValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ProcessResultValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ProcessResultValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ProcessResultValidationError) ErrorName() string <span class="cov0" title="0">{ return "ProcessResultValidationError" }</span>

// Error satisfies the builtin error interface
func (e ProcessResultValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sProcessResult.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ProcessResultValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ProcessResultValidationError{}

// Validate checks the field values on OrdersList with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrdersList) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on OrdersList with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrdersListMultiError, or
// nil if none found.
func (m *OrdersList) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *OrdersList) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        for idx, item := range m.GetOrders() </span><span class="cov0" title="0">{
                _, _ = idx, item

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(item).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, OrdersListValidationError{
                                                field:  fmt.Sprintf("Orders[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, OrdersListValidationError{
                                                field:  fmt.Sprintf("Orders[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(item).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return OrdersListValidationError{
                                        field:  fmt.Sprintf("Orders[%v]", idx),
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        // no validation rules for Total

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return OrdersListMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OrdersListMultiError is an error wrapping multiple validation errors
// returned by OrdersList.ValidateAll() if the designated constraints aren't met.
type OrdersListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrdersListMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m OrdersListMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// OrdersListValidationError is the validation error returned by
// OrdersList.Validate if the designated constraints aren't met.
type OrdersListValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e OrdersListValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e OrdersListValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e OrdersListValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e OrdersListValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e OrdersListValidationError) ErrorName() string <span class="cov0" title="0">{ return "OrdersListValidationError" }</span>

// Error satisfies the builtin error interface
func (e OrdersListValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sOrdersList.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = OrdersListValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = OrdersListValidationError{}

// Validate checks the field values on OrderHistoryList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OrderHistoryList) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on OrderHistoryList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderHistoryListMultiError, or nil if none found.
func (m *OrderHistoryList) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *OrderHistoryList) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        for idx, item := range m.GetHistory() </span><span class="cov0" title="0">{
                _, _ = idx, item

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(item).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, OrderHistoryListValidationError{
                                                field:  fmt.Sprintf("History[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, OrderHistoryListValidationError{
                                                field:  fmt.Sprintf("History[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(item).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return OrderHistoryListValidationError{
                                        field:  fmt.Sprintf("History[%v]", idx),
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return OrderHistoryListMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OrderHistoryListMultiError is an error wrapping multiple validation errors
// returned by OrderHistoryList.ValidateAll() if the designated constraints
// aren't met.
type OrderHistoryListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderHistoryListMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m OrderHistoryListMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// OrderHistoryListValidationError is the validation error returned by
// OrderHistoryList.Validate if the designated constraints aren't met.
type OrderHistoryListValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e OrderHistoryListValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e OrderHistoryListValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e OrderHistoryListValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e OrderHistoryListValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e OrderHistoryListValidationError) ErrorName() string <span class="cov0" title="0">{ return "OrderHistoryListValidationError" }</span>

// Error satisfies the builtin error interface
func (e OrderHistoryListValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sOrderHistoryList.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = OrderHistoryListValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = OrderHistoryListValidationError{}

// Validate checks the field values on ImportResult with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ImportResult) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ImportResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ImportResultMultiError, or
// nil if none found.
func (m *ImportResult) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ImportResult) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Imported

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ImportResultMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ImportResultMultiError is an error wrapping multiple validation errors
// returned by ImportResult.ValidateAll() if the designated constraints aren't met.
type ImportResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportResultMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ImportResultMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ImportResultValidationError is the validation error returned by
// ImportResult.Validate if the designated constraints aren't met.
type ImportResultValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ImportResultValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ImportResultValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ImportResultValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ImportResultValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ImportResultValidationError) ErrorName() string <span class="cov0" title="0">{ return "ImportResultValidationError" }</span>

// Error satisfies the builtin error interface
func (e ImportResultValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sImportResult.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ImportResultValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ImportResultValidationError{}

// Validate checks the field values on Order with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Order) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on Order with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OrderMultiError, or nil if none found.
func (m *Order) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *Order) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for OrderId

        // no validation rules for UserId

        // no validation rules for Status

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetExpiresAt()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, OrderValidationError{
                                        field:  "ExpiresAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, OrderValidationError{
                                        field:  "ExpiresAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetExpiresAt()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return OrderValidationError{
                                field:  "ExpiresAt",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        // no validation rules for Weight

        // no validation rules for TotalPrice

        <span class="cov0" title="0">if m.Package != nil </span>{<span class="cov0" title="0">
                // no validation rules for Package
        }</span>

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return OrderMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OrderMultiError is an error wrapping multiple validation errors returned by
// Order.ValidateAll() if the designated constraints aren't met.
type OrderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m OrderMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// OrderValidationError is the validation error returned by Order.Validate if
// the designated constraints aren't met.
type OrderValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e OrderValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e OrderValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e OrderValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e OrderValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e OrderValidationError) ErrorName() string <span class="cov0" title="0">{ return "OrderValidationError" }</span>

// Error satisfies the builtin error interface
func (e OrderValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sOrder.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = OrderValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = OrderValidationError{}

// Validate checks the field values on OrderHistory with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderHistory) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on OrderHistory with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderHistoryMultiError, or
// nil if none found.
func (m *OrderHistory) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *OrderHistory) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for OrderId

        // no validation rules for Status

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetCreatedAt()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, OrderHistoryValidationError{
                                        field:  "CreatedAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, OrderHistoryValidationError{
                                        field:  "CreatedAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return OrderHistoryValidationError{
                                field:  "CreatedAt",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return OrderHistoryMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OrderHistoryMultiError is an error wrapping multiple validation errors
// returned by OrderHistory.ValidateAll() if the designated constraints aren't met.
type OrderHistoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderHistoryMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m OrderHistoryMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// OrderHistoryValidationError is the validation error returned by
// OrderHistory.Validate if the designated constraints aren't met.
type OrderHistoryValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e OrderHistoryValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e OrderHistoryValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e OrderHistoryValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e OrderHistoryValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e OrderHistoryValidationError) ErrorName() string <span class="cov0" title="0">{ return "OrderHistoryValidationError" }</span>

// Error satisfies the builtin error interface
func (e OrderHistoryValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sOrderHistory.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = OrderHistoryValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = OrderHistoryValidationError{}

// Validate checks the field values on Pagination with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Pagination) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on Pagination with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PaginationMultiError, or
// nil if none found.
func (m *Pagination) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *Pagination) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Page

        // no validation rules for CountOnPage

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return PaginationMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PaginationMultiError is an error wrapping multiple validation errors
// returned by Pagination.ValidateAll() if the designated constraints aren't met.
type PaginationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaginationMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m PaginationMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// PaginationValidationError is the validation error returned by
// Pagination.Validate if the designated constraints aren't met.
type PaginationValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e PaginationValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e PaginationValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e PaginationValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e PaginationValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e PaginationValidationError) ErrorName() string <span class="cov0" title="0">{ return "PaginationValidationError" }</span>

// Error satisfies the builtin error interface
func (e PaginationValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sPagination.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = PaginationValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = PaginationValidationError{}

// Validate checks the field values on ListReturnsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListReturnsRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ListReturnsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListReturnsRequestMultiError, or nil if none found.
func (m *ListReturnsRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ListReturnsRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if m.Pagination != nil </span><span class="cov0" title="0">{

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(m.GetPagination()).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListReturnsRequestValidationError{
                                                field:  "Pagination",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListReturnsRequestValidationError{
                                                field:  "Pagination",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return ListReturnsRequestValidationError{
                                        field:  "Pagination",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ListReturnsRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListReturnsRequestMultiError is an error wrapping multiple validation errors
// returned by ListReturnsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListReturnsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReturnsRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ListReturnsRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ListReturnsRequestValidationError is the validation error returned by
// ListReturnsRequest.Validate if the designated constraints aren't met.
type ListReturnsRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ListReturnsRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ListReturnsRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ListReturnsRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ListReturnsRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ListReturnsRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "ListReturnsRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e ListReturnsRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sListReturnsRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ListReturnsRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ListReturnsRequestValidationError{}

// Validate checks the field values on ReturnsList with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReturnsList) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ReturnsList with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReturnsListMultiError, or
// nil if none found.
func (m *ReturnsList) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ReturnsList) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        for idx, item := range m.GetReturns() </span><span class="cov0" title="0">{
                _, _ = idx, item

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(item).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ReturnsListValidationError{
                                                field:  fmt.Sprintf("Returns[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ReturnsListValidationError{
                                                field:  fmt.Sprintf("Returns[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(item).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return ReturnsListValidationError{
                                        field:  fmt.Sprintf("Returns[%v]", idx),
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ReturnsListMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ReturnsListMultiError is an error wrapping multiple validation errors
// returned by ReturnsList.ValidateAll() if the designated constraints aren't met.
type ReturnsListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReturnsListMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ReturnsListMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ReturnsListValidationError is the validation error returned by
// ReturnsList.Validate if the designated constraints aren't met.
type ReturnsListValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ReturnsListValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ReturnsListValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ReturnsListValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ReturnsListValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ReturnsListValidationError) ErrorName() string <span class="cov0" title="0">{ return "ReturnsListValidationError" }</span>

// Error satisfies the builtin error interface
func (e ReturnsListValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sReturnsList.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ReturnsListValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ReturnsListValidationError{}

// Validate checks the field values on ReturnRecord with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReturnRecord) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ReturnRecord with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReturnRecordMultiError, or
// nil if none found.
func (m *ReturnRecord) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ReturnRecord) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for OrderId

        // no validation rules for UserId

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetReturnedAt()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, ReturnRecordValidationError{
                                        field:  "ReturnedAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, ReturnRecordValidationError{
                                        field:  "ReturnedAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetReturnedAt()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return ReturnRecordValidationError{
                                field:  "ReturnedAt",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ReturnRecordMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ReturnRecordMultiError is an error wrapping multiple validation errors
// returned by ReturnRecord.ValidateAll() if the designated constraints aren't met.
type ReturnRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReturnRecordMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ReturnRecordMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ReturnRecordValidationError is the validation error returned by
// ReturnRecord.Validate if the designated constraints aren't met.
type ReturnRecordValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ReturnRecordValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ReturnRecordValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ReturnRecordValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ReturnRecordValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ReturnRecordValidationError) ErrorName() string <span class="cov0" title="0">{ return "ReturnRecordValidationError" }</span>

// Error satisfies the builtin error interface
func (e ReturnRecordValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sReturnRecord.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ReturnRecordValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ReturnRecordValidationError{}
</pre>
		
		<pre class="file" id="file55" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.1
// source: pvz/order_service.proto

package pvzpb

import (
        context "context"

        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        OrdersService_AcceptOrder_FullMethodName   = "/orders.OrdersService/AcceptOrder"
        OrdersService_ReturnOrder_FullMethodName   = "/orders.OrdersService/ReturnOrder"
        OrdersService_ProcessOrders_FullMethodName = "/orders.OrdersService/ProcessOrders"
        OrdersService_ListOrders_FullMethodName    = "/orders.OrdersService/ListOrders"
        OrdersService_ListReturns_FullMethodName   = "/orders.OrdersService/ListReturns"
        OrdersService_GetHistory_FullMethodName    = "/orders.OrdersService/GetHistory"
        OrdersService_ImportOrders_FullMethodName  = "/orders.OrdersService/ImportOrders"
)

// OrdersServiceClient is the client API for OrdersService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OrdersServiceClient interface {
        // Принять заказ от курьера
        AcceptOrder(ctx context.Context, in *AcceptOrderRequest, opts ...grpc.CallOption) (*OrderResponse, error)
        // Вернуть заказ курьеру
        ReturnOrder(ctx context.Context, in *OrderIdRequest, opts ...grpc.CallOption) (*OrderResponse, error)
        // Выдать заказы или принять возврат клиента
        ProcessOrders(ctx context.Context, in *ProcessOrdersRequest, opts ...grpc.CallOption) (*ProcessResult, error)
        // Получить список заказов клиента
        ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*OrdersList, error)
        // Получить список возвратов клиентов (постранично, от новых к старым)
        ListReturns(ctx context.Context, in *ListReturnsRequest, opts ...grpc.CallOption) (*ReturnsList, error)
        // Получить историю изменения заказов
        GetHistory(ctx context.Context, in *GetHistoryRequest, opts ...grpc.CallOption) (*OrderHistoryList, error)
        // Импортировать заказы
        ImportOrders(ctx context.Context, in *ImportOrdersRequest, opts ...grpc.CallOption) (*ImportResult, error)
}

type ordersServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewOrdersServiceClient(cc grpc.ClientConnInterface) OrdersServiceClient <span class="cov0" title="0">{
        return &amp;ordersServiceClient{cc}
}</span>

func (c *ordersServiceClient) AcceptOrder(ctx context.Context, in *AcceptOrderRequest, opts ...grpc.CallOption) (*OrderResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(OrderResponse)
        err := c.cc.Invoke(ctx, OrdersService_AcceptOrder_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ordersServiceClient) ReturnOrder(ctx context.Context, in *OrderIdRequest, opts ...grpc.CallOption) (*OrderResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(OrderResponse)
        err := c.cc.Invoke(ctx, OrdersService_ReturnOrder_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ordersServiceClient) ProcessOrders(ctx context.Context, in *ProcessOrdersRequest, opts ...grpc.CallOption) (*ProcessResult, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ProcessResult)
        err := c.cc.Invoke(ctx, OrdersService_ProcessOrders_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ordersServiceClient) ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*OrdersList, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(OrdersList)
        err := c.cc.Invoke(ctx, OrdersService_ListOrders_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ordersServiceClient) ListReturns(ctx context.Context, in *ListReturnsRequest, opts ...grpc.CallOption) (*ReturnsList, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ReturnsList)
        err := c.cc.Invoke(ctx, OrdersService_ListReturns_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ordersServiceClient) GetHistory(ctx context.Context, in *GetHistoryRequest, opts ...grpc.CallOption) (*OrderHistoryList, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(OrderHistoryList)
        err := c.cc.Invoke(ctx, OrdersService_GetHistory_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ordersServiceClient) ImportOrders(ctx context.Context, in *ImportOrdersRequest, opts ...grpc.CallOption) (*ImportResult, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ImportResult)
        err := c.cc.Invoke(ctx, OrdersService_ImportOrders_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// OrdersServiceServer is the server API for OrdersService service.
// All implementations must embed UnimplementedOrdersServiceServer
// for forward compatibility.
type OrdersServiceServer interface {
        // Принять заказ от курьера
        AcceptOrder(context.Context, *AcceptOrderRequest) (*OrderResponse, error)
        // Вернуть заказ курьеру
        ReturnOrder(context.Context, *OrderIdRequest) (*OrderResponse, error)
        // Выдать заказы или принять возврат клиента
        ProcessOrders(context.Context, *ProcessOrdersRequest) (*ProcessResult, error)
        // Получить список заказов клиента
        ListOrders(context.Context, *ListOrdersRequest) (*OrdersList, error)
        // Получить список возвратов клиентов (постранично, от новых к старым)
        ListReturns(context.Context, *ListReturnsRequest) (*ReturnsList, error)
        // Получить историю изменения заказов
        GetHistory(context.Context, *GetHistoryRequest) (*OrderHistoryList, error)
        // Импортировать заказы
        ImportOrders(context.Context, *ImportOrdersRequest) (*ImportResult, error)
        mustEmbedUnimplementedOrdersServiceServer()
}

// UnimplementedOrdersServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOrdersServiceServer struct{}

func (UnimplementedOrdersServiceServer) AcceptOrder(context.Context, *AcceptOrderRequest) (*OrderResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AcceptOrder not implemented")
}</span>
func (UnimplementedOrdersServiceServer) ReturnOrder(context.Context, *OrderIdRequest) (*OrderResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ReturnOrder not implemented")
}</span>
func (UnimplementedOrdersServiceServer) ProcessOrders(context.Context, *ProcessOrdersRequest) (*ProcessResult, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ProcessOrders not implemented")
}</span>
func (UnimplementedOrdersServiceServer) ListOrders(context.Context, *ListOrdersRequest) (*OrdersList, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListOrders not implemented")
}</span>
func (UnimplementedOrdersServiceServer) ListReturns(context.Context, *ListReturnsRequest) (*ReturnsList, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListReturns not implemented")
}</span>
func (UnimplementedOrdersServiceServer) GetHistory(context.Context, *GetHistoryRequest) (*OrderHistoryList, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetHistory not implemented")
}</span>
func (UnimplementedOrdersServiceServer) ImportOrders(context.Context, *ImportOrdersRequest) (*ImportResult, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ImportOrders not implemented")
}</span>
func (UnimplementedOrdersServiceServer) mustEmbedUnimplementedOrdersServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedOrdersServiceServer) testEmbeddedByValue()                       {<span class="cov0" title="0">}</span>

// UnsafeOrdersServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OrdersServiceServer will
// result in compilation errors.
type UnsafeOrdersServiceServer interface {
        mustEmbedUnimplementedOrdersServiceServer()
}

func RegisterOrdersServiceServer(s grpc.ServiceRegistrar, srv OrdersServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedOrdersServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;OrdersService_ServiceDesc, srv)</span>
}

func _OrdersService_AcceptOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AcceptOrderRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).AcceptOrder(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrdersService_AcceptOrder_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).AcceptOrder(ctx, req.(*AcceptOrderRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OrdersService_ReturnOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(OrderIdRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ReturnOrder(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrdersService_ReturnOrder_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ReturnOrder(ctx, req.(*OrderIdRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OrdersService_ProcessOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ProcessOrdersRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ProcessOrders(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrdersService_ProcessOrders_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ProcessOrders(ctx, req.(*ProcessOrdersRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OrdersService_ListOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListOrdersRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ListOrders(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrdersService_ListOrders_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ListOrders(ctx, req.(*ListOrdersRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OrdersService_ListReturns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListReturnsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ListReturns(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrdersService_ListReturns_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ListReturns(ctx, req.(*ListReturnsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OrdersService_GetHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetHistoryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).GetHistory(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrdersService_GetHistory_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).GetHistory(ctx, req.(*GetHistoryRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OrdersService_ImportOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ImportOrdersRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ImportOrders(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrdersService_ImportOrders_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ImportOrders(ctx, req.(*ImportOrdersRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// OrdersService_ServiceDesc is the grpc.ServiceDesc for OrdersService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OrdersService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "orders.OrdersService",
        HandlerType: (*OrdersServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "AcceptOrder",
                        Handler:    _OrdersService_AcceptOrder_Handler,
                },
                {
                        MethodName: "ReturnOrder",
                        Handler:    _OrdersService_ReturnOrder_Handler,
                },
                {
                        MethodName: "ProcessOrders",
                        Handler:    _OrdersService_ProcessOrders_Handler,
                },
                {
                        MethodName: "ListOrders",
                        Handler:    _OrdersService_ListOrders_Handler,
                },
                {
                        MethodName: "ListReturns",
                        Handler:    _OrdersService_ListReturns_Handler,
                },
                {
                        MethodName: "GetHistory",
                        Handler:    _OrdersService_GetHistory_Handler,
                },
                {
                        MethodName: "ImportOrders",
                        Handler:    _OrdersService_ImportOrders_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "pvz/order_service.proto",
}
</pre>
		
		<pre class="file" id="file56" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v6.30.1
// source: pvz/order_types.proto

package pvzpb

import (
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"

        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ActionType int32

const (
        ActionType_ACTION_TYPE_UNSPECIFIED ActionType = 0
        ActionType_ACTION_TYPE_ISSUE       ActionType = 1
        ActionType_ACTION_TYPE_RETURN      ActionType = 2
)

// Enum value maps for ActionType.
var (
        ActionType_name = map[int32]string{
                0: "ACTION_TYPE_UNSPECIFIED",
                1: "ACTION_TYPE_ISSUE",
                2: "ACTION_TYPE_RETURN",
        }
        ActionType_value = map[string]int32{
                "ACTION_TYPE_UNSPECIFIED": 0,
                "ACTION_TYPE_ISSUE":       1,
                "ACTION_TYPE_RETURN":      2,
        }
)

func (x ActionType) Enum() *ActionType <span class="cov0" title="0">{
        p := new(ActionType)
        *p = x
        return p
}</span>

func (x ActionType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (ActionType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_pvz_order_types_proto_enumTypes[0].Descriptor()
}</span>

func (ActionType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_pvz_order_types_proto_enumTypes[0]
}</span>

func (x ActionType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use ActionType.Descriptor instead.
func (ActionType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_types_proto_rawDescGZIP(), []int{0}
}</span>

type PackageType int32

const (
        PackageType_PACKAGE_TYPE_UNSPECIFIED PackageType = 0
        PackageType_PACKAGE_TYPE_BAG         PackageType = 1
        PackageType_PACKAGE_TYPE_BOX         PackageType = 2
        PackageType_PACKAGE_TYPE_TAPE        PackageType = 3
        PackageType_PACKAGE_TYPE_BAG_TAPE    PackageType = 4
        PackageType_PACKAGE_TYPE_BOX_TAPE    PackageType = 5
)

// Enum value maps for PackageType.
var (
        PackageType_name = map[int32]string{
                0: "PACKAGE_TYPE_UNSPECIFIED",
                1: "PACKAGE_TYPE_BAG",
                2: "PACKAGE_TYPE_BOX",
                3: "PACKAGE_TYPE_TAPE",
                4: "PACKAGE_TYPE_BAG_TAPE",
                5: "PACKAGE_TYPE_BOX_TAPE",
        }
        PackageType_value = map[string]int32{
                "PACKAGE_TYPE_UNSPECIFIED": 0,
                "PACKAGE_TYPE_BAG":         1,
                "PACKAGE_TYPE_BOX":         2,
                "PACKAGE_TYPE_TAPE":        3,
                "PACKAGE_TYPE_BAG_TAPE":    4,
                "PACKAGE_TYPE_BOX_TAPE":    5,
        }
)

func (x PackageType) Enum() *PackageType <span class="cov0" title="0">{
        p := new(PackageType)
        *p = x
        return p
}</span>

func (x PackageType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (PackageType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_pvz_order_types_proto_enumTypes[1].Descriptor()
}</span>

func (PackageType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_pvz_order_types_proto_enumTypes[1]
}</span>

func (x PackageType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use PackageType.Descriptor instead.
func (PackageType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_types_proto_rawDescGZIP(), []int{1}
}</span>

type OrderStatus int32

const (
        OrderStatus_ORDER_STATUS_UNSPECIFIED OrderStatus = 0
        OrderStatus_ORDER_STATUS_EXPECTS     OrderStatus = 1
        OrderStatus_ORDER_STATUS_ACCEPTED    OrderStatus = 2
        OrderStatus_ORDER_STATUS_RETURNED    OrderStatus = 3
        OrderStatus_ORDER_STATUS_DELETED     OrderStatus = 4
)

// Enum value maps for OrderStatus.
var (
        OrderStatus_name = map[int32]string{
                0: "ORDER_STATUS_UNSPECIFIED",
                1: "ORDER_STATUS_EXPECTS",
                2: "ORDER_STATUS_ACCEPTED",
                3: "ORDER_STATUS_RETURNED",
                4: "ORDER_STATUS_DELETED",
        }
        OrderStatus_value = map[string]int32{
                "ORDER_STATUS_UNSPECIFIED": 0,
                "ORDER_STATUS_EXPECTS":     1,
                "ORDER_STATUS_ACCEPTED":    2,
                "ORDER_STATUS_RETURNED":    3,
                "ORDER_STATUS_DELETED":     4,
        }
)

func (x OrderStatus) Enum() *OrderStatus <span class="cov0" title="0">{
        p := new(OrderStatus)
        *p = x
        return p
}</span>

func (x OrderStatus) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (OrderStatus) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_pvz_order_types_proto_enumTypes[2].Descriptor()
}</span>

func (OrderStatus) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_pvz_order_types_proto_enumTypes[2]
}</span>

func (x OrderStatus) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use OrderStatus.Descriptor instead.
func (OrderStatus) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pvz_order_types_proto_rawDescGZIP(), []int{2}
}</span>

var File_pvz_order_types_proto protoreflect.FileDescriptor

const file_pvz_order_types_proto_rawDesc = "" +
        "\n" +
        "\x15pvz/order_types.proto\x12\x06orders*X\n" +
        "\n" +
        "ActionType\x12\x1b\n" +
        "\x17ACTION_TYPE_UNSPECIFIED\x10\x00\x12\x15\n" +
        "\x11ACTION_TYPE_ISSUE\x10\x01\x12\x16\n" +
        "\x12ACTION_TYPE_RETURN\x10\x02*\xa4\x01\n" +
        "\vPackageType\x12\x1c\n" +
        "\x18PACKAGE_TYPE_UNSPECIFIED\x10\x00\x12\x14\n" +
        "\x10PACKAGE_TYPE_BAG\x10\x01\x12\x14\n" +
        "\x10PACKAGE_TYPE_BOX\x10\x02\x12\x15\n" +
        "\x11PACKAGE_TYPE_TAPE\x10\x03\x12\x19\n" +
        "\x15PACKAGE_TYPE_BAG_TAPE\x10\x04\x12\x19\n" +
        "\x15PACKAGE_TYPE_BOX_TAPE\x10\x05*\x95\x01\n" +
        "\vOrderStatus\x12\x1c\n" +
        "\x18ORDER_STATUS_UNSPECIFIED\x10\x00\x12\x18\n" +
        "\x14ORDER_STATUS_EXPECTS\x10\x01\x12\x19\n" +
        "\x15ORDER_STATUS_ACCEPTED\x10\x02\x12\x19\n" +
        "\x15ORDER_STATUS_RETURNED\x10\x03\x12\x18\n" +
        "\x14ORDER_STATUS_DELETED\x10\x04B\x13Z\x11api/pkg/pvz;pvzpbb\x06proto3"

var (
        file_pvz_order_types_proto_rawDescOnce sync.Once
        file_pvz_order_types_proto_rawDescData []byte
)

func file_pvz_order_types_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_pvz_order_types_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_pvz_order_types_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_pvz_order_types_proto_rawDesc), len(file_pvz_order_types_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_pvz_order_types_proto_rawDescData</span>
}

var file_pvz_order_types_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_pvz_order_types_proto_goTypes = []any{
        (ActionType)(0),  // 0: orders.ActionType
        (PackageType)(0), // 1: orders.PackageType
        (OrderStatus)(0), // 2: orders.OrderStatus
}
var file_pvz_order_types_proto_depIdxs = []int32{
        0, // [0:0] is the sub-list for method output_type
        0, // [0:0] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_pvz_order_types_proto_init() }</span>
func file_pvz_order_types_proto_init() <span class="cov0" title="0">{
        if File_pvz_order_types_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_pvz_order_types_proto_rawDesc), len(file_pvz_order_types_proto_rawDesc)),
                        NumEnums:      3,
                        NumMessages:   0,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_pvz_order_types_proto_goTypes,
                DependencyIndexes: file_pvz_order_types_proto_depIdxs,
                EnumInfos:         file_pvz_order_types_proto_enumTypes,
        }.Build()
        File_pvz_order_types_proto = out.File
        file_pvz_order_types_proto_goTypes = nil
        file_pvz_order_types_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package txmanager

import (
        "context"

        "github.com/jackc/pgx/v5"
)

type accessModeKey struct{}

func (t *Transactor) WithReadOnly(ctx context.Context) context.Context <span class="cov0" title="0">{
        return injectAccessMode(ctx, AccessModeReadOnly)
}</span>

// injectAccessMode returns a new Context that carries the given access mode.
func injectAccessMode(ctx context.Context, mode pgx.TxAccessMode) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, accessModeKey{}, mode)
}</span>

// extractAccessMode retrieves the access mode from the Context.
// The second return value is false if no access mode was set.
func extractAccessMode(ctx context.Context) (pgx.TxAccessMode, bool) <span class="cov0" title="0">{
        mode, ok := ctx.Value(accessModeKey{}).(pgx.TxAccessMode)
        return mode, ok
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i pvz-cli/pkg/txmanager.TxManager -o txmanager_mock.go -n TxManagerMock -p mock

import (
        "context"
        mm_txmanager "pvz-cli/pkg/txmanager"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "github.com/jackc/pgx/v5"
)

// TxManagerMock implements mm_txmanager.TxManager
type TxManagerMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcGetExecutor          func(ctx context.Context) (e1 mm_txmanager.Executor)
        funcGetExecutorOrigin    string
        inspectFuncGetExecutor   func(ctx context.Context)
        afterGetExecutorCounter  uint64
        beforeGetExecutorCounter uint64
        GetExecutorMock          mTxManagerMockGetExecutor

        funcWithReadOnly          func(ctx context.Context) (c2 context.Context)
        funcWithReadOnlyOrigin    string
        inspectFuncWithReadOnly   func(ctx context.Context)
        afterWithReadOnlyCounter  uint64
        beforeWithReadOnlyCounter uint64
        WithReadOnlyMock          mTxManagerMockWithReadOnly

        funcWithTx          func(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error) (err error)
        funcWithTxOrigin    string
        inspectFuncWithTx   func(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error)
        afterWithTxCounter  uint64
        beforeWithTxCounter uint64
        WithTxMock          mTxManagerMockWithTx
}

// NewTxManagerMock returns a mock for mm_txmanager.TxManager
func NewTxManagerMock(t minimock.Tester) *TxManagerMock <span class="cov0" title="0">{
        m := &amp;TxManagerMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.GetExecutorMock = mTxManagerMockGetExecutor{mock: m}
        m.GetExecutorMock.callArgs = []*TxManagerMockGetExecutorParams{}

        m.WithReadOnlyMock = mTxManagerMockWithReadOnly{mock: m}
        m.WithReadOnlyMock.callArgs = []*TxManagerMockWithReadOnlyParams{}

        m.WithTxMock = mTxManagerMockWithTx{mock: m}
        m.WithTxMock.callArgs = []*TxManagerMockWithTxParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mTxManagerMockGetExecutor struct {
        optional           bool
        mock               *TxManagerMock
        defaultExpectation *TxManagerMockGetExecutorExpectation
        expectations       []*TxManagerMockGetExecutorExpectation

        callArgs []*TxManagerMockGetExecutorParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TxManagerMockGetExecutorExpectation specifies expectation struct of the TxManager.GetExecutor
type TxManagerMockGetExecutorExpectation struct {
        mock               *TxManagerMock
        params             *TxManagerMockGetExecutorParams
        paramPtrs          *TxManagerMockGetExecutorParamPtrs
        expectationOrigins TxManagerMockGetExecutorExpectationOrigins
        results            *TxManagerMockGetExecutorResults
        returnOrigin       string
        Counter            uint64
}

// TxManagerMockGetExecutorParams contains parameters of the TxManager.GetExecutor
type TxManagerMockGetExecutorParams struct {
        ctx context.Context
}

// TxManagerMockGetExecutorParamPtrs contains pointers to parameters of the TxManager.GetExecutor
type TxManagerMockGetExecutorParamPtrs struct {
        ctx *context.Context
}

// TxManagerMockGetExecutorResults contains results of the TxManager.GetExecutor
type TxManagerMockGetExecutorResults struct {
        e1 mm_txmanager.Executor
}

// TxManagerMockGetExecutorOrigins contains origins of expectations of the TxManager.GetExecutor
type TxManagerMockGetExecutorExpectationOrigins struct {
        origin    string
        originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetExecutor *mTxManagerMockGetExecutor) Optional() *mTxManagerMockGetExecutor <span class="cov0" title="0">{
        mmGetExecutor.optional = true
        return mmGetExecutor
}</span>

// Expect sets up expected params for TxManager.GetExecutor
func (mmGetExecutor *mTxManagerMockGetExecutor) Expect(ctx context.Context) *mTxManagerMockGetExecutor <span class="cov0" title="0">{
        if mmGetExecutor.mock.funcGetExecutor != nil </span><span class="cov0" title="0">{
                mmGetExecutor.mock.t.Fatalf("TxManagerMock.GetExecutor mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetExecutor.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetExecutor.defaultExpectation = &amp;TxManagerMockGetExecutorExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetExecutor.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetExecutor.mock.t.Fatalf("TxManagerMock.GetExecutor mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGetExecutor.defaultExpectation.params = &amp;TxManagerMockGetExecutorParams{ctx}
        mmGetExecutor.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetExecutor.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetExecutor.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetExecutor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetExecutor.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGetExecutor</span>
}

// ExpectCtxParam1 sets up expected param ctx for TxManager.GetExecutor
func (mmGetExecutor *mTxManagerMockGetExecutor) ExpectCtxParam1(ctx context.Context) *mTxManagerMockGetExecutor <span class="cov0" title="0">{
        if mmGetExecutor.mock.funcGetExecutor != nil </span><span class="cov0" title="0">{
                mmGetExecutor.mock.t.Fatalf("TxManagerMock.GetExecutor mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetExecutor.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetExecutor.defaultExpectation = &amp;TxManagerMockGetExecutorExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetExecutor.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetExecutor.mock.t.Fatalf("TxManagerMock.GetExecutor mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetExecutor.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetExecutor.defaultExpectation.paramPtrs = &amp;TxManagerMockGetExecutorParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetExecutor.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmGetExecutor.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmGetExecutor</span>
}

// Inspect accepts an inspector function that has same arguments as the TxManager.GetExecutor
func (mmGetExecutor *mTxManagerMockGetExecutor) Inspect(f func(ctx context.Context)) *mTxManagerMockGetExecutor <span class="cov0" title="0">{
        if mmGetExecutor.mock.inspectFuncGetExecutor != nil </span><span class="cov0" title="0">{
                mmGetExecutor.mock.t.Fatalf("Inspect function is already set for TxManagerMock.GetExecutor")
        }</span>

        <span class="cov0" title="0">mmGetExecutor.mock.inspectFuncGetExecutor = f

        return mmGetExecutor</span>
}

// Return sets up results that will be returned by TxManager.GetExecutor
func (mmGetExecutor *mTxManagerMockGetExecutor) Return(e1 mm_txmanager.Executor) *TxManagerMock <span class="cov0" title="0">{
        if mmGetExecutor.mock.funcGetExecutor != nil </span><span class="cov0" title="0">{
                mmGetExecutor.mock.t.Fatalf("TxManagerMock.GetExecutor mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetExecutor.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetExecutor.defaultExpectation = &amp;TxManagerMockGetExecutorExpectation{mock: mmGetExecutor.mock}
        }</span>
        <span class="cov0" title="0">mmGetExecutor.defaultExpectation.results = &amp;TxManagerMockGetExecutorResults{e1}
        mmGetExecutor.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetExecutor.mock</span>
}

// Set uses given function f to mock the TxManager.GetExecutor method
func (mmGetExecutor *mTxManagerMockGetExecutor) Set(f func(ctx context.Context) (e1 mm_txmanager.Executor)) *TxManagerMock <span class="cov0" title="0">{
        if mmGetExecutor.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetExecutor.mock.t.Fatalf("Default expectation is already set for the TxManager.GetExecutor method")
        }</span>

        <span class="cov0" title="0">if len(mmGetExecutor.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetExecutor.mock.t.Fatalf("Some expectations are already set for the TxManager.GetExecutor method")
        }</span>

        <span class="cov0" title="0">mmGetExecutor.mock.funcGetExecutor = f
        mmGetExecutor.mock.funcGetExecutorOrigin = minimock.CallerInfo(1)
        return mmGetExecutor.mock</span>
}

// When sets expectation for the TxManager.GetExecutor which will trigger the result defined by the following
// Then helper
func (mmGetExecutor *mTxManagerMockGetExecutor) When(ctx context.Context) *TxManagerMockGetExecutorExpectation <span class="cov0" title="0">{
        if mmGetExecutor.mock.funcGetExecutor != nil </span><span class="cov0" title="0">{
                mmGetExecutor.mock.t.Fatalf("TxManagerMock.GetExecutor mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TxManagerMockGetExecutorExpectation{
                mock:               mmGetExecutor.mock,
                params:             &amp;TxManagerMockGetExecutorParams{ctx},
                expectationOrigins: TxManagerMockGetExecutorExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetExecutor.expectations = append(mmGetExecutor.expectations, expectation)
        return expectation</span>
}

// Then sets up TxManager.GetExecutor return parameters for the expectation previously defined by the When method
func (e *TxManagerMockGetExecutorExpectation) Then(e1 mm_txmanager.Executor) *TxManagerMock <span class="cov0" title="0">{
        e.results = &amp;TxManagerMockGetExecutorResults{e1}
        return e.mock
}</span>

// Times sets number of times TxManager.GetExecutor should be invoked
func (mmGetExecutor *mTxManagerMockGetExecutor) Times(n uint64) *mTxManagerMockGetExecutor <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetExecutor.mock.t.Fatalf("Times of TxManagerMock.GetExecutor mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetExecutor.expectedInvocations, n)
        mmGetExecutor.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetExecutor</span>
}

func (mmGetExecutor *mTxManagerMockGetExecutor) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmGetExecutor.expectations) == 0 &amp;&amp; mmGetExecutor.defaultExpectation == nil &amp;&amp; mmGetExecutor.mock.funcGetExecutor == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetExecutor.mock.afterGetExecutorCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetExecutor.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetExecutor implements mm_txmanager.TxManager
func (mmGetExecutor *TxManagerMock) GetExecutor(ctx context.Context) (e1 mm_txmanager.Executor) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmGetExecutor.beforeGetExecutorCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetExecutor.afterGetExecutorCounter, 1)

        mmGetExecutor.t.Helper()

        if mmGetExecutor.inspectFuncGetExecutor != nil </span><span class="cov0" title="0">{
                mmGetExecutor.inspectFuncGetExecutor(ctx)
        }</span>

        <span class="cov0" title="0">mm_params := TxManagerMockGetExecutorParams{ctx}

        // Record call args
        mmGetExecutor.GetExecutorMock.mutex.Lock()
        mmGetExecutor.GetExecutorMock.callArgs = append(mmGetExecutor.GetExecutorMock.callArgs, &amp;mm_params)
        mmGetExecutor.GetExecutorMock.mutex.Unlock()

        for _, e := range mmGetExecutor.GetExecutorMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.e1
                }</span>
        }

        <span class="cov0" title="0">if mmGetExecutor.GetExecutorMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmGetExecutor.GetExecutorMock.defaultExpectation.Counter, 1)
                mm_want := mmGetExecutor.GetExecutorMock.defaultExpectation.params
                mm_want_ptrs := mmGetExecutor.GetExecutorMock.defaultExpectation.paramPtrs

                mm_got := TxManagerMockGetExecutorParams{ctx}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGetExecutor.t.Errorf("TxManagerMock.GetExecutor got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetExecutor.GetExecutorMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetExecutor.t.Errorf("TxManagerMock.GetExecutor got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetExecutor.GetExecutorMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmGetExecutor.GetExecutorMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetExecutor.t.Fatal("No results are set for the TxManagerMock.GetExecutor")
                }</span>
                <span class="cov0" title="0">return (*mm_results).e1</span>
        }
        <span class="cov0" title="0">if mmGetExecutor.funcGetExecutor != nil </span><span class="cov0" title="0">{
                return mmGetExecutor.funcGetExecutor(ctx)
        }</span>
        <span class="cov0" title="0">mmGetExecutor.t.Fatalf("Unexpected call to TxManagerMock.GetExecutor. %v", ctx)
        return</span>
}

// GetExecutorAfterCounter returns a count of finished TxManagerMock.GetExecutor invocations
func (mmGetExecutor *TxManagerMock) GetExecutorAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetExecutor.afterGetExecutorCounter)
}</span>

// GetExecutorBeforeCounter returns a count of TxManagerMock.GetExecutor invocations
func (mmGetExecutor *TxManagerMock) GetExecutorBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetExecutor.beforeGetExecutorCounter)
}</span>

// Calls returns a list of arguments used in each call to TxManagerMock.GetExecutor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetExecutor *mTxManagerMockGetExecutor) Calls() []*TxManagerMockGetExecutorParams <span class="cov0" title="0">{
        mmGetExecutor.mutex.RLock()

        argCopy := make([]*TxManagerMockGetExecutorParams, len(mmGetExecutor.callArgs))
        copy(argCopy, mmGetExecutor.callArgs)

        mmGetExecutor.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetExecutorDone returns true if the count of the GetExecutor invocations corresponds
// the number of defined expectations
func (m *TxManagerMock) MinimockGetExecutorDone() bool <span class="cov0" title="0">{
        if m.GetExecutorMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.GetExecutorMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.GetExecutorMock.invocationsDone()</span>
}

// MinimockGetExecutorInspect logs each unmet expectation
func (m *TxManagerMock) MinimockGetExecutorInspect() <span class="cov0" title="0">{
        for _, e := range m.GetExecutorMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TxManagerMock.GetExecutor at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetExecutorCounter := mm_atomic.LoadUint64(&amp;m.afterGetExecutorCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetExecutorMock.defaultExpectation != nil &amp;&amp; afterGetExecutorCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetExecutorMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TxManagerMock.GetExecutor at\n%s", m.GetExecutorMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TxManagerMock.GetExecutor at\n%s with params: %#v", m.GetExecutorMock.defaultExpectation.expectationOrigins.origin, *m.GetExecutorMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetExecutor != nil &amp;&amp; afterGetExecutorCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TxManagerMock.GetExecutor at\n%s", m.funcGetExecutorOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetExecutorMock.invocationsDone() &amp;&amp; afterGetExecutorCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TxManagerMock.GetExecutor at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetExecutorMock.expectedInvocations), m.GetExecutorMock.expectedInvocationsOrigin, afterGetExecutorCounter)
        }</span>
}

type mTxManagerMockWithReadOnly struct {
        optional           bool
        mock               *TxManagerMock
        defaultExpectation *TxManagerMockWithReadOnlyExpectation
        expectations       []*TxManagerMockWithReadOnlyExpectation

        callArgs []*TxManagerMockWithReadOnlyParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TxManagerMockWithReadOnlyExpectation specifies expectation struct of the TxManager.WithReadOnly
type TxManagerMockWithReadOnlyExpectation struct {
        mock               *TxManagerMock
        params             *TxManagerMockWithReadOnlyParams
        paramPtrs          *TxManagerMockWithReadOnlyParamPtrs
        expectationOrigins TxManagerMockWithReadOnlyExpectationOrigins
        results            *TxManagerMockWithReadOnlyResults
        returnOrigin       string
        Counter            uint64
}

// TxManagerMockWithReadOnlyParams contains parameters of the TxManager.WithReadOnly
type TxManagerMockWithReadOnlyParams struct {
        ctx context.Context
}

// TxManagerMockWithReadOnlyParamPtrs contains pointers to parameters of the TxManager.WithReadOnly
type TxManagerMockWithReadOnlyParamPtrs struct {
        ctx *context.Context
}

// TxManagerMockWithReadOnlyResults contains results of the TxManager.WithReadOnly
type TxManagerMockWithReadOnlyResults struct {
        c2 context.Context
}

// TxManagerMockWithReadOnlyOrigins contains origins of expectations of the TxManager.WithReadOnly
type TxManagerMockWithReadOnlyExpectationOrigins struct {
        origin    string
        originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWithReadOnly *mTxManagerMockWithReadOnly) Optional() *mTxManagerMockWithReadOnly <span class="cov0" title="0">{
        mmWithReadOnly.optional = true
        return mmWithReadOnly
}</span>

// Expect sets up expected params for TxManager.WithReadOnly
func (mmWithReadOnly *mTxManagerMockWithReadOnly) Expect(ctx context.Context) *mTxManagerMockWithReadOnly <span class="cov0" title="0">{
        if mmWithReadOnly.mock.funcWithReadOnly != nil </span><span class="cov0" title="0">{
                mmWithReadOnly.mock.t.Fatalf("TxManagerMock.WithReadOnly mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmWithReadOnly.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmWithReadOnly.defaultExpectation = &amp;TxManagerMockWithReadOnlyExpectation{}
        }</span>

        <span class="cov0" title="0">if mmWithReadOnly.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmWithReadOnly.mock.t.Fatalf("TxManagerMock.WithReadOnly mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmWithReadOnly.defaultExpectation.params = &amp;TxManagerMockWithReadOnlyParams{ctx}
        mmWithReadOnly.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmWithReadOnly.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmWithReadOnly.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmWithReadOnly.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithReadOnly.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmWithReadOnly</span>
}

// ExpectCtxParam1 sets up expected param ctx for TxManager.WithReadOnly
func (mmWithReadOnly *mTxManagerMockWithReadOnly) ExpectCtxParam1(ctx context.Context) *mTxManagerMockWithReadOnly <span class="cov0" title="0">{
        if mmWithReadOnly.mock.funcWithReadOnly != nil </span><span class="cov0" title="0">{
                mmWithReadOnly.mock.t.Fatalf("TxManagerMock.WithReadOnly mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmWithReadOnly.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmWithReadOnly.defaultExpectation = &amp;TxManagerMockWithReadOnlyExpectation{}
        }</span>

        <span class="cov0" title="0">if mmWithReadOnly.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmWithReadOnly.mock.t.Fatalf("TxManagerMock.WithReadOnly mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmWithReadOnly.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmWithReadOnly.defaultExpectation.paramPtrs = &amp;TxManagerMockWithReadOnlyParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmWithReadOnly.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmWithReadOnly.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmWithReadOnly</span>
}

// Inspect accepts an inspector function that has same arguments as the TxManager.WithReadOnly
func (mmWithReadOnly *mTxManagerMockWithReadOnly) Inspect(f func(ctx context.Context)) *mTxManagerMockWithReadOnly <span class="cov0" title="0">{
        if mmWithReadOnly.mock.inspectFuncWithReadOnly != nil </span><span class="cov0" title="0">{
                mmWithReadOnly.mock.t.Fatalf("Inspect function is already set for TxManagerMock.WithReadOnly")
        }</span>

        <span class="cov0" title="0">mmWithReadOnly.mock.inspectFuncWithReadOnly = f

        return mmWithReadOnly</span>
}

// Return sets up results that will be returned by TxManager.WithReadOnly
func (mmWithReadOnly *mTxManagerMockWithReadOnly) Return(c2 context.Context) *TxManagerMock <span class="cov0" title="0">{
        if mmWithReadOnly.mock.funcWithReadOnly != nil </span><span class="cov0" title="0">{
                mmWithReadOnly.mock.t.Fatalf("TxManagerMock.WithReadOnly mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmWithReadOnly.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmWithReadOnly.defaultExpectation = &amp;TxManagerMockWithReadOnlyExpectation{mock: mmWithReadOnly.mock}
        }</span>
        <span class="cov0" title="0">mmWithReadOnly.defaultExpectation.results = &amp;TxManagerMockWithReadOnlyResults{c2}
        mmWithReadOnly.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmWithReadOnly.mock</span>
}

// Set uses given function f to mock the TxManager.WithReadOnly method
func (mmWithReadOnly *mTxManagerMockWithReadOnly) Set(f func(ctx context.Context) (c2 context.Context)) *TxManagerMock <span class="cov0" title="0">{
        if mmWithReadOnly.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmWithReadOnly.mock.t.Fatalf("Default expectation is already set for the TxManager.WithReadOnly method")
        }</span>

        <span class="cov0" title="0">if len(mmWithReadOnly.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmWithReadOnly.mock.t.Fatalf("Some expectations are already set for the TxManager.WithReadOnly method")
        }</span>

        <span class="cov0" title="0">mmWithReadOnly.mock.funcWithReadOnly = f
        mmWithReadOnly.mock.funcWithReadOnlyOrigin = minimock.CallerInfo(1)
        return mmWithReadOnly.mock</span>
}

// When sets expectation for the TxManager.WithReadOnly which will trigger the result defined by the following
// Then helper
func (mmWithReadOnly *mTxManagerMockWithReadOnly) When(ctx context.Context) *TxManagerMockWithReadOnlyExpectation <span class="cov0" title="0">{
        if mmWithReadOnly.mock.funcWithReadOnly != nil </span><span class="cov0" title="0">{
                mmWithReadOnly.mock.t.Fatalf("TxManagerMock.WithReadOnly mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TxManagerMockWithReadOnlyExpectation{
                mock:               mmWithReadOnly.mock,
                params:             &amp;TxManagerMockWithReadOnlyParams{ctx},
                expectationOrigins: TxManagerMockWithReadOnlyExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmWithReadOnly.expectations = append(mmWithReadOnly.expectations, expectation)
        return expectation</span>
}

// Then sets up TxManager.WithReadOnly return parameters for the expectation previously defined by the When method
func (e *TxManagerMockWithReadOnlyExpectation) Then(c2 context.Context) *TxManagerMock <span class="cov0" title="0">{
        e.results = &amp;TxManagerMockWithReadOnlyResults{c2}
        return e.mock
}</span>

// Times sets number of times TxManager.WithReadOnly should be invoked
func (mmWithReadOnly *mTxManagerMockWithReadOnly) Times(n uint64) *mTxManagerMockWithReadOnly <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmWithReadOnly.mock.t.Fatalf("Times of TxManagerMock.WithReadOnly mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmWithReadOnly.expectedInvocations, n)
        mmWithReadOnly.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmWithReadOnly</span>
}

func (mmWithReadOnly *mTxManagerMockWithReadOnly) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmWithReadOnly.expectations) == 0 &amp;&amp; mmWithReadOnly.defaultExpectation == nil &amp;&amp; mmWithReadOnly.mock.funcWithReadOnly == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmWithReadOnly.mock.afterWithReadOnlyCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmWithReadOnly.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// WithReadOnly implements mm_txmanager.TxManager
func (mmWithReadOnly *TxManagerMock) WithReadOnly(ctx context.Context) (c2 context.Context) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmWithReadOnly.beforeWithReadOnlyCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmWithReadOnly.afterWithReadOnlyCounter, 1)

        mmWithReadOnly.t.Helper()

        if mmWithReadOnly.inspectFuncWithReadOnly != nil </span><span class="cov0" title="0">{
                mmWithReadOnly.inspectFuncWithReadOnly(ctx)
        }</span>

        <span class="cov0" title="0">mm_params := TxManagerMockWithReadOnlyParams{ctx}

        // Record call args
        mmWithReadOnly.WithReadOnlyMock.mutex.Lock()
        mmWithReadOnly.WithReadOnlyMock.callArgs = append(mmWithReadOnly.WithReadOnlyMock.callArgs, &amp;mm_params)
        mmWithReadOnly.WithReadOnlyMock.mutex.Unlock()

        for _, e := range mmWithReadOnly.WithReadOnlyMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.c2
                }</span>
        }

        <span class="cov0" title="0">if mmWithReadOnly.WithReadOnlyMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmWithReadOnly.WithReadOnlyMock.defaultExpectation.Counter, 1)
                mm_want := mmWithReadOnly.WithReadOnlyMock.defaultExpectation.params
                mm_want_ptrs := mmWithReadOnly.WithReadOnlyMock.defaultExpectation.paramPtrs

                mm_got := TxManagerMockWithReadOnlyParams{ctx}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmWithReadOnly.t.Errorf("TxManagerMock.WithReadOnly got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmWithReadOnly.WithReadOnlyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmWithReadOnly.t.Errorf("TxManagerMock.WithReadOnly got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmWithReadOnly.WithReadOnlyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmWithReadOnly.WithReadOnlyMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmWithReadOnly.t.Fatal("No results are set for the TxManagerMock.WithReadOnly")
                }</span>
                <span class="cov0" title="0">return (*mm_results).c2</span>
        }
        <span class="cov0" title="0">if mmWithReadOnly.funcWithReadOnly != nil </span><span class="cov0" title="0">{
                return mmWithReadOnly.funcWithReadOnly(ctx)
        }</span>
        <span class="cov0" title="0">mmWithReadOnly.t.Fatalf("Unexpected call to TxManagerMock.WithReadOnly. %v", ctx)
        return</span>
}

// WithReadOnlyAfterCounter returns a count of finished TxManagerMock.WithReadOnly invocations
func (mmWithReadOnly *TxManagerMock) WithReadOnlyAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmWithReadOnly.afterWithReadOnlyCounter)
}</span>

// WithReadOnlyBeforeCounter returns a count of TxManagerMock.WithReadOnly invocations
func (mmWithReadOnly *TxManagerMock) WithReadOnlyBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmWithReadOnly.beforeWithReadOnlyCounter)
}</span>

// Calls returns a list of arguments used in each call to TxManagerMock.WithReadOnly.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithReadOnly *mTxManagerMockWithReadOnly) Calls() []*TxManagerMockWithReadOnlyParams <span class="cov0" title="0">{
        mmWithReadOnly.mutex.RLock()

        argCopy := make([]*TxManagerMockWithReadOnlyParams, len(mmWithReadOnly.callArgs))
        copy(argCopy, mmWithReadOnly.callArgs)

        mmWithReadOnly.mutex.RUnlock()

        return argCopy
}</span>

// MinimockWithReadOnlyDone returns true if the count of the WithReadOnly invocations corresponds
// the number of defined expectations
func (m *TxManagerMock) MinimockWithReadOnlyDone() bool <span class="cov0" title="0">{
        if m.WithReadOnlyMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.WithReadOnlyMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.WithReadOnlyMock.invocationsDone()</span>
}

// MinimockWithReadOnlyInspect logs each unmet expectation
func (m *TxManagerMock) MinimockWithReadOnlyInspect() <span class="cov0" title="0">{
        for _, e := range m.WithReadOnlyMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TxManagerMock.WithReadOnly at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterWithReadOnlyCounter := mm_atomic.LoadUint64(&amp;m.afterWithReadOnlyCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.WithReadOnlyMock.defaultExpectation != nil &amp;&amp; afterWithReadOnlyCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.WithReadOnlyMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TxManagerMock.WithReadOnly at\n%s", m.WithReadOnlyMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TxManagerMock.WithReadOnly at\n%s with params: %#v", m.WithReadOnlyMock.defaultExpectation.expectationOrigins.origin, *m.WithReadOnlyMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcWithReadOnly != nil &amp;&amp; afterWithReadOnlyCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TxManagerMock.WithReadOnly at\n%s", m.funcWithReadOnlyOrigin)
        }</span>

        <span class="cov0" title="0">if !m.WithReadOnlyMock.invocationsDone() &amp;&amp; afterWithReadOnlyCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TxManagerMock.WithReadOnly at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.WithReadOnlyMock.expectedInvocations), m.WithReadOnlyMock.expectedInvocationsOrigin, afterWithReadOnlyCounter)
        }</span>
}

type mTxManagerMockWithTx struct {
        optional           bool
        mock               *TxManagerMock
        defaultExpectation *TxManagerMockWithTxExpectation
        expectations       []*TxManagerMockWithTxExpectation

        callArgs []*TxManagerMockWithTxParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TxManagerMockWithTxExpectation specifies expectation struct of the TxManager.WithTx
type TxManagerMockWithTxExpectation struct {
        mock               *TxManagerMock
        params             *TxManagerMockWithTxParams
        paramPtrs          *TxManagerMockWithTxParamPtrs
        expectationOrigins TxManagerMockWithTxExpectationOrigins
        results            *TxManagerMockWithTxResults
        returnOrigin       string
        Counter            uint64
}

// TxManagerMockWithTxParams contains parameters of the TxManager.WithTx
type TxManagerMockWithTxParams struct {
        ctx        context.Context
        isoLevel   pgx.TxIsoLevel
        accessMode pgx.TxAccessMode
        fn         func(ctx context.Context) error
}

// TxManagerMockWithTxParamPtrs contains pointers to parameters of the TxManager.WithTx
type TxManagerMockWithTxParamPtrs struct {
        ctx        *context.Context
        isoLevel   *pgx.TxIsoLevel
        accessMode *pgx.TxAccessMode
        fn         *func(ctx context.Context) error
}

// TxManagerMockWithTxResults contains results of the TxManager.WithTx
type TxManagerMockWithTxResults struct {
        err error
}

// TxManagerMockWithTxOrigins contains origins of expectations of the TxManager.WithTx
type TxManagerMockWithTxExpectationOrigins struct {
        origin           string
        originCtx        string
        originIsoLevel   string
        originAccessMode string
        originFn         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWithTx *mTxManagerMockWithTx) Optional() *mTxManagerMockWithTx <span class="cov0" title="0">{
        mmWithTx.optional = true
        return mmWithTx
}</span>

// Expect sets up expected params for TxManager.WithTx
func (mmWithTx *mTxManagerMockWithTx) Expect(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error) *mTxManagerMockWithTx <span class="cov0" title="0">{
        if mmWithTx.mock.funcWithTx != nil </span><span class="cov0" title="0">{
                mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmWithTx.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmWithTx.defaultExpectation = &amp;TxManagerMockWithTxExpectation{}
        }</span>

        <span class="cov0" title="0">if mmWithTx.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmWithTx.defaultExpectation.params = &amp;TxManagerMockWithTxParams{ctx, isoLevel, accessMode, fn}
        mmWithTx.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmWithTx.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmWithTx.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmWithTx.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithTx.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmWithTx</span>
}

// ExpectCtxParam1 sets up expected param ctx for TxManager.WithTx
func (mmWithTx *mTxManagerMockWithTx) ExpectCtxParam1(ctx context.Context) *mTxManagerMockWithTx <span class="cov0" title="0">{
        if mmWithTx.mock.funcWithTx != nil </span><span class="cov0" title="0">{
                mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmWithTx.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmWithTx.defaultExpectation = &amp;TxManagerMockWithTxExpectation{}
        }</span>

        <span class="cov0" title="0">if mmWithTx.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmWithTx.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmWithTx.defaultExpectation.paramPtrs = &amp;TxManagerMockWithTxParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmWithTx.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmWithTx.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmWithTx</span>
}

// ExpectIsoLevelParam2 sets up expected param isoLevel for TxManager.WithTx
func (mmWithTx *mTxManagerMockWithTx) ExpectIsoLevelParam2(isoLevel pgx.TxIsoLevel) *mTxManagerMockWithTx <span class="cov0" title="0">{
        if mmWithTx.mock.funcWithTx != nil </span><span class="cov0" title="0">{
                mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmWithTx.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmWithTx.defaultExpectation = &amp;TxManagerMockWithTxExpectation{}
        }</span>

        <span class="cov0" title="0">if mmWithTx.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmWithTx.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmWithTx.defaultExpectation.paramPtrs = &amp;TxManagerMockWithTxParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmWithTx.defaultExpectation.paramPtrs.isoLevel = &amp;isoLevel
        mmWithTx.defaultExpectation.expectationOrigins.originIsoLevel = minimock.CallerInfo(1)

        return mmWithTx</span>
}

// ExpectAccessModeParam3 sets up expected param accessMode for TxManager.WithTx
func (mmWithTx *mTxManagerMockWithTx) ExpectAccessModeParam3(accessMode pgx.TxAccessMode) *mTxManagerMockWithTx <span class="cov0" title="0">{
        if mmWithTx.mock.funcWithTx != nil </span><span class="cov0" title="0">{
                mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmWithTx.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmWithTx.defaultExpectation = &amp;TxManagerMockWithTxExpectation{}
        }</span>

        <span class="cov0" title="0">if mmWithTx.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmWithTx.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmWithTx.defaultExpectation.paramPtrs = &amp;TxManagerMockWithTxParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmWithTx.defaultExpectation.paramPtrs.accessMode = &amp;accessMode
        mmWithTx.defaultExpectation.expectationOrigins.originAccessMode = minimock.CallerInfo(1)

        return mmWithTx</span>
}

// ExpectFnParam4 sets up expected param fn for TxManager.WithTx
func (mmWithTx *mTxManagerMockWithTx) ExpectFnParam4(fn func(ctx context.Context) error) *mTxManagerMockWithTx <span class="cov0" title="0">{
        if mmWithTx.mock.funcWithTx != nil </span><span class="cov0" title="0">{
                mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmWithTx.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmWithTx.defaultExpectation = &amp;TxManagerMockWithTxExpectation{}
        }</span>

        <span class="cov0" title="0">if mmWithTx.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmWithTx.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmWithTx.defaultExpectation.paramPtrs = &amp;TxManagerMockWithTxParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmWithTx.defaultExpectation.paramPtrs.fn = &amp;fn
        mmWithTx.defaultExpectation.expectationOrigins.originFn = minimock.CallerInfo(1)

        return mmWithTx</span>
}

// Inspect accepts an inspector function that has same arguments as the TxManager.WithTx
func (mmWithTx *mTxManagerMockWithTx) Inspect(f func(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error)) *mTxManagerMockWithTx <span class="cov0" title="0">{
        if mmWithTx.mock.inspectFuncWithTx != nil </span><span class="cov0" title="0">{
                mmWithTx.mock.t.Fatalf("Inspect function is already set for TxManagerMock.WithTx")
        }</span>

        <span class="cov0" title="0">mmWithTx.mock.inspectFuncWithTx = f

        return mmWithTx</span>
}

// Return sets up results that will be returned by TxManager.WithTx
func (mmWithTx *mTxManagerMockWithTx) Return(err error) *TxManagerMock <span class="cov0" title="0">{
        if mmWithTx.mock.funcWithTx != nil </span><span class="cov0" title="0">{
                mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmWithTx.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmWithTx.defaultExpectation = &amp;TxManagerMockWithTxExpectation{mock: mmWithTx.mock}
        }</span>
        <span class="cov0" title="0">mmWithTx.defaultExpectation.results = &amp;TxManagerMockWithTxResults{err}
        mmWithTx.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmWithTx.mock</span>
}

// Set uses given function f to mock the TxManager.WithTx method
func (mmWithTx *mTxManagerMockWithTx) Set(f func(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error) (err error)) *TxManagerMock <span class="cov0" title="0">{
        if mmWithTx.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmWithTx.mock.t.Fatalf("Default expectation is already set for the TxManager.WithTx method")
        }</span>

        <span class="cov0" title="0">if len(mmWithTx.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmWithTx.mock.t.Fatalf("Some expectations are already set for the TxManager.WithTx method")
        }</span>

        <span class="cov0" title="0">mmWithTx.mock.funcWithTx = f
        mmWithTx.mock.funcWithTxOrigin = minimock.CallerInfo(1)
        return mmWithTx.mock</span>
}

// When sets expectation for the TxManager.WithTx which will trigger the result defined by the following
// Then helper
func (mmWithTx *mTxManagerMockWithTx) When(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error) *TxManagerMockWithTxExpectation <span class="cov0" title="0">{
        if mmWithTx.mock.funcWithTx != nil </span><span class="cov0" title="0">{
                mmWithTx.mock.t.Fatalf("TxManagerMock.WithTx mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TxManagerMockWithTxExpectation{
                mock:               mmWithTx.mock,
                params:             &amp;TxManagerMockWithTxParams{ctx, isoLevel, accessMode, fn},
                expectationOrigins: TxManagerMockWithTxExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmWithTx.expectations = append(mmWithTx.expectations, expectation)
        return expectation</span>
}

// Then sets up TxManager.WithTx return parameters for the expectation previously defined by the When method
func (e *TxManagerMockWithTxExpectation) Then(err error) *TxManagerMock <span class="cov0" title="0">{
        e.results = &amp;TxManagerMockWithTxResults{err}
        return e.mock
}</span>

// Times sets number of times TxManager.WithTx should be invoked
func (mmWithTx *mTxManagerMockWithTx) Times(n uint64) *mTxManagerMockWithTx <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmWithTx.mock.t.Fatalf("Times of TxManagerMock.WithTx mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmWithTx.expectedInvocations, n)
        mmWithTx.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmWithTx</span>
}

func (mmWithTx *mTxManagerMockWithTx) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmWithTx.expectations) == 0 &amp;&amp; mmWithTx.defaultExpectation == nil &amp;&amp; mmWithTx.mock.funcWithTx == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmWithTx.mock.afterWithTxCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmWithTx.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// WithTx implements mm_txmanager.TxManager
func (mmWithTx *TxManagerMock) WithTx(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmWithTx.beforeWithTxCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmWithTx.afterWithTxCounter, 1)

        mmWithTx.t.Helper()

        if mmWithTx.inspectFuncWithTx != nil </span><span class="cov0" title="0">{
                mmWithTx.inspectFuncWithTx(ctx, isoLevel, accessMode, fn)
        }</span>

        <span class="cov0" title="0">mm_params := TxManagerMockWithTxParams{ctx, isoLevel, accessMode, fn}

        // Record call args
        mmWithTx.WithTxMock.mutex.Lock()
        mmWithTx.WithTxMock.callArgs = append(mmWithTx.WithTxMock.callArgs, &amp;mm_params)
        mmWithTx.WithTxMock.mutex.Unlock()

        for _, e := range mmWithTx.WithTxMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmWithTx.WithTxMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmWithTx.WithTxMock.defaultExpectation.Counter, 1)
                mm_want := mmWithTx.WithTxMock.defaultExpectation.params
                mm_want_ptrs := mmWithTx.WithTxMock.defaultExpectation.paramPtrs

                mm_got := TxManagerMockWithTxParams{ctx, isoLevel, accessMode, fn}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmWithTx.t.Errorf("TxManagerMock.WithTx got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmWithTx.WithTxMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.isoLevel != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.isoLevel, mm_got.isoLevel) </span><span class="cov0" title="0">{
                                mmWithTx.t.Errorf("TxManagerMock.WithTx got unexpected parameter isoLevel, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmWithTx.WithTxMock.defaultExpectation.expectationOrigins.originIsoLevel, *mm_want_ptrs.isoLevel, mm_got.isoLevel, minimock.Diff(*mm_want_ptrs.isoLevel, mm_got.isoLevel))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.accessMode != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.accessMode, mm_got.accessMode) </span><span class="cov0" title="0">{
                                mmWithTx.t.Errorf("TxManagerMock.WithTx got unexpected parameter accessMode, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmWithTx.WithTxMock.defaultExpectation.expectationOrigins.originAccessMode, *mm_want_ptrs.accessMode, mm_got.accessMode, minimock.Diff(*mm_want_ptrs.accessMode, mm_got.accessMode))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.fn != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.fn, mm_got.fn) </span><span class="cov0" title="0">{
                                mmWithTx.t.Errorf("TxManagerMock.WithTx got unexpected parameter fn, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmWithTx.WithTxMock.defaultExpectation.expectationOrigins.originFn, *mm_want_ptrs.fn, mm_got.fn, minimock.Diff(*mm_want_ptrs.fn, mm_got.fn))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmWithTx.t.Errorf("TxManagerMock.WithTx got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmWithTx.WithTxMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmWithTx.WithTxMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmWithTx.t.Fatal("No results are set for the TxManagerMock.WithTx")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmWithTx.funcWithTx != nil </span><span class="cov0" title="0">{
                return mmWithTx.funcWithTx(ctx, isoLevel, accessMode, fn)
        }</span>
        <span class="cov0" title="0">mmWithTx.t.Fatalf("Unexpected call to TxManagerMock.WithTx. %v %v %v %v", ctx, isoLevel, accessMode, fn)
        return</span>
}

// WithTxAfterCounter returns a count of finished TxManagerMock.WithTx invocations
func (mmWithTx *TxManagerMock) WithTxAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmWithTx.afterWithTxCounter)
}</span>

// WithTxBeforeCounter returns a count of TxManagerMock.WithTx invocations
func (mmWithTx *TxManagerMock) WithTxBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmWithTx.beforeWithTxCounter)
}</span>

// Calls returns a list of arguments used in each call to TxManagerMock.WithTx.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithTx *mTxManagerMockWithTx) Calls() []*TxManagerMockWithTxParams <span class="cov0" title="0">{
        mmWithTx.mutex.RLock()

        argCopy := make([]*TxManagerMockWithTxParams, len(mmWithTx.callArgs))
        copy(argCopy, mmWithTx.callArgs)

        mmWithTx.mutex.RUnlock()

        return argCopy
}</span>

// MinimockWithTxDone returns true if the count of the WithTx invocations corresponds
// the number of defined expectations
func (m *TxManagerMock) MinimockWithTxDone() bool <span class="cov0" title="0">{
        if m.WithTxMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.WithTxMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.WithTxMock.invocationsDone()</span>
}

// MinimockWithTxInspect logs each unmet expectation
func (m *TxManagerMock) MinimockWithTxInspect() <span class="cov0" title="0">{
        for _, e := range m.WithTxMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TxManagerMock.WithTx at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterWithTxCounter := mm_atomic.LoadUint64(&amp;m.afterWithTxCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.WithTxMock.defaultExpectation != nil &amp;&amp; afterWithTxCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.WithTxMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TxManagerMock.WithTx at\n%s", m.WithTxMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TxManagerMock.WithTx at\n%s with params: %#v", m.WithTxMock.defaultExpectation.expectationOrigins.origin, *m.WithTxMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcWithTx != nil &amp;&amp; afterWithTxCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TxManagerMock.WithTx at\n%s", m.funcWithTxOrigin)
        }</span>

        <span class="cov0" title="0">if !m.WithTxMock.invocationsDone() &amp;&amp; afterWithTxCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TxManagerMock.WithTx at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.WithTxMock.expectedInvocations), m.WithTxMock.expectedInvocationsOrigin, afterWithTxCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TxManagerMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockGetExecutorInspect()

                        m.MinimockWithReadOnlyInspect()

                        m.MinimockWithTxInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TxManagerMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *TxManagerMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockGetExecutorDone() &amp;&amp;
                m.MinimockWithReadOnlyDone() &amp;&amp;
                m.MinimockWithTxDone()
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package txmanager

import (
        "context"
        "errors"
        "pvz-cli/pkg/logger"
        "sync/atomic"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"
)

type Executor interface {
        Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error)
        Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)
        QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
}

type TxManager interface {
        GetExecutor(ctx context.Context) Executor
        WithTx(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error) error
        WithReadOnly(ctx context.Context) context.Context
}

var (
        IsolationLevelSerializable   = pgx.Serializable
        IsolationLevelReadCommitted  = pgx.ReadCommitted
        IsolationLevelRepeatableRead = pgx.RepeatableRead

        AccessModeReadWrite = pgx.ReadWrite
        AccessModeReadOnly  = pgx.ReadOnly
)

type txKey struct{}

type Transactor struct {
        writePool *pgxpool.Pool
        readPools []*pgxpool.Pool
        rrCounter uint64
        logger    logger.Logger
}

func NewTransactor(writePool *pgxpool.Pool, readPools []*pgxpool.Pool, logger logger.Logger) *Transactor <span class="cov0" title="0">{
        return &amp;Transactor{
                writePool: writePool,
                readPools: readPools,
                rrCounter: 0,
                logger:    logger,
        }
}</span>

func (t *Transactor) poolForMode(mode pgx.TxAccessMode) *pgxpool.Pool <span class="cov0" title="0">{
        if mode == AccessModeReadOnly </span><span class="cov0" title="0">{
                return t.pickRead()
        }</span>
        <span class="cov0" title="0">return t.writePool</span>
}

func (t *Transactor) pickRead() *pgxpool.Pool <span class="cov0" title="0">{
        n := len(t.readPools)
        if n == 0 </span><span class="cov0" title="0">{
                return t.writePool
        }</span>
        <span class="cov0" title="0">idx := atomic.AddUint64(&amp;t.rrCounter, 1) - 1
        return t.readPools[int(idx%uint64(n))]</span>
}

// injectTx injects transaction to context
func injectTx(ctx context.Context, tx pgx.Tx) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, txKey{}, tx)
}</span>

// extractTx extracts transaction from context
func extractTx(ctx context.Context) pgx.Tx <span class="cov0" title="0">{
        if tx, ok := ctx.Value(txKey{}).(pgx.Tx); ok </span><span class="cov0" title="0">{
                return tx
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (t *Transactor) WithTx(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error) (err error) <span class="cov0" title="0">{
        opts := pgx.TxOptions{
                IsoLevel:   isoLevel,
                AccessMode: accessMode,
        }

        poolToUse := t.poolForMode(accessMode)

        tx, err := poolToUse.BeginTx(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                t.logger.Errorw("Failed to begin transaction",
                        "error", err,
                        "isoLevel", isoLevel,
                        "accessMode", accessMode,
                )
                return err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if rbErr := tx.Rollback(ctx); rbErr != nil &amp;&amp; !errors.Is(rbErr, pgx.ErrTxClosed) </span><span class="cov0" title="0">{
                                t.logger.Errorw("Failed to rollback transaction",
                                        "error", rbErr,
                                )
                        }</span>
                }
        }()

        <span class="cov0" title="0">ctx = injectTx(ctx, tx)

        if err = fn(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                t.logger.Errorw("Failed to commit transaction",
                        "error", err,
                )
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (t *Transactor) GetExecutor(ctx context.Context) Executor <span class="cov0" title="0">{
        if tx := extractTx(ctx); tx != nil </span><span class="cov0" title="0">{
                return tx
        }</span>

        <span class="cov0" title="0">if mode, ok := extractAccessMode(ctx); ok &amp;&amp; mode == AccessModeReadOnly </span><span class="cov0" title="0">{
                return t.pickRead()
        }</span>

        // default — master
        <span class="cov0" title="0">return t.writePool</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.0
//         protoc        (unknown)
// source: protoc-gen-openapiv2/options/annotations.proto

//go:build !protoopaque

package options

import (
        reflect "reflect"

        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        descriptorpb "google.golang.org/protobuf/types/descriptorpb"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

var file_protoc_gen_openapiv2_options_annotations_proto_extTypes = []protoimpl.ExtensionInfo{
        {
                ExtendedType:  (*descriptorpb.FileOptions)(nil),
                ExtensionType: (*Swagger)(nil),
                Field:         1042,
                Name:          "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger",
                Tag:           "bytes,1042,opt,name=openapiv2_swagger",
                Filename:      "protoc-gen-openapiv2/options/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MethodOptions)(nil),
                ExtensionType: (*Operation)(nil),
                Field:         1042,
                Name:          "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation",
                Tag:           "bytes,1042,opt,name=openapiv2_operation",
                Filename:      "protoc-gen-openapiv2/options/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MessageOptions)(nil),
                ExtensionType: (*Schema)(nil),
                Field:         1042,
                Name:          "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema",
                Tag:           "bytes,1042,opt,name=openapiv2_schema",
                Filename:      "protoc-gen-openapiv2/options/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.EnumOptions)(nil),
                ExtensionType: (*EnumSchema)(nil),
                Field:         1042,
                Name:          "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_enum",
                Tag:           "bytes,1042,opt,name=openapiv2_enum",
                Filename:      "protoc-gen-openapiv2/options/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.ServiceOptions)(nil),
                ExtensionType: (*Tag)(nil),
                Field:         1042,
                Name:          "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_tag",
                Tag:           "bytes,1042,opt,name=openapiv2_tag",
                Filename:      "protoc-gen-openapiv2/options/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.FieldOptions)(nil),
                ExtensionType: (*JSONSchema)(nil),
                Field:         1042,
                Name:          "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field",
                Tag:           "bytes,1042,opt,name=openapiv2_field",
                Filename:      "protoc-gen-openapiv2/options/annotations.proto",
        },
}

// Extension fields to descriptorpb.FileOptions.
var (
        // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
        //
        // All IDs are the same, as assigned. It is okay that they are the same, as they extend
        // different descriptor messages.
        //
        // optional grpc.gateway.protoc_gen_openapiv2.options.Swagger openapiv2_swagger = 1042;
        E_Openapiv2Swagger = &amp;file_protoc_gen_openapiv2_options_annotations_proto_extTypes[0]
)

// Extension fields to descriptorpb.MethodOptions.
var (
        // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
        //
        // All IDs are the same, as assigned. It is okay that they are the same, as they extend
        // different descriptor messages.
        //
        // optional grpc.gateway.protoc_gen_openapiv2.options.Operation openapiv2_operation = 1042;
        E_Openapiv2Operation = &amp;file_protoc_gen_openapiv2_options_annotations_proto_extTypes[1]
)

// Extension fields to descriptorpb.MessageOptions.
var (
        // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
        //
        // All IDs are the same, as assigned. It is okay that they are the same, as they extend
        // different descriptor messages.
        //
        // optional grpc.gateway.protoc_gen_openapiv2.options.Schema openapiv2_schema = 1042;
        E_Openapiv2Schema = &amp;file_protoc_gen_openapiv2_options_annotations_proto_extTypes[2]
)

// Extension fields to descriptorpb.EnumOptions.
var (
        // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
        //
        // All IDs are the same, as assigned. It is okay that they are the same, as they extend
        // different descriptor messages.
        //
        // optional grpc.gateway.protoc_gen_openapiv2.options.EnumSchema openapiv2_enum = 1042;
        E_Openapiv2Enum = &amp;file_protoc_gen_openapiv2_options_annotations_proto_extTypes[3]
)

// Extension fields to descriptorpb.ServiceOptions.
var (
        // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
        //
        // All IDs are the same, as assigned. It is okay that they are the same, as they extend
        // different descriptor messages.
        //
        // optional grpc.gateway.protoc_gen_openapiv2.options.Tag openapiv2_tag = 1042;
        E_Openapiv2Tag = &amp;file_protoc_gen_openapiv2_options_annotations_proto_extTypes[4]
)

// Extension fields to descriptorpb.FieldOptions.
var (
        // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
        //
        // All IDs are the same, as assigned. It is okay that they are the same, as they extend
        // different descriptor messages.
        //
        // optional grpc.gateway.protoc_gen_openapiv2.options.JSONSchema openapiv2_field = 1042;
        E_Openapiv2Field = &amp;file_protoc_gen_openapiv2_options_annotations_proto_extTypes[5]
)

var File_protoc_gen_openapiv2_options_annotations_proto protoreflect.FileDescriptor

var file_protoc_gen_openapiv2_options_annotations_proto_rawDesc = []byte{
        0x0a, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e, 0x2d, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x61,
        0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x12, 0x29, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70,
        0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x20, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x65, 0x73,
        0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2c, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e, 0x2d, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70,
        0x69, 0x76, 0x32, 0x2f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x6f, 0x70, 0x65, 0x6e,
        0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x3a, 0x7e, 0x0a, 0x11, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x5f, 0x73, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72,
        0x12, 0x1c, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
        0x75, 0x66, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x92,
        0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74,
        0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f,
        0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x2e, 0x53, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x52, 0x10, 0x6f, 0x70, 0x65, 0x6e, 0x61,
        0x70, 0x69, 0x76, 0x32, 0x53, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x3a, 0x86, 0x01, 0x0a, 0x13,
        0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x5f, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x12, 0x1e, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x4f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x18, 0x92, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x67, 0x72, 0x70,
        0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
        0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
        0x52, 0x12, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x4f, 0x70, 0x65, 0x72, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x7e, 0x0a, 0x10, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61,
        0x67, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x92, 0x08, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x31, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61,
        0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x63, 0x68,
        0x65, 0x6d, 0x61, 0x52, 0x0f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x53, 0x63,
        0x68, 0x65, 0x6d, 0x61, 0x3a, 0x7b, 0x0a, 0x0e, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x5f, 0x65, 0x6e, 0x75, 0x6d, 0x12, 0x1c, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6e, 0x75, 0x6d, 0x4f, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x73, 0x18, 0x92, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x67, 0x72,
        0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e,
        0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x45, 0x6e, 0x75, 0x6d, 0x53, 0x63, 0x68, 0x65,
        0x6d, 0x61, 0x52, 0x0d, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x45, 0x6e, 0x75,
        0x6d, 0x3a, 0x75, 0x0a, 0x0d, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x5f, 0x74,
        0x61, 0x67, 0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x4f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x18, 0x92, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x67, 0x72, 0x70,
        0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
        0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x54, 0x61, 0x67, 0x52, 0x0c, 0x6f, 0x70, 0x65, 0x6e,
        0x61, 0x70, 0x69, 0x76, 0x32, 0x54, 0x61, 0x67, 0x3a, 0x7e, 0x0a, 0x0f, 0x6f, 0x70, 0x65, 0x6e,
        0x61, 0x70, 0x69, 0x76, 0x32, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x12, 0x1d, 0x2e, 0x67, 0x6f,
        0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x46, 0x69,
        0x65, 0x6c, 0x64, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x92, 0x08, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x35, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e,
        0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4a, 0x53,
        0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x52, 0x0e, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70,
        0x69, 0x76, 0x32, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x42, 0x48, 0x5a, 0x46, 0x67, 0x69, 0x74, 0x68,
        0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x2d, 0x65, 0x63, 0x6f, 0x73,
        0x79, 0x73, 0x74, 0x65, 0x6d, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x2d, 0x67, 0x61, 0x74, 0x65, 0x77,
        0x61, 0x79, 0x2f, 0x76, 0x32, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e,
        0x2d, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2f, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var file_protoc_gen_openapiv2_options_annotations_proto_goTypes = []any{
        (*descriptorpb.FileOptions)(nil),    // 0: google.protobuf.FileOptions
        (*descriptorpb.MethodOptions)(nil),  // 1: google.protobuf.MethodOptions
        (*descriptorpb.MessageOptions)(nil), // 2: google.protobuf.MessageOptions
        (*descriptorpb.EnumOptions)(nil),    // 3: google.protobuf.EnumOptions
        (*descriptorpb.ServiceOptions)(nil), // 4: google.protobuf.ServiceOptions
        (*descriptorpb.FieldOptions)(nil),   // 5: google.protobuf.FieldOptions
        (*Swagger)(nil),                     // 6: grpc.gateway.protoc_gen_openapiv2.options.Swagger
        (*Operation)(nil),                   // 7: grpc.gateway.protoc_gen_openapiv2.options.Operation
        (*Schema)(nil),                      // 8: grpc.gateway.protoc_gen_openapiv2.options.Schema
        (*EnumSchema)(nil),                  // 9: grpc.gateway.protoc_gen_openapiv2.options.EnumSchema
        (*Tag)(nil),                         // 10: grpc.gateway.protoc_gen_openapiv2.options.Tag
        (*JSONSchema)(nil),                  // 11: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema
}
var file_protoc_gen_openapiv2_options_annotations_proto_depIdxs = []int32{
        0,  // 0: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger:extendee -&gt; google.protobuf.FileOptions
        1,  // 1: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation:extendee -&gt; google.protobuf.MethodOptions
        2,  // 2: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema:extendee -&gt; google.protobuf.MessageOptions
        3,  // 3: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_enum:extendee -&gt; google.protobuf.EnumOptions
        4,  // 4: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_tag:extendee -&gt; google.protobuf.ServiceOptions
        5,  // 5: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field:extendee -&gt; google.protobuf.FieldOptions
        6,  // 6: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Swagger
        7,  // 7: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Operation
        8,  // 8: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Schema
        9,  // 9: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_enum:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.EnumSchema
        10, // 10: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_tag:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Tag
        11, // 11: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.JSONSchema
        12, // [12:12] is the sub-list for method output_type
        12, // [12:12] is the sub-list for method input_type
        6,  // [6:12] is the sub-list for extension type_name
        0,  // [0:6] is the sub-list for extension extendee
        0,  // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_protoc_gen_openapiv2_options_annotations_proto_init() }</span>
func file_protoc_gen_openapiv2_options_annotations_proto_init() <span class="cov0" title="0">{
        if File_protoc_gen_openapiv2_options_annotations_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_init()
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_protoc_gen_openapiv2_options_annotations_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   0,
                        NumExtensions: 6,
                        NumServices:   0,
                },
                GoTypes:           file_protoc_gen_openapiv2_options_annotations_proto_goTypes,
                DependencyIndexes: file_protoc_gen_openapiv2_options_annotations_proto_depIdxs,
                ExtensionInfos:    file_protoc_gen_openapiv2_options_annotations_proto_extTypes,
        }.Build()
        File_protoc_gen_openapiv2_options_annotations_proto = out.File
        file_protoc_gen_openapiv2_options_annotations_proto_rawDesc = nil
        file_protoc_gen_openapiv2_options_annotations_proto_goTypes = nil
        file_protoc_gen_openapiv2_options_annotations_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.0
//         protoc        (unknown)
// source: protoc-gen-openapiv2/options/openapiv2.proto

//go:build !protoopaque

package options

import (
        reflect "reflect"

        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        structpb "google.golang.org/protobuf/types/known/structpb"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Scheme describes the schemes supported by the OpenAPI Swagger
// and Operation objects.
type Scheme int32

const (
        Scheme_UNKNOWN Scheme = 0
        Scheme_HTTP    Scheme = 1
        Scheme_HTTPS   Scheme = 2
        Scheme_WS      Scheme = 3
        Scheme_WSS     Scheme = 4
)

// Enum value maps for Scheme.
var (
        Scheme_name = map[int32]string{
                0: "UNKNOWN",
                1: "HTTP",
                2: "HTTPS",
                3: "WS",
                4: "WSS",
        }
        Scheme_value = map[string]int32{
                "UNKNOWN": 0,
                "HTTP":    1,
                "HTTPS":   2,
                "WS":      3,
                "WSS":     4,
        }
)

func (x Scheme) Enum() *Scheme <span class="cov0" title="0">{
        p := new(Scheme)
        *p = x
        return p
}</span>

func (x Scheme) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (Scheme) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[0].Descriptor()
}</span>

func (Scheme) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[0]
}</span>

func (x Scheme) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// `Type` is a supported HTTP header type.
// See https://swagger.io/specification/v2/#parameterType.
type HeaderParameter_Type int32

const (
        HeaderParameter_UNKNOWN HeaderParameter_Type = 0
        HeaderParameter_STRING  HeaderParameter_Type = 1
        HeaderParameter_NUMBER  HeaderParameter_Type = 2
        HeaderParameter_INTEGER HeaderParameter_Type = 3
        HeaderParameter_BOOLEAN HeaderParameter_Type = 4
)

// Enum value maps for HeaderParameter_Type.
var (
        HeaderParameter_Type_name = map[int32]string{
                0: "UNKNOWN",
                1: "STRING",
                2: "NUMBER",
                3: "INTEGER",
                4: "BOOLEAN",
        }
        HeaderParameter_Type_value = map[string]int32{
                "UNKNOWN": 0,
                "STRING":  1,
                "NUMBER":  2,
                "INTEGER": 3,
                "BOOLEAN": 4,
        }
)

func (x HeaderParameter_Type) Enum() *HeaderParameter_Type <span class="cov0" title="0">{
        p := new(HeaderParameter_Type)
        *p = x
        return p
}</span>

func (x HeaderParameter_Type) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (HeaderParameter_Type) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[1].Descriptor()
}</span>

func (HeaderParameter_Type) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[1]
}</span>

func (x HeaderParameter_Type) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

type JSONSchema_JSONSchemaSimpleTypes int32

const (
        JSONSchema_UNKNOWN JSONSchema_JSONSchemaSimpleTypes = 0
        JSONSchema_ARRAY   JSONSchema_JSONSchemaSimpleTypes = 1
        JSONSchema_BOOLEAN JSONSchema_JSONSchemaSimpleTypes = 2
        JSONSchema_INTEGER JSONSchema_JSONSchemaSimpleTypes = 3
        JSONSchema_NULL    JSONSchema_JSONSchemaSimpleTypes = 4
        JSONSchema_NUMBER  JSONSchema_JSONSchemaSimpleTypes = 5
        JSONSchema_OBJECT  JSONSchema_JSONSchemaSimpleTypes = 6
        JSONSchema_STRING  JSONSchema_JSONSchemaSimpleTypes = 7
)

// Enum value maps for JSONSchema_JSONSchemaSimpleTypes.
var (
        JSONSchema_JSONSchemaSimpleTypes_name = map[int32]string{
                0: "UNKNOWN",
                1: "ARRAY",
                2: "BOOLEAN",
                3: "INTEGER",
                4: "NULL",
                5: "NUMBER",
                6: "OBJECT",
                7: "STRING",
        }
        JSONSchema_JSONSchemaSimpleTypes_value = map[string]int32{
                "UNKNOWN": 0,
                "ARRAY":   1,
                "BOOLEAN": 2,
                "INTEGER": 3,
                "NULL":    4,
                "NUMBER":  5,
                "OBJECT":  6,
                "STRING":  7,
        }
)

func (x JSONSchema_JSONSchemaSimpleTypes) Enum() *JSONSchema_JSONSchemaSimpleTypes <span class="cov0" title="0">{
        p := new(JSONSchema_JSONSchemaSimpleTypes)
        *p = x
        return p
}</span>

func (x JSONSchema_JSONSchemaSimpleTypes) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (JSONSchema_JSONSchemaSimpleTypes) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[2].Descriptor()
}</span>

func (JSONSchema_JSONSchemaSimpleTypes) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[2]
}</span>

func (x JSONSchema_JSONSchemaSimpleTypes) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// The type of the security scheme. Valid values are "basic",
// "apiKey" or "oauth2".
type SecurityScheme_Type int32

const (
        SecurityScheme_TYPE_INVALID SecurityScheme_Type = 0
        SecurityScheme_TYPE_BASIC   SecurityScheme_Type = 1
        SecurityScheme_TYPE_API_KEY SecurityScheme_Type = 2
        SecurityScheme_TYPE_OAUTH2  SecurityScheme_Type = 3
)

// Enum value maps for SecurityScheme_Type.
var (
        SecurityScheme_Type_name = map[int32]string{
                0: "TYPE_INVALID",
                1: "TYPE_BASIC",
                2: "TYPE_API_KEY",
                3: "TYPE_OAUTH2",
        }
        SecurityScheme_Type_value = map[string]int32{
                "TYPE_INVALID": 0,
                "TYPE_BASIC":   1,
                "TYPE_API_KEY": 2,
                "TYPE_OAUTH2":  3,
        }
)

func (x SecurityScheme_Type) Enum() *SecurityScheme_Type <span class="cov0" title="0">{
        p := new(SecurityScheme_Type)
        *p = x
        return p
}</span>

func (x SecurityScheme_Type) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (SecurityScheme_Type) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[3].Descriptor()
}</span>

func (SecurityScheme_Type) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[3]
}</span>

func (x SecurityScheme_Type) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// The location of the API key. Valid values are "query" or "header".
type SecurityScheme_In int32

const (
        SecurityScheme_IN_INVALID SecurityScheme_In = 0
        SecurityScheme_IN_QUERY   SecurityScheme_In = 1
        SecurityScheme_IN_HEADER  SecurityScheme_In = 2
)

// Enum value maps for SecurityScheme_In.
var (
        SecurityScheme_In_name = map[int32]string{
                0: "IN_INVALID",
                1: "IN_QUERY",
                2: "IN_HEADER",
        }
        SecurityScheme_In_value = map[string]int32{
                "IN_INVALID": 0,
                "IN_QUERY":   1,
                "IN_HEADER":  2,
        }
)

func (x SecurityScheme_In) Enum() *SecurityScheme_In <span class="cov0" title="0">{
        p := new(SecurityScheme_In)
        *p = x
        return p
}</span>

func (x SecurityScheme_In) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (SecurityScheme_In) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[4].Descriptor()
}</span>

func (SecurityScheme_In) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[4]
}</span>

func (x SecurityScheme_In) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// The flow used by the OAuth2 security scheme. Valid values are
// "implicit", "password", "application" or "accessCode".
type SecurityScheme_Flow int32

const (
        SecurityScheme_FLOW_INVALID     SecurityScheme_Flow = 0
        SecurityScheme_FLOW_IMPLICIT    SecurityScheme_Flow = 1
        SecurityScheme_FLOW_PASSWORD    SecurityScheme_Flow = 2
        SecurityScheme_FLOW_APPLICATION SecurityScheme_Flow = 3
        SecurityScheme_FLOW_ACCESS_CODE SecurityScheme_Flow = 4
)

// Enum value maps for SecurityScheme_Flow.
var (
        SecurityScheme_Flow_name = map[int32]string{
                0: "FLOW_INVALID",
                1: "FLOW_IMPLICIT",
                2: "FLOW_PASSWORD",
                3: "FLOW_APPLICATION",
                4: "FLOW_ACCESS_CODE",
        }
        SecurityScheme_Flow_value = map[string]int32{
                "FLOW_INVALID":     0,
                "FLOW_IMPLICIT":    1,
                "FLOW_PASSWORD":    2,
                "FLOW_APPLICATION": 3,
                "FLOW_ACCESS_CODE": 4,
        }
)

func (x SecurityScheme_Flow) Enum() *SecurityScheme_Flow <span class="cov0" title="0">{
        p := new(SecurityScheme_Flow)
        *p = x
        return p
}</span>

func (x SecurityScheme_Flow) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (SecurityScheme_Flow) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[5].Descriptor()
}</span>

func (SecurityScheme_Flow) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[5]
}</span>

func (x SecurityScheme_Flow) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// `Swagger` is a representation of OpenAPI v2 specification's Swagger object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#swaggerObject
//
// Example:
//
//        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//          info: {
//            title: "Echo API";
//            version: "1.0";
//            description: "";
//            contact: {
//              name: "gRPC-Gateway project";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway";
//              email: "none@example.com";
//            };
//            license: {
//              name: "BSD 3-Clause License";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/main/LICENSE";
//            };
//          };
//          schemes: HTTPS;
//          consumes: "application/json";
//          produces: "application/json";
//        };
type Swagger struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // Specifies the OpenAPI Specification version being used. It can be
        // used by the OpenAPI UI and other clients to interpret the API listing. The
        // value MUST be "2.0".
        Swagger string `protobuf:"bytes,1,opt,name=swagger,proto3" json:"swagger,omitempty"`
        // Provides metadata about the API. The metadata can be used by the
        // clients if needed.
        Info *Info `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
        // The host (name or ip) serving the API. This MUST be the host only and does
        // not include the scheme nor sub-paths. It MAY include a port. If the host is
        // not included, the host serving the documentation is to be used (including
        // the port). The host does not support path templating.
        Host string `protobuf:"bytes,3,opt,name=host,proto3" json:"host,omitempty"`
        // The base path on which the API is served, which is relative to the host. If
        // it is not included, the API is served directly under the host. The value
        // MUST start with a leading slash (/). The basePath does not support path
        // templating.
        // Note that using `base_path` does not change the endpoint paths that are
        // generated in the resulting OpenAPI file. If you wish to use `base_path`
        // with relatively generated OpenAPI paths, the `base_path` prefix must be
        // manually removed from your `google.api.http` paths and your code changed to
        // serve the API from the `base_path`.
        BasePath string `protobuf:"bytes,4,opt,name=base_path,json=basePath,proto3" json:"base_path,omitempty"`
        // The transfer protocol of the API. Values MUST be from the list: "http",
        // "https", "ws", "wss". If the schemes is not included, the default scheme to
        // be used is the one used to access the OpenAPI definition itself.
        Schemes []Scheme `protobuf:"varint,5,rep,packed,name=schemes,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.Scheme" json:"schemes,omitempty"`
        // A list of MIME types the APIs can consume. This is global to all APIs but
        // can be overridden on specific API calls. Value MUST be as described under
        // Mime Types.
        Consumes []string `protobuf:"bytes,6,rep,name=consumes,proto3" json:"consumes,omitempty"`
        // A list of MIME types the APIs can produce. This is global to all APIs but
        // can be overridden on specific API calls. Value MUST be as described under
        // Mime Types.
        Produces []string `protobuf:"bytes,7,rep,name=produces,proto3" json:"produces,omitempty"`
        // An object to hold responses that can be used across operations. This
        // property does not define global responses for all operations.
        Responses map[string]*Response `protobuf:"bytes,10,rep,name=responses,proto3" json:"responses,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        // Security scheme definitions that can be used across the specification.
        SecurityDefinitions *SecurityDefinitions `protobuf:"bytes,11,opt,name=security_definitions,json=securityDefinitions,proto3" json:"security_definitions,omitempty"`
        // A declaration of which security schemes are applied for the API as a whole.
        // The list of values describes alternative security schemes that can be used
        // (that is, there is a logical OR between the security requirements).
        // Individual operations can override this definition.
        Security []*SecurityRequirement `protobuf:"bytes,12,rep,name=security,proto3" json:"security,omitempty"`
        // A list of tags for API documentation control. Tags can be used for logical
        // grouping of operations by resources or any other qualifier.
        Tags []*Tag `protobuf:"bytes,13,rep,name=tags,proto3" json:"tags,omitempty"`
        // Additional external documentation.
        ExternalDocs *ExternalDocumentation `protobuf:"bytes,14,opt,name=external_docs,json=externalDocs,proto3" json:"external_docs,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions    map[string]*structpb.Value `protobuf:"bytes,15,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Swagger) Reset() <span class="cov0" title="0">{
        *x = Swagger{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Swagger) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Swagger) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Swagger) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Swagger) GetSwagger() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Swagger
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Swagger) GetInfo() *Info <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Info
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetHost() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Host
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Swagger) GetBasePath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BasePath
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Swagger) GetSchemes() []Scheme <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Schemes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetConsumes() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Consumes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetProduces() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Produces
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetResponses() map[string]*Response <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Responses
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetSecurityDefinitions() *SecurityDefinitions <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SecurityDefinitions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetSecurity() []*SecurityRequirement <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Security
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetTags() []*Tag <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetExternalDocs() *ExternalDocumentation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExternalDocs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) SetSwagger(v string) <span class="cov0" title="0">{
        x.Swagger = v
}</span>

func (x *Swagger) SetInfo(v *Info) <span class="cov0" title="0">{
        x.Info = v
}</span>

func (x *Swagger) SetHost(v string) <span class="cov0" title="0">{
        x.Host = v
}</span>

func (x *Swagger) SetBasePath(v string) <span class="cov0" title="0">{
        x.BasePath = v
}</span>

func (x *Swagger) SetSchemes(v []Scheme) <span class="cov0" title="0">{
        x.Schemes = v
}</span>

func (x *Swagger) SetConsumes(v []string) <span class="cov0" title="0">{
        x.Consumes = v
}</span>

func (x *Swagger) SetProduces(v []string) <span class="cov0" title="0">{
        x.Produces = v
}</span>

func (x *Swagger) SetResponses(v map[string]*Response) <span class="cov0" title="0">{
        x.Responses = v
}</span>

func (x *Swagger) SetSecurityDefinitions(v *SecurityDefinitions) <span class="cov0" title="0">{
        x.SecurityDefinitions = v
}</span>

func (x *Swagger) SetSecurity(v []*SecurityRequirement) <span class="cov0" title="0">{
        x.Security = v
}</span>

func (x *Swagger) SetTags(v []*Tag) <span class="cov0" title="0">{
        x.Tags = v
}</span>

func (x *Swagger) SetExternalDocs(v *ExternalDocumentation) <span class="cov0" title="0">{
        x.ExternalDocs = v
}</span>

func (x *Swagger) SetExtensions(v map[string]*structpb.Value) <span class="cov0" title="0">{
        x.Extensions = v
}</span>

func (x *Swagger) HasInfo() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.Info != nil</span>
}

func (x *Swagger) HasSecurityDefinitions() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.SecurityDefinitions != nil</span>
}

func (x *Swagger) HasExternalDocs() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.ExternalDocs != nil</span>
}

func (x *Swagger) ClearInfo() <span class="cov0" title="0">{
        x.Info = nil
}</span>

func (x *Swagger) ClearSecurityDefinitions() <span class="cov0" title="0">{
        x.SecurityDefinitions = nil
}</span>

func (x *Swagger) ClearExternalDocs() <span class="cov0" title="0">{
        x.ExternalDocs = nil
}</span>

type Swagger_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // Specifies the OpenAPI Specification version being used. It can be
        // used by the OpenAPI UI and other clients to interpret the API listing. The
        // value MUST be "2.0".
        Swagger string
        // Provides metadata about the API. The metadata can be used by the
        // clients if needed.
        Info *Info
        // The host (name or ip) serving the API. This MUST be the host only and does
        // not include the scheme nor sub-paths. It MAY include a port. If the host is
        // not included, the host serving the documentation is to be used (including
        // the port). The host does not support path templating.
        Host string
        // The base path on which the API is served, which is relative to the host. If
        // it is not included, the API is served directly under the host. The value
        // MUST start with a leading slash (/). The basePath does not support path
        // templating.
        // Note that using `base_path` does not change the endpoint paths that are
        // generated in the resulting OpenAPI file. If you wish to use `base_path`
        // with relatively generated OpenAPI paths, the `base_path` prefix must be
        // manually removed from your `google.api.http` paths and your code changed to
        // serve the API from the `base_path`.
        BasePath string
        // The transfer protocol of the API. Values MUST be from the list: "http",
        // "https", "ws", "wss". If the schemes is not included, the default scheme to
        // be used is the one used to access the OpenAPI definition itself.
        Schemes []Scheme
        // A list of MIME types the APIs can consume. This is global to all APIs but
        // can be overridden on specific API calls. Value MUST be as described under
        // Mime Types.
        Consumes []string
        // A list of MIME types the APIs can produce. This is global to all APIs but
        // can be overridden on specific API calls. Value MUST be as described under
        // Mime Types.
        Produces []string
        // An object to hold responses that can be used across operations. This
        // property does not define global responses for all operations.
        Responses map[string]*Response
        // Security scheme definitions that can be used across the specification.
        SecurityDefinitions *SecurityDefinitions
        // A declaration of which security schemes are applied for the API as a whole.
        // The list of values describes alternative security schemes that can be used
        // (that is, there is a logical OR between the security requirements).
        // Individual operations can override this definition.
        Security []*SecurityRequirement
        // A list of tags for API documentation control. Tags can be used for logical
        // grouping of operations by resources or any other qualifier.
        Tags []*Tag
        // Additional external documentation.
        ExternalDocs *ExternalDocumentation
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value
}

func (b0 Swagger_builder) Build() *Swagger <span class="cov0" title="0">{
        m0 := &amp;Swagger{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Swagger = b.Swagger
        x.Info = b.Info
        x.Host = b.Host
        x.BasePath = b.BasePath
        x.Schemes = b.Schemes
        x.Consumes = b.Consumes
        x.Produces = b.Produces
        x.Responses = b.Responses
        x.SecurityDefinitions = b.SecurityDefinitions
        x.Security = b.Security
        x.Tags = b.Tags
        x.ExternalDocs = b.ExternalDocs
        x.Extensions = b.Extensions
        return m0
}</span>

// `Operation` is a representation of OpenAPI v2 specification's Operation object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#operationObject
//
// Example:
//
//        service EchoService {
//          rpc Echo(SimpleMessage) returns (SimpleMessage) {
//            option (google.api.http) = {
//              get: "/v1/example/echo/{id}"
//            };
//
//            option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
//              summary: "Get a message.";
//              operation_id: "getMessage";
//              tags: "echo";
//              responses: {
//                key: "200"
//                  value: {
//                  description: "OK";
//                }
//              }
//            };
//          }
//        }
type Operation struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // A list of tags for API documentation control. Tags can be used for logical
        // grouping of operations by resources or any other qualifier.
        Tags []string `protobuf:"bytes,1,rep,name=tags,proto3" json:"tags,omitempty"`
        // A short summary of what the operation does. For maximum readability in the
        // swagger-ui, this field SHOULD be less than 120 characters.
        Summary string `protobuf:"bytes,2,opt,name=summary,proto3" json:"summary,omitempty"`
        // A verbose explanation of the operation behavior. GFM syntax can be used for
        // rich text representation.
        Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
        // Additional external documentation for this operation.
        ExternalDocs *ExternalDocumentation `protobuf:"bytes,4,opt,name=external_docs,json=externalDocs,proto3" json:"external_docs,omitempty"`
        // Unique string used to identify the operation. The id MUST be unique among
        // all operations described in the API. Tools and libraries MAY use the
        // operationId to uniquely identify an operation, therefore, it is recommended
        // to follow common programming naming conventions.
        OperationId string `protobuf:"bytes,5,opt,name=operation_id,json=operationId,proto3" json:"operation_id,omitempty"`
        // A list of MIME types the operation can consume. This overrides the consumes
        // definition at the OpenAPI Object. An empty value MAY be used to clear the
        // global definition. Value MUST be as described under Mime Types.
        Consumes []string `protobuf:"bytes,6,rep,name=consumes,proto3" json:"consumes,omitempty"`
        // A list of MIME types the operation can produce. This overrides the produces
        // definition at the OpenAPI Object. An empty value MAY be used to clear the
        // global definition. Value MUST be as described under Mime Types.
        Produces []string `protobuf:"bytes,7,rep,name=produces,proto3" json:"produces,omitempty"`
        // The list of possible responses as they are returned from executing this
        // operation.
        Responses map[string]*Response `protobuf:"bytes,9,rep,name=responses,proto3" json:"responses,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        // The transfer protocol for the operation. Values MUST be from the list:
        // "http", "https", "ws", "wss". The value overrides the OpenAPI Object
        // schemes definition.
        Schemes []Scheme `protobuf:"varint,10,rep,packed,name=schemes,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.Scheme" json:"schemes,omitempty"`
        // Declares this operation to be deprecated. Usage of the declared operation
        // should be refrained. Default value is false.
        Deprecated bool `protobuf:"varint,11,opt,name=deprecated,proto3" json:"deprecated,omitempty"`
        // A declaration of which security schemes are applied for this operation. The
        // list of values describes alternative security schemes that can be used
        // (that is, there is a logical OR between the security requirements). This
        // definition overrides any declared top-level security. To remove a top-level
        // security declaration, an empty array can be used.
        Security []*SecurityRequirement `protobuf:"bytes,12,rep,name=security,proto3" json:"security,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value `protobuf:"bytes,13,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        // Custom parameters such as HTTP request headers.
        // See: https://swagger.io/docs/specification/2-0/describing-parameters/
        // and https://swagger.io/specification/v2/#parameter-object.
        Parameters    *Parameters `protobuf:"bytes,14,opt,name=parameters,proto3" json:"parameters,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Operation) Reset() <span class="cov0" title="0">{
        *x = Operation{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Operation) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Operation) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Operation) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Operation) GetTags() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetSummary() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Summary
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Operation) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Operation) GetExternalDocs() *ExternalDocumentation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExternalDocs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetOperationId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OperationId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Operation) GetConsumes() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Consumes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetProduces() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Produces
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetResponses() map[string]*Response <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Responses
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetSchemes() []Scheme <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Schemes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetDeprecated() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Deprecated
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Operation) GetSecurity() []*SecurityRequirement <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Security
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetParameters() *Parameters <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Parameters
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) SetTags(v []string) <span class="cov0" title="0">{
        x.Tags = v
}</span>

func (x *Operation) SetSummary(v string) <span class="cov0" title="0">{
        x.Summary = v
}</span>

func (x *Operation) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *Operation) SetExternalDocs(v *ExternalDocumentation) <span class="cov0" title="0">{
        x.ExternalDocs = v
}</span>

func (x *Operation) SetOperationId(v string) <span class="cov0" title="0">{
        x.OperationId = v
}</span>

func (x *Operation) SetConsumes(v []string) <span class="cov0" title="0">{
        x.Consumes = v
}</span>

func (x *Operation) SetProduces(v []string) <span class="cov0" title="0">{
        x.Produces = v
}</span>

func (x *Operation) SetResponses(v map[string]*Response) <span class="cov0" title="0">{
        x.Responses = v
}</span>

func (x *Operation) SetSchemes(v []Scheme) <span class="cov0" title="0">{
        x.Schemes = v
}</span>

func (x *Operation) SetDeprecated(v bool) <span class="cov0" title="0">{
        x.Deprecated = v
}</span>

func (x *Operation) SetSecurity(v []*SecurityRequirement) <span class="cov0" title="0">{
        x.Security = v
}</span>

func (x *Operation) SetExtensions(v map[string]*structpb.Value) <span class="cov0" title="0">{
        x.Extensions = v
}</span>

func (x *Operation) SetParameters(v *Parameters) <span class="cov0" title="0">{
        x.Parameters = v
}</span>

func (x *Operation) HasExternalDocs() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.ExternalDocs != nil</span>
}

func (x *Operation) HasParameters() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.Parameters != nil</span>
}

func (x *Operation) ClearExternalDocs() <span class="cov0" title="0">{
        x.ExternalDocs = nil
}</span>

func (x *Operation) ClearParameters() <span class="cov0" title="0">{
        x.Parameters = nil
}</span>

type Operation_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // A list of tags for API documentation control. Tags can be used for logical
        // grouping of operations by resources or any other qualifier.
        Tags []string
        // A short summary of what the operation does. For maximum readability in the
        // swagger-ui, this field SHOULD be less than 120 characters.
        Summary string
        // A verbose explanation of the operation behavior. GFM syntax can be used for
        // rich text representation.
        Description string
        // Additional external documentation for this operation.
        ExternalDocs *ExternalDocumentation
        // Unique string used to identify the operation. The id MUST be unique among
        // all operations described in the API. Tools and libraries MAY use the
        // operationId to uniquely identify an operation, therefore, it is recommended
        // to follow common programming naming conventions.
        OperationId string
        // A list of MIME types the operation can consume. This overrides the consumes
        // definition at the OpenAPI Object. An empty value MAY be used to clear the
        // global definition. Value MUST be as described under Mime Types.
        Consumes []string
        // A list of MIME types the operation can produce. This overrides the produces
        // definition at the OpenAPI Object. An empty value MAY be used to clear the
        // global definition. Value MUST be as described under Mime Types.
        Produces []string
        // The list of possible responses as they are returned from executing this
        // operation.
        Responses map[string]*Response
        // The transfer protocol for the operation. Values MUST be from the list:
        // "http", "https", "ws", "wss". The value overrides the OpenAPI Object
        // schemes definition.
        Schemes []Scheme
        // Declares this operation to be deprecated. Usage of the declared operation
        // should be refrained. Default value is false.
        Deprecated bool
        // A declaration of which security schemes are applied for this operation. The
        // list of values describes alternative security schemes that can be used
        // (that is, there is a logical OR between the security requirements). This
        // definition overrides any declared top-level security. To remove a top-level
        // security declaration, an empty array can be used.
        Security []*SecurityRequirement
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value
        // Custom parameters such as HTTP request headers.
        // See: https://swagger.io/docs/specification/2-0/describing-parameters/
        // and https://swagger.io/specification/v2/#parameter-object.
        Parameters *Parameters
}

func (b0 Operation_builder) Build() *Operation <span class="cov0" title="0">{
        m0 := &amp;Operation{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Tags = b.Tags
        x.Summary = b.Summary
        x.Description = b.Description
        x.ExternalDocs = b.ExternalDocs
        x.OperationId = b.OperationId
        x.Consumes = b.Consumes
        x.Produces = b.Produces
        x.Responses = b.Responses
        x.Schemes = b.Schemes
        x.Deprecated = b.Deprecated
        x.Security = b.Security
        x.Extensions = b.Extensions
        x.Parameters = b.Parameters
        return m0
}</span>

// `Parameters` is a representation of OpenAPI v2 specification's parameters object.
// Note: This technically breaks compatibility with the OpenAPI 2 definition structure as we only
// allow header parameters to be set here since we do not want users specifying custom non-header
// parameters beyond those inferred from the Protobuf schema.
// See: https://swagger.io/specification/v2/#parameter-object
type Parameters struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // `Headers` is one or more HTTP header parameter.
        // See: https://swagger.io/docs/specification/2-0/describing-parameters/#header-parameters
        Headers       []*HeaderParameter `protobuf:"bytes,1,rep,name=headers,proto3" json:"headers,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Parameters) Reset() <span class="cov0" title="0">{
        *x = Parameters{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Parameters) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Parameters) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Parameters) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Parameters) GetHeaders() []*HeaderParameter <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Headers
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Parameters) SetHeaders(v []*HeaderParameter) <span class="cov0" title="0">{
        x.Headers = v
}</span>

type Parameters_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // `Headers` is one or more HTTP header parameter.
        // See: https://swagger.io/docs/specification/2-0/describing-parameters/#header-parameters
        Headers []*HeaderParameter
}

func (b0 Parameters_builder) Build() *Parameters <span class="cov0" title="0">{
        m0 := &amp;Parameters{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Headers = b.Headers
        return m0
}</span>

// `HeaderParameter` a HTTP header parameter.
// See: https://swagger.io/specification/v2/#parameter-object
type HeaderParameter struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // `Name` is the header name.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // `Description` is a short description of the header.
        Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        // `Type` is the type of the object. The value MUST be one of "string", "number", "integer", or "boolean". The "array" type is not supported.
        // See: https://swagger.io/specification/v2/#parameterType.
        Type HeaderParameter_Type `protobuf:"varint,3,opt,name=type,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter_Type" json:"type,omitempty"`
        // `Format` The extending format for the previously mentioned type.
        Format string `protobuf:"bytes,4,opt,name=format,proto3" json:"format,omitempty"`
        // `Required` indicates if the header is optional
        Required      bool `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *HeaderParameter) Reset() <span class="cov0" title="0">{
        *x = HeaderParameter{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *HeaderParameter) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HeaderParameter) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HeaderParameter) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *HeaderParameter) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HeaderParameter) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HeaderParameter) GetType() HeaderParameter_Type <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return HeaderParameter_UNKNOWN</span>
}

func (x *HeaderParameter) GetFormat() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Format
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HeaderParameter) GetRequired() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Required
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *HeaderParameter) SetName(v string) <span class="cov0" title="0">{
        x.Name = v
}</span>

func (x *HeaderParameter) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *HeaderParameter) SetType(v HeaderParameter_Type) <span class="cov0" title="0">{
        x.Type = v
}</span>

func (x *HeaderParameter) SetFormat(v string) <span class="cov0" title="0">{
        x.Format = v
}</span>

func (x *HeaderParameter) SetRequired(v bool) <span class="cov0" title="0">{
        x.Required = v
}</span>

type HeaderParameter_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // `Name` is the header name.
        Name string
        // `Description` is a short description of the header.
        Description string
        // `Type` is the type of the object. The value MUST be one of "string", "number", "integer", or "boolean". The "array" type is not supported.
        // See: https://swagger.io/specification/v2/#parameterType.
        Type HeaderParameter_Type
        // `Format` The extending format for the previously mentioned type.
        Format string
        // `Required` indicates if the header is optional
        Required bool
}

func (b0 HeaderParameter_builder) Build() *HeaderParameter <span class="cov0" title="0">{
        m0 := &amp;HeaderParameter{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Name = b.Name
        x.Description = b.Description
        x.Type = b.Type
        x.Format = b.Format
        x.Required = b.Required
        return m0
}</span>

// `Header` is a representation of OpenAPI v2 specification's Header object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#headerObject
type Header struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // `Description` is a short description of the header.
        Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
        // The type of the object. The value MUST be one of "string", "number", "integer", or "boolean". The "array" type is not supported.
        Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
        // `Format` The extending format for the previously mentioned type.
        Format string `protobuf:"bytes,3,opt,name=format,proto3" json:"format,omitempty"`
        // `Default` Declares the value of the header that the server will use if none is provided.
        // See: https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
        // Unlike JSON Schema this value MUST conform to the defined type for the header.
        Default string `protobuf:"bytes,6,opt,name=default,proto3" json:"default,omitempty"`
        // 'Pattern' See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.3.
        Pattern       string `protobuf:"bytes,13,opt,name=pattern,proto3" json:"pattern,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Header) Reset() <span class="cov0" title="0">{
        *x = Header{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Header) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Header) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Header) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Header) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetFormat() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Format
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetDefault() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Default
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetPattern() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Pattern
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *Header) SetType(v string) <span class="cov0" title="0">{
        x.Type = v
}</span>

func (x *Header) SetFormat(v string) <span class="cov0" title="0">{
        x.Format = v
}</span>

func (x *Header) SetDefault(v string) <span class="cov0" title="0">{
        x.Default = v
}</span>

func (x *Header) SetPattern(v string) <span class="cov0" title="0">{
        x.Pattern = v
}</span>

type Header_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // `Description` is a short description of the header.
        Description string
        // The type of the object. The value MUST be one of "string", "number", "integer", or "boolean". The "array" type is not supported.
        Type string
        // `Format` The extending format for the previously mentioned type.
        Format string
        // `Default` Declares the value of the header that the server will use if none is provided.
        // See: https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
        // Unlike JSON Schema this value MUST conform to the defined type for the header.
        Default string
        // 'Pattern' See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.3.
        Pattern string
}

func (b0 Header_builder) Build() *Header <span class="cov0" title="0">{
        m0 := &amp;Header{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Description = b.Description
        x.Type = b.Type
        x.Format = b.Format
        x.Default = b.Default
        x.Pattern = b.Pattern
        return m0
}</span>

// `Response` is a representation of OpenAPI v2 specification's Response object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#responseObject
type Response struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // `Description` is a short description of the response.
        // GFM syntax can be used for rich text representation.
        Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
        // `Schema` optionally defines the structure of the response.
        // If `Schema` is not provided, it means there is no content to the response.
        Schema *Schema `protobuf:"bytes,2,opt,name=schema,proto3" json:"schema,omitempty"`
        // `Headers` A list of headers that are sent with the response.
        // `Header` name is expected to be a string in the canonical format of the MIME header key
        // See: https://golang.org/pkg/net/textproto/#CanonicalMIMEHeaderKey
        Headers map[string]*Header `protobuf:"bytes,3,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        // `Examples` gives per-mimetype response examples.
        // See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#example-object
        Examples map[string]string `protobuf:"bytes,4,rep,name=examples,proto3" json:"examples,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions    map[string]*structpb.Value `protobuf:"bytes,5,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Response) Reset() <span class="cov0" title="0">{
        *x = Response{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Response) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Response) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Response) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Response) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Response) GetSchema() *Schema <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Schema
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Response) GetHeaders() map[string]*Header <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Headers
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Response) GetExamples() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Examples
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Response) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Response) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *Response) SetSchema(v *Schema) <span class="cov0" title="0">{
        x.Schema = v
}</span>

func (x *Response) SetHeaders(v map[string]*Header) <span class="cov0" title="0">{
        x.Headers = v
}</span>

func (x *Response) SetExamples(v map[string]string) <span class="cov0" title="0">{
        x.Examples = v
}</span>

func (x *Response) SetExtensions(v map[string]*structpb.Value) <span class="cov0" title="0">{
        x.Extensions = v
}</span>

func (x *Response) HasSchema() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.Schema != nil</span>
}

func (x *Response) ClearSchema() <span class="cov0" title="0">{
        x.Schema = nil
}</span>

type Response_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // `Description` is a short description of the response.
        // GFM syntax can be used for rich text representation.
        Description string
        // `Schema` optionally defines the structure of the response.
        // If `Schema` is not provided, it means there is no content to the response.
        Schema *Schema
        // `Headers` A list of headers that are sent with the response.
        // `Header` name is expected to be a string in the canonical format of the MIME header key
        // See: https://golang.org/pkg/net/textproto/#CanonicalMIMEHeaderKey
        Headers map[string]*Header
        // `Examples` gives per-mimetype response examples.
        // See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#example-object
        Examples map[string]string
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value
}

func (b0 Response_builder) Build() *Response <span class="cov0" title="0">{
        m0 := &amp;Response{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Description = b.Description
        x.Schema = b.Schema
        x.Headers = b.Headers
        x.Examples = b.Examples
        x.Extensions = b.Extensions
        return m0
}</span>

// `Info` is a representation of OpenAPI v2 specification's Info object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#infoObject
//
// Example:
//
//        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//          info: {
//            title: "Echo API";
//            version: "1.0";
//            description: "";
//            contact: {
//              name: "gRPC-Gateway project";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway";
//              email: "none@example.com";
//            };
//            license: {
//              name: "BSD 3-Clause License";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/main/LICENSE";
//            };
//          };
//          ...
//        };
type Info struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // The title of the application.
        Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
        // A short description of the application. GFM syntax can be used for rich
        // text representation.
        Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        // The Terms of Service for the API.
        TermsOfService string `protobuf:"bytes,3,opt,name=terms_of_service,json=termsOfService,proto3" json:"terms_of_service,omitempty"`
        // The contact information for the exposed API.
        Contact *Contact `protobuf:"bytes,4,opt,name=contact,proto3" json:"contact,omitempty"`
        // The license information for the exposed API.
        License *License `protobuf:"bytes,5,opt,name=license,proto3" json:"license,omitempty"`
        // Provides the version of the application API (not to be confused
        // with the specification version).
        Version string `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions    map[string]*structpb.Value `protobuf:"bytes,7,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Info) Reset() <span class="cov0" title="0">{
        *x = Info{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Info) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Info) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Info) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Info) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Info) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Info) GetTermsOfService() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TermsOfService
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Info) GetContact() *Contact <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Contact
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Info) GetLicense() *License <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.License
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Info) GetVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Version
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Info) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Info) SetTitle(v string) <span class="cov0" title="0">{
        x.Title = v
}</span>

func (x *Info) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *Info) SetTermsOfService(v string) <span class="cov0" title="0">{
        x.TermsOfService = v
}</span>

func (x *Info) SetContact(v *Contact) <span class="cov0" title="0">{
        x.Contact = v
}</span>

func (x *Info) SetLicense(v *License) <span class="cov0" title="0">{
        x.License = v
}</span>

func (x *Info) SetVersion(v string) <span class="cov0" title="0">{
        x.Version = v
}</span>

func (x *Info) SetExtensions(v map[string]*structpb.Value) <span class="cov0" title="0">{
        x.Extensions = v
}</span>

func (x *Info) HasContact() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.Contact != nil</span>
}

func (x *Info) HasLicense() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.License != nil</span>
}

func (x *Info) ClearContact() <span class="cov0" title="0">{
        x.Contact = nil
}</span>

func (x *Info) ClearLicense() <span class="cov0" title="0">{
        x.License = nil
}</span>

type Info_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // The title of the application.
        Title string
        // A short description of the application. GFM syntax can be used for rich
        // text representation.
        Description string
        // The Terms of Service for the API.
        TermsOfService string
        // The contact information for the exposed API.
        Contact *Contact
        // The license information for the exposed API.
        License *License
        // Provides the version of the application API (not to be confused
        // with the specification version).
        Version string
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value
}

func (b0 Info_builder) Build() *Info <span class="cov0" title="0">{
        m0 := &amp;Info{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Title = b.Title
        x.Description = b.Description
        x.TermsOfService = b.TermsOfService
        x.Contact = b.Contact
        x.License = b.License
        x.Version = b.Version
        x.Extensions = b.Extensions
        return m0
}</span>

// `Contact` is a representation of OpenAPI v2 specification's Contact object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#contactObject
//
// Example:
//
//        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//          info: {
//            ...
//            contact: {
//              name: "gRPC-Gateway project";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway";
//              email: "none@example.com";
//            };
//            ...
//          };
//          ...
//        };
type Contact struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // The identifying name of the contact person/organization.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // The URL pointing to the contact information. MUST be in the format of a
        // URL.
        Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
        // The email address of the contact person/organization. MUST be in the format
        // of an email address.
        Email         string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Contact) Reset() <span class="cov0" title="0">{
        *x = Contact{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Contact) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Contact) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Contact) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Contact) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Contact) GetUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Url
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Contact) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Contact) SetName(v string) <span class="cov0" title="0">{
        x.Name = v
}</span>

func (x *Contact) SetUrl(v string) <span class="cov0" title="0">{
        x.Url = v
}</span>

func (x *Contact) SetEmail(v string) <span class="cov0" title="0">{
        x.Email = v
}</span>

type Contact_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // The identifying name of the contact person/organization.
        Name string
        // The URL pointing to the contact information. MUST be in the format of a
        // URL.
        Url string
        // The email address of the contact person/organization. MUST be in the format
        // of an email address.
        Email string
}

func (b0 Contact_builder) Build() *Contact <span class="cov0" title="0">{
        m0 := &amp;Contact{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Name = b.Name
        x.Url = b.Url
        x.Email = b.Email
        return m0
}</span>

// `License` is a representation of OpenAPI v2 specification's License object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#licenseObject
//
// Example:
//
//        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//          info: {
//            ...
//            license: {
//              name: "BSD 3-Clause License";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/main/LICENSE";
//            };
//            ...
//          };
//          ...
//        };
type License struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // The license name used for the API.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // A URL to the license used for the API. MUST be in the format of a URL.
        Url           string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *License) Reset() <span class="cov0" title="0">{
        *x = License{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *License) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*License) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *License) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *License) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *License) GetUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Url
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *License) SetName(v string) <span class="cov0" title="0">{
        x.Name = v
}</span>

func (x *License) SetUrl(v string) <span class="cov0" title="0">{
        x.Url = v
}</span>

type License_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // The license name used for the API.
        Name string
        // A URL to the license used for the API. MUST be in the format of a URL.
        Url string
}

func (b0 License_builder) Build() *License <span class="cov0" title="0">{
        m0 := &amp;License{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Name = b.Name
        x.Url = b.Url
        return m0
}</span>

// `ExternalDocumentation` is a representation of OpenAPI v2 specification's
// ExternalDocumentation object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#externalDocumentationObject
//
// Example:
//
//        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//          ...
//          external_docs: {
//            description: "More about gRPC-Gateway";
//            url: "https://github.com/grpc-ecosystem/grpc-gateway";
//          }
//          ...
//        };
type ExternalDocumentation struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // A short description of the target documentation. GFM syntax can be used for
        // rich text representation.
        Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
        // The URL for the target documentation. Value MUST be in the format
        // of a URL.
        Url           string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ExternalDocumentation) Reset() <span class="cov0" title="0">{
        *x = ExternalDocumentation{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ExternalDocumentation) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ExternalDocumentation) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ExternalDocumentation) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *ExternalDocumentation) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ExternalDocumentation) GetUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Url
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ExternalDocumentation) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *ExternalDocumentation) SetUrl(v string) <span class="cov0" title="0">{
        x.Url = v
}</span>

type ExternalDocumentation_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // A short description of the target documentation. GFM syntax can be used for
        // rich text representation.
        Description string
        // The URL for the target documentation. Value MUST be in the format
        // of a URL.
        Url string
}

func (b0 ExternalDocumentation_builder) Build() *ExternalDocumentation <span class="cov0" title="0">{
        m0 := &amp;ExternalDocumentation{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Description = b.Description
        x.Url = b.Url
        return m0
}</span>

// `Schema` is a representation of OpenAPI v2 specification's Schema object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
type Schema struct {
        state      protoimpl.MessageState `protogen:"hybrid.v1"`
        JsonSchema *JSONSchema            `protobuf:"bytes,1,opt,name=json_schema,json=jsonSchema,proto3" json:"json_schema,omitempty"`
        // Adds support for polymorphism. The discriminator is the schema property
        // name that is used to differentiate between other schema that inherit this
        // schema. The property name used MUST be defined at this schema and it MUST
        // be in the required property list. When used, the value MUST be the name of
        // this schema or any schema that inherits it.
        Discriminator string `protobuf:"bytes,2,opt,name=discriminator,proto3" json:"discriminator,omitempty"`
        // Relevant only for Schema "properties" definitions. Declares the property as
        // "read only". This means that it MAY be sent as part of a response but MUST
        // NOT be sent as part of the request. Properties marked as readOnly being
        // true SHOULD NOT be in the required list of the defined schema. Default
        // value is false.
        ReadOnly bool `protobuf:"varint,3,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
        // Additional external documentation for this schema.
        ExternalDocs *ExternalDocumentation `protobuf:"bytes,5,opt,name=external_docs,json=externalDocs,proto3" json:"external_docs,omitempty"`
        // A free-form property to include an example of an instance for this schema in JSON.
        // This is copied verbatim to the output.
        Example       string `protobuf:"bytes,6,opt,name=example,proto3" json:"example,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Schema) Reset() <span class="cov0" title="0">{
        *x = Schema{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Schema) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Schema) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Schema) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Schema) GetJsonSchema() *JSONSchema <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.JsonSchema
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Schema) GetDiscriminator() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Discriminator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Schema) GetReadOnly() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReadOnly
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Schema) GetExternalDocs() *ExternalDocumentation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExternalDocs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Schema) GetExample() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Example
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Schema) SetJsonSchema(v *JSONSchema) <span class="cov0" title="0">{
        x.JsonSchema = v
}</span>

func (x *Schema) SetDiscriminator(v string) <span class="cov0" title="0">{
        x.Discriminator = v
}</span>

func (x *Schema) SetReadOnly(v bool) <span class="cov0" title="0">{
        x.ReadOnly = v
}</span>

func (x *Schema) SetExternalDocs(v *ExternalDocumentation) <span class="cov0" title="0">{
        x.ExternalDocs = v
}</span>

func (x *Schema) SetExample(v string) <span class="cov0" title="0">{
        x.Example = v
}</span>

func (x *Schema) HasJsonSchema() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.JsonSchema != nil</span>
}

func (x *Schema) HasExternalDocs() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.ExternalDocs != nil</span>
}

func (x *Schema) ClearJsonSchema() <span class="cov0" title="0">{
        x.JsonSchema = nil
}</span>

func (x *Schema) ClearExternalDocs() <span class="cov0" title="0">{
        x.ExternalDocs = nil
}</span>

type Schema_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        JsonSchema *JSONSchema
        // Adds support for polymorphism. The discriminator is the schema property
        // name that is used to differentiate between other schema that inherit this
        // schema. The property name used MUST be defined at this schema and it MUST
        // be in the required property list. When used, the value MUST be the name of
        // this schema or any schema that inherits it.
        Discriminator string
        // Relevant only for Schema "properties" definitions. Declares the property as
        // "read only". This means that it MAY be sent as part of a response but MUST
        // NOT be sent as part of the request. Properties marked as readOnly being
        // true SHOULD NOT be in the required list of the defined schema. Default
        // value is false.
        ReadOnly bool
        // Additional external documentation for this schema.
        ExternalDocs *ExternalDocumentation
        // A free-form property to include an example of an instance for this schema in JSON.
        // This is copied verbatim to the output.
        Example string
}

func (b0 Schema_builder) Build() *Schema <span class="cov0" title="0">{
        m0 := &amp;Schema{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.JsonSchema = b.JsonSchema
        x.Discriminator = b.Discriminator
        x.ReadOnly = b.ReadOnly
        x.ExternalDocs = b.ExternalDocs
        x.Example = b.Example
        return m0
}</span>

// `EnumSchema` is subset of fields from the OpenAPI v2 specification's Schema object.
// Only fields that are applicable to Enums are included
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
//
// Example:
//
//        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_enum) = {
//          ...
//          title: "MyEnum";
//          description:"This is my nice enum";
//          example: "ZERO";
//          required: true;
//          ...
//        };
type EnumSchema struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // A short description of the schema.
        Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
        Default     string `protobuf:"bytes,2,opt,name=default,proto3" json:"default,omitempty"`
        // The title of the schema.
        Title    string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
        Required bool   `protobuf:"varint,4,opt,name=required,proto3" json:"required,omitempty"`
        ReadOnly bool   `protobuf:"varint,5,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
        // Additional external documentation for this schema.
        ExternalDocs *ExternalDocumentation `protobuf:"bytes,6,opt,name=external_docs,json=externalDocs,proto3" json:"external_docs,omitempty"`
        Example      string                 `protobuf:"bytes,7,opt,name=example,proto3" json:"example,omitempty"`
        // Ref is used to define an external reference to include in the message.
        // This could be a fully qualified proto message reference, and that type must
        // be imported into the protofile. If no message is identified, the Ref will
        // be used verbatim in the output.
        // For example:
        //
        //        `ref: ".google.protobuf.Timestamp"`.
        Ref string `protobuf:"bytes,8,opt,name=ref,proto3" json:"ref,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions    map[string]*structpb.Value `protobuf:"bytes,9,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *EnumSchema) Reset() <span class="cov0" title="0">{
        *x = EnumSchema{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *EnumSchema) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EnumSchema) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EnumSchema) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *EnumSchema) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *EnumSchema) GetDefault() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Default
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *EnumSchema) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *EnumSchema) GetRequired() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Required
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *EnumSchema) GetReadOnly() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReadOnly
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *EnumSchema) GetExternalDocs() *ExternalDocumentation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExternalDocs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *EnumSchema) GetExample() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Example
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *EnumSchema) GetRef() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ref
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *EnumSchema) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *EnumSchema) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *EnumSchema) SetDefault(v string) <span class="cov0" title="0">{
        x.Default = v
}</span>

func (x *EnumSchema) SetTitle(v string) <span class="cov0" title="0">{
        x.Title = v
}</span>

func (x *EnumSchema) SetRequired(v bool) <span class="cov0" title="0">{
        x.Required = v
}</span>

func (x *EnumSchema) SetReadOnly(v bool) <span class="cov0" title="0">{
        x.ReadOnly = v
}</span>

func (x *EnumSchema) SetExternalDocs(v *ExternalDocumentation) <span class="cov0" title="0">{
        x.ExternalDocs = v
}</span>

func (x *EnumSchema) SetExample(v string) <span class="cov0" title="0">{
        x.Example = v
}</span>

func (x *EnumSchema) SetRef(v string) <span class="cov0" title="0">{
        x.Ref = v
}</span>

func (x *EnumSchema) SetExtensions(v map[string]*structpb.Value) <span class="cov0" title="0">{
        x.Extensions = v
}</span>

func (x *EnumSchema) HasExternalDocs() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.ExternalDocs != nil</span>
}

func (x *EnumSchema) ClearExternalDocs() <span class="cov0" title="0">{
        x.ExternalDocs = nil
}</span>

type EnumSchema_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // A short description of the schema.
        Description string
        Default     string
        // The title of the schema.
        Title    string
        Required bool
        ReadOnly bool
        // Additional external documentation for this schema.
        ExternalDocs *ExternalDocumentation
        Example      string
        // Ref is used to define an external reference to include in the message.
        // This could be a fully qualified proto message reference, and that type must
        // be imported into the protofile. If no message is identified, the Ref will
        // be used verbatim in the output.
        // For example:
        //
        //        `ref: ".google.protobuf.Timestamp"`.
        Ref string
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value
}

func (b0 EnumSchema_builder) Build() *EnumSchema <span class="cov0" title="0">{
        m0 := &amp;EnumSchema{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Description = b.Description
        x.Default = b.Default
        x.Title = b.Title
        x.Required = b.Required
        x.ReadOnly = b.ReadOnly
        x.ExternalDocs = b.ExternalDocs
        x.Example = b.Example
        x.Ref = b.Ref
        x.Extensions = b.Extensions
        return m0
}</span>

// `JSONSchema` represents properties from JSON Schema taken, and as used, in
// the OpenAPI v2 spec.
//
// This includes changes made by OpenAPI v2.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
//
// See also: https://cswr.github.io/JsonSchema/spec/basic_types/,
// https://github.com/json-schema-org/json-schema-spec/blob/master/schema.json
//
// Example:
//
//        message SimpleMessage {
//          option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
//            json_schema: {
//              title: "SimpleMessage"
//              description: "A simple message."
//              required: ["id"]
//            }
//          };
//
//          // Id represents the message identifier.
//          string id = 1; [
//              (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
//                description: "The unique identifier of the simple message."
//              }];
//        }
type JSONSchema struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // Ref is used to define an external reference to include in the message.
        // This could be a fully qualified proto message reference, and that type must
        // be imported into the protofile. If no message is identified, the Ref will
        // be used verbatim in the output.
        // For example:
        //
        //        `ref: ".google.protobuf.Timestamp"`.
        Ref string `protobuf:"bytes,3,opt,name=ref,proto3" json:"ref,omitempty"`
        // The title of the schema.
        Title string `protobuf:"bytes,5,opt,name=title,proto3" json:"title,omitempty"`
        // A short description of the schema.
        Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
        Default     string `protobuf:"bytes,7,opt,name=default,proto3" json:"default,omitempty"`
        ReadOnly    bool   `protobuf:"varint,8,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
        // A free-form property to include a JSON example of this field. This is copied
        // verbatim to the output swagger.json. Quotes must be escaped.
        // This property is the same for 2.0 and 3.0.0 https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/3.0.0.md#schemaObject  https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
        Example    string  `protobuf:"bytes,9,opt,name=example,proto3" json:"example,omitempty"`
        MultipleOf float64 `protobuf:"fixed64,10,opt,name=multiple_of,json=multipleOf,proto3" json:"multiple_of,omitempty"`
        // Maximum represents an inclusive upper limit for a numeric instance. The
        // value of MUST be a number,
        Maximum          float64 `protobuf:"fixed64,11,opt,name=maximum,proto3" json:"maximum,omitempty"`
        ExclusiveMaximum bool    `protobuf:"varint,12,opt,name=exclusive_maximum,json=exclusiveMaximum,proto3" json:"exclusive_maximum,omitempty"`
        // minimum represents an inclusive lower limit for a numeric instance. The
        // value of MUST be a number,
        Minimum          float64  `protobuf:"fixed64,13,opt,name=minimum,proto3" json:"minimum,omitempty"`
        ExclusiveMinimum bool     `protobuf:"varint,14,opt,name=exclusive_minimum,json=exclusiveMinimum,proto3" json:"exclusive_minimum,omitempty"`
        MaxLength        uint64   `protobuf:"varint,15,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`
        MinLength        uint64   `protobuf:"varint,16,opt,name=min_length,json=minLength,proto3" json:"min_length,omitempty"`
        Pattern          string   `protobuf:"bytes,17,opt,name=pattern,proto3" json:"pattern,omitempty"`
        MaxItems         uint64   `protobuf:"varint,20,opt,name=max_items,json=maxItems,proto3" json:"max_items,omitempty"`
        MinItems         uint64   `protobuf:"varint,21,opt,name=min_items,json=minItems,proto3" json:"min_items,omitempty"`
        UniqueItems      bool     `protobuf:"varint,22,opt,name=unique_items,json=uniqueItems,proto3" json:"unique_items,omitempty"`
        MaxProperties    uint64   `protobuf:"varint,24,opt,name=max_properties,json=maxProperties,proto3" json:"max_properties,omitempty"`
        MinProperties    uint64   `protobuf:"varint,25,opt,name=min_properties,json=minProperties,proto3" json:"min_properties,omitempty"`
        Required         []string `protobuf:"bytes,26,rep,name=required,proto3" json:"required,omitempty"`
        // Items in 'array' must be unique.
        Array []string                           `protobuf:"bytes,34,rep,name=array,proto3" json:"array,omitempty"`
        Type  []JSONSchema_JSONSchemaSimpleTypes `protobuf:"varint,35,rep,packed,name=type,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.JSONSchema_JSONSchemaSimpleTypes" json:"type,omitempty"`
        // `Format`
        Format string `protobuf:"bytes,36,opt,name=format,proto3" json:"format,omitempty"`
        // Items in `enum` must be unique https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1
        Enum []string `protobuf:"bytes,46,rep,name=enum,proto3" json:"enum,omitempty"`
        // Additional field level properties used when generating the OpenAPI v2 file.
        FieldConfiguration *JSONSchema_FieldConfiguration `protobuf:"bytes,1001,opt,name=field_configuration,json=fieldConfiguration,proto3" json:"field_configuration,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions    map[string]*structpb.Value `protobuf:"bytes,48,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *JSONSchema) Reset() <span class="cov0" title="0">{
        *x = JSONSchema{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *JSONSchema) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*JSONSchema) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *JSONSchema) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *JSONSchema) GetRef() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ref
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetDefault() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Default
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetReadOnly() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReadOnly
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *JSONSchema) GetExample() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Example
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetMultipleOf() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MultipleOf
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetMaximum() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Maximum
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetExclusiveMaximum() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExclusiveMaximum
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *JSONSchema) GetMinimum() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Minimum
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetExclusiveMinimum() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExclusiveMinimum
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *JSONSchema) GetMaxLength() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxLength
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetMinLength() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MinLength
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetPattern() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Pattern
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetMaxItems() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxItems
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetMinItems() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MinItems
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetUniqueItems() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UniqueItems
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *JSONSchema) GetMaxProperties() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxProperties
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetMinProperties() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MinProperties
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetRequired() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Required
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JSONSchema) GetArray() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Array
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JSONSchema) GetType() []JSONSchema_JSONSchemaSimpleTypes <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JSONSchema) GetFormat() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Format
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetEnum() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enum
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JSONSchema) GetFieldConfiguration() *JSONSchema_FieldConfiguration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FieldConfiguration
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JSONSchema) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JSONSchema) SetRef(v string) <span class="cov0" title="0">{
        x.Ref = v
}</span>

func (x *JSONSchema) SetTitle(v string) <span class="cov0" title="0">{
        x.Title = v
}</span>

func (x *JSONSchema) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *JSONSchema) SetDefault(v string) <span class="cov0" title="0">{
        x.Default = v
}</span>

func (x *JSONSchema) SetReadOnly(v bool) <span class="cov0" title="0">{
        x.ReadOnly = v
}</span>

func (x *JSONSchema) SetExample(v string) <span class="cov0" title="0">{
        x.Example = v
}</span>

func (x *JSONSchema) SetMultipleOf(v float64) <span class="cov0" title="0">{
        x.MultipleOf = v
}</span>

func (x *JSONSchema) SetMaximum(v float64) <span class="cov0" title="0">{
        x.Maximum = v
}</span>

func (x *JSONSchema) SetExclusiveMaximum(v bool) <span class="cov0" title="0">{
        x.ExclusiveMaximum = v
}</span>

func (x *JSONSchema) SetMinimum(v float64) <span class="cov0" title="0">{
        x.Minimum = v
}</span>

func (x *JSONSchema) SetExclusiveMinimum(v bool) <span class="cov0" title="0">{
        x.ExclusiveMinimum = v
}</span>

func (x *JSONSchema) SetMaxLength(v uint64) <span class="cov0" title="0">{
        x.MaxLength = v
}</span>

func (x *JSONSchema) SetMinLength(v uint64) <span class="cov0" title="0">{
        x.MinLength = v
}</span>

func (x *JSONSchema) SetPattern(v string) <span class="cov0" title="0">{
        x.Pattern = v
}</span>

func (x *JSONSchema) SetMaxItems(v uint64) <span class="cov0" title="0">{
        x.MaxItems = v
}</span>

func (x *JSONSchema) SetMinItems(v uint64) <span class="cov0" title="0">{
        x.MinItems = v
}</span>

func (x *JSONSchema) SetUniqueItems(v bool) <span class="cov0" title="0">{
        x.UniqueItems = v
}</span>

func (x *JSONSchema) SetMaxProperties(v uint64) <span class="cov0" title="0">{
        x.MaxProperties = v
}</span>

func (x *JSONSchema) SetMinProperties(v uint64) <span class="cov0" title="0">{
        x.MinProperties = v
}</span>

func (x *JSONSchema) SetRequired(v []string) <span class="cov0" title="0">{
        x.Required = v
}</span>

func (x *JSONSchema) SetArray(v []string) <span class="cov0" title="0">{
        x.Array = v
}</span>

func (x *JSONSchema) SetType(v []JSONSchema_JSONSchemaSimpleTypes) <span class="cov0" title="0">{
        x.Type = v
}</span>

func (x *JSONSchema) SetFormat(v string) <span class="cov0" title="0">{
        x.Format = v
}</span>

func (x *JSONSchema) SetEnum(v []string) <span class="cov0" title="0">{
        x.Enum = v
}</span>

func (x *JSONSchema) SetFieldConfiguration(v *JSONSchema_FieldConfiguration) <span class="cov0" title="0">{
        x.FieldConfiguration = v
}</span>

func (x *JSONSchema) SetExtensions(v map[string]*structpb.Value) <span class="cov0" title="0">{
        x.Extensions = v
}</span>

func (x *JSONSchema) HasFieldConfiguration() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.FieldConfiguration != nil</span>
}

func (x *JSONSchema) ClearFieldConfiguration() <span class="cov0" title="0">{
        x.FieldConfiguration = nil
}</span>

type JSONSchema_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // Ref is used to define an external reference to include in the message.
        // This could be a fully qualified proto message reference, and that type must
        // be imported into the protofile. If no message is identified, the Ref will
        // be used verbatim in the output.
        // For example:
        //
        //        `ref: ".google.protobuf.Timestamp"`.
        Ref string
        // The title of the schema.
        Title string
        // A short description of the schema.
        Description string
        Default     string
        ReadOnly    bool
        // A free-form property to include a JSON example of this field. This is copied
        // verbatim to the output swagger.json. Quotes must be escaped.
        // This property is the same for 2.0 and 3.0.0 https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/3.0.0.md#schemaObject  https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
        Example    string
        MultipleOf float64
        // Maximum represents an inclusive upper limit for a numeric instance. The
        // value of MUST be a number,
        Maximum          float64
        ExclusiveMaximum bool
        // minimum represents an inclusive lower limit for a numeric instance. The
        // value of MUST be a number,
        Minimum          float64
        ExclusiveMinimum bool
        MaxLength        uint64
        MinLength        uint64
        Pattern          string
        MaxItems         uint64
        MinItems         uint64
        UniqueItems      bool
        MaxProperties    uint64
        MinProperties    uint64
        Required         []string
        // Items in 'array' must be unique.
        Array []string
        Type  []JSONSchema_JSONSchemaSimpleTypes
        // `Format`
        Format string
        // Items in `enum` must be unique https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1
        Enum []string
        // Additional field level properties used when generating the OpenAPI v2 file.
        FieldConfiguration *JSONSchema_FieldConfiguration
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value
}

func (b0 JSONSchema_builder) Build() *JSONSchema <span class="cov0" title="0">{
        m0 := &amp;JSONSchema{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Ref = b.Ref
        x.Title = b.Title
        x.Description = b.Description
        x.Default = b.Default
        x.ReadOnly = b.ReadOnly
        x.Example = b.Example
        x.MultipleOf = b.MultipleOf
        x.Maximum = b.Maximum
        x.ExclusiveMaximum = b.ExclusiveMaximum
        x.Minimum = b.Minimum
        x.ExclusiveMinimum = b.ExclusiveMinimum
        x.MaxLength = b.MaxLength
        x.MinLength = b.MinLength
        x.Pattern = b.Pattern
        x.MaxItems = b.MaxItems
        x.MinItems = b.MinItems
        x.UniqueItems = b.UniqueItems
        x.MaxProperties = b.MaxProperties
        x.MinProperties = b.MinProperties
        x.Required = b.Required
        x.Array = b.Array
        x.Type = b.Type
        x.Format = b.Format
        x.Enum = b.Enum
        x.FieldConfiguration = b.FieldConfiguration
        x.Extensions = b.Extensions
        return m0
}</span>

// `Tag` is a representation of OpenAPI v2 specification's Tag object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#tagObject
type Tag struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // The name of the tag. Use it to allow override of the name of a
        // global Tag object, then use that name to reference the tag throughout the
        // OpenAPI file.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // A short description for the tag. GFM syntax can be used for rich text
        // representation.
        Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        // Additional external documentation for this tag.
        ExternalDocs *ExternalDocumentation `protobuf:"bytes,3,opt,name=external_docs,json=externalDocs,proto3" json:"external_docs,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions    map[string]*structpb.Value `protobuf:"bytes,4,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Tag) Reset() <span class="cov0" title="0">{
        *x = Tag{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Tag) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Tag) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Tag) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Tag) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Tag) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Tag) GetExternalDocs() *ExternalDocumentation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExternalDocs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Tag) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Tag) SetName(v string) <span class="cov0" title="0">{
        x.Name = v
}</span>

func (x *Tag) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *Tag) SetExternalDocs(v *ExternalDocumentation) <span class="cov0" title="0">{
        x.ExternalDocs = v
}</span>

func (x *Tag) SetExtensions(v map[string]*structpb.Value) <span class="cov0" title="0">{
        x.Extensions = v
}</span>

func (x *Tag) HasExternalDocs() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.ExternalDocs != nil</span>
}

func (x *Tag) ClearExternalDocs() <span class="cov0" title="0">{
        x.ExternalDocs = nil
}</span>

type Tag_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // The name of the tag. Use it to allow override of the name of a
        // global Tag object, then use that name to reference the tag throughout the
        // OpenAPI file.
        Name string
        // A short description for the tag. GFM syntax can be used for rich text
        // representation.
        Description string
        // Additional external documentation for this tag.
        ExternalDocs *ExternalDocumentation
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value
}

func (b0 Tag_builder) Build() *Tag <span class="cov0" title="0">{
        m0 := &amp;Tag{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Name = b.Name
        x.Description = b.Description
        x.ExternalDocs = b.ExternalDocs
        x.Extensions = b.Extensions
        return m0
}</span>

// `SecurityDefinitions` is a representation of OpenAPI v2 specification's
// Security Definitions object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securityDefinitionsObject
//
// A declaration of the security schemes available to be used in the
// specification. This does not enforce the security schemes on the operations
// and only serves to provide the relevant details for each scheme.
type SecurityDefinitions struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // A single security scheme definition, mapping a "name" to the scheme it
        // defines.
        Security      map[string]*SecurityScheme `protobuf:"bytes,1,rep,name=security,proto3" json:"security,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SecurityDefinitions) Reset() <span class="cov0" title="0">{
        *x = SecurityDefinitions{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SecurityDefinitions) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SecurityDefinitions) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SecurityDefinitions) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *SecurityDefinitions) GetSecurity() map[string]*SecurityScheme <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Security
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SecurityDefinitions) SetSecurity(v map[string]*SecurityScheme) <span class="cov0" title="0">{
        x.Security = v
}</span>

type SecurityDefinitions_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // A single security scheme definition, mapping a "name" to the scheme it
        // defines.
        Security map[string]*SecurityScheme
}

func (b0 SecurityDefinitions_builder) Build() *SecurityDefinitions <span class="cov0" title="0">{
        m0 := &amp;SecurityDefinitions{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Security = b.Security
        return m0
}</span>

// `SecurityScheme` is a representation of OpenAPI v2 specification's
// Security Scheme object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securitySchemeObject
//
// Allows the definition of a security scheme that can be used by the
// operations. Supported schemes are basic authentication, an API key (either as
// a header or as a query parameter) and OAuth2's common flows (implicit,
// password, application and access code).
type SecurityScheme struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // The type of the security scheme. Valid values are "basic",
        // "apiKey" or "oauth2".
        Type SecurityScheme_Type `protobuf:"varint,1,opt,name=type,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme_Type" json:"type,omitempty"`
        // A short description for security scheme.
        Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        // The name of the header or query parameter to be used.
        // Valid for apiKey.
        Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
        // The location of the API key. Valid values are "query" or
        // "header".
        // Valid for apiKey.
        In SecurityScheme_In `protobuf:"varint,4,opt,name=in,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme_In" json:"in,omitempty"`
        // The flow used by the OAuth2 security scheme. Valid values are
        // "implicit", "password", "application" or "accessCode".
        // Valid for oauth2.
        Flow SecurityScheme_Flow `protobuf:"varint,5,opt,name=flow,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme_Flow" json:"flow,omitempty"`
        // The authorization URL to be used for this flow. This SHOULD be in
        // the form of a URL.
        // Valid for oauth2/implicit and oauth2/accessCode.
        AuthorizationUrl string `protobuf:"bytes,6,opt,name=authorization_url,json=authorizationUrl,proto3" json:"authorization_url,omitempty"`
        // The token URL to be used for this flow. This SHOULD be in the
        // form of a URL.
        // Valid for oauth2/password, oauth2/application and oauth2/accessCode.
        TokenUrl string `protobuf:"bytes,7,opt,name=token_url,json=tokenUrl,proto3" json:"token_url,omitempty"`
        // The available scopes for the OAuth2 security scheme.
        // Valid for oauth2.
        Scopes *Scopes `protobuf:"bytes,8,opt,name=scopes,proto3" json:"scopes,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions    map[string]*structpb.Value `protobuf:"bytes,9,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SecurityScheme) Reset() <span class="cov0" title="0">{
        *x = SecurityScheme{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SecurityScheme) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SecurityScheme) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SecurityScheme) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *SecurityScheme) GetType() SecurityScheme_Type <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return SecurityScheme_TYPE_INVALID</span>
}

func (x *SecurityScheme) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SecurityScheme) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SecurityScheme) GetIn() SecurityScheme_In <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return SecurityScheme_IN_INVALID</span>
}

func (x *SecurityScheme) GetFlow() SecurityScheme_Flow <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Flow
        }</span>
        <span class="cov0" title="0">return SecurityScheme_FLOW_INVALID</span>
}

func (x *SecurityScheme) GetAuthorizationUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorizationUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SecurityScheme) GetTokenUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TokenUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SecurityScheme) GetScopes() *Scopes <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Scopes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SecurityScheme) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SecurityScheme) SetType(v SecurityScheme_Type) <span class="cov0" title="0">{
        x.Type = v
}</span>

func (x *SecurityScheme) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *SecurityScheme) SetName(v string) <span class="cov0" title="0">{
        x.Name = v
}</span>

func (x *SecurityScheme) SetIn(v SecurityScheme_In) <span class="cov0" title="0">{
        x.In = v
}</span>

func (x *SecurityScheme) SetFlow(v SecurityScheme_Flow) <span class="cov0" title="0">{
        x.Flow = v
}</span>

func (x *SecurityScheme) SetAuthorizationUrl(v string) <span class="cov0" title="0">{
        x.AuthorizationUrl = v
}</span>

func (x *SecurityScheme) SetTokenUrl(v string) <span class="cov0" title="0">{
        x.TokenUrl = v
}</span>

func (x *SecurityScheme) SetScopes(v *Scopes) <span class="cov0" title="0">{
        x.Scopes = v
}</span>

func (x *SecurityScheme) SetExtensions(v map[string]*structpb.Value) <span class="cov0" title="0">{
        x.Extensions = v
}</span>

func (x *SecurityScheme) HasScopes() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.Scopes != nil</span>
}

func (x *SecurityScheme) ClearScopes() <span class="cov0" title="0">{
        x.Scopes = nil
}</span>

type SecurityScheme_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // The type of the security scheme. Valid values are "basic",
        // "apiKey" or "oauth2".
        Type SecurityScheme_Type
        // A short description for security scheme.
        Description string
        // The name of the header or query parameter to be used.
        // Valid for apiKey.
        Name string
        // The location of the API key. Valid values are "query" or
        // "header".
        // Valid for apiKey.
        In SecurityScheme_In
        // The flow used by the OAuth2 security scheme. Valid values are
        // "implicit", "password", "application" or "accessCode".
        // Valid for oauth2.
        Flow SecurityScheme_Flow
        // The authorization URL to be used for this flow. This SHOULD be in
        // the form of a URL.
        // Valid for oauth2/implicit and oauth2/accessCode.
        AuthorizationUrl string
        // The token URL to be used for this flow. This SHOULD be in the
        // form of a URL.
        // Valid for oauth2/password, oauth2/application and oauth2/accessCode.
        TokenUrl string
        // The available scopes for the OAuth2 security scheme.
        // Valid for oauth2.
        Scopes *Scopes
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value
}

func (b0 SecurityScheme_builder) Build() *SecurityScheme <span class="cov0" title="0">{
        m0 := &amp;SecurityScheme{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Type = b.Type
        x.Description = b.Description
        x.Name = b.Name
        x.In = b.In
        x.Flow = b.Flow
        x.AuthorizationUrl = b.AuthorizationUrl
        x.TokenUrl = b.TokenUrl
        x.Scopes = b.Scopes
        x.Extensions = b.Extensions
        return m0
}</span>

// `SecurityRequirement` is a representation of OpenAPI v2 specification's
// Security Requirement object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securityRequirementObject
//
// Lists the required security schemes to execute this operation. The object can
// have multiple security schemes declared in it which are all required (that
// is, there is a logical AND between the schemes).
//
// The name used for each property MUST correspond to a security scheme
// declared in the Security Definitions.
type SecurityRequirement struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // Each name must correspond to a security scheme which is declared in
        // the Security Definitions. If the security scheme is of type "oauth2",
        // then the value is a list of scope names required for the execution.
        // For other security scheme types, the array MUST be empty.
        SecurityRequirement map[string]*SecurityRequirement_SecurityRequirementValue `protobuf:"bytes,1,rep,name=security_requirement,json=securityRequirement,proto3" json:"security_requirement,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields       protoimpl.UnknownFields
        sizeCache           protoimpl.SizeCache
}

func (x *SecurityRequirement) Reset() <span class="cov0" title="0">{
        *x = SecurityRequirement{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SecurityRequirement) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SecurityRequirement) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SecurityRequirement) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *SecurityRequirement) GetSecurityRequirement() map[string]*SecurityRequirement_SecurityRequirementValue <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SecurityRequirement
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SecurityRequirement) SetSecurityRequirement(v map[string]*SecurityRequirement_SecurityRequirementValue) <span class="cov0" title="0">{
        x.SecurityRequirement = v
}</span>

type SecurityRequirement_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // Each name must correspond to a security scheme which is declared in
        // the Security Definitions. If the security scheme is of type "oauth2",
        // then the value is a list of scope names required for the execution.
        // For other security scheme types, the array MUST be empty.
        SecurityRequirement map[string]*SecurityRequirement_SecurityRequirementValue
}

func (b0 SecurityRequirement_builder) Build() *SecurityRequirement <span class="cov0" title="0">{
        m0 := &amp;SecurityRequirement{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.SecurityRequirement = b.SecurityRequirement
        return m0
}</span>

// `Scopes` is a representation of OpenAPI v2 specification's Scopes object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#scopesObject
//
// Lists the available scopes for an OAuth2 security scheme.
type Scopes struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // Maps between a name of a scope to a short description of it (as the value
        // of the property).
        Scope         map[string]string `protobuf:"bytes,1,rep,name=scope,proto3" json:"scope,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Scopes) Reset() <span class="cov0" title="0">{
        *x = Scopes{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[17]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Scopes) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Scopes) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Scopes) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[17]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Scopes) GetScope() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Scope
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Scopes) SetScope(v map[string]string) <span class="cov0" title="0">{
        x.Scope = v
}</span>

type Scopes_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // Maps between a name of a scope to a short description of it (as the value
        // of the property).
        Scope map[string]string
}

func (b0 Scopes_builder) Build() *Scopes <span class="cov0" title="0">{
        m0 := &amp;Scopes{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Scope = b.Scope
        return m0
}</span>

// 'FieldConfiguration' provides additional field level properties used when generating the OpenAPI v2 file.
// These properties are not defined by OpenAPIv2, but they are used to control the generation.
type JSONSchema_FieldConfiguration struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // Alternative parameter name when used as path parameter. If set, this will
        // be used as the complete parameter name when this field is used as a path
        // parameter. Use this to avoid having auto generated path parameter names
        // for overlapping paths.
        PathParamName string `protobuf:"bytes,47,opt,name=path_param_name,json=pathParamName,proto3" json:"path_param_name,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *JSONSchema_FieldConfiguration) Reset() <span class="cov0" title="0">{
        *x = JSONSchema_FieldConfiguration{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[27]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *JSONSchema_FieldConfiguration) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*JSONSchema_FieldConfiguration) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *JSONSchema_FieldConfiguration) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[27]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *JSONSchema_FieldConfiguration) GetPathParamName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PathParamName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema_FieldConfiguration) SetPathParamName(v string) <span class="cov0" title="0">{
        x.PathParamName = v
}</span>

type JSONSchema_FieldConfiguration_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // Alternative parameter name when used as path parameter. If set, this will
        // be used as the complete parameter name when this field is used as a path
        // parameter. Use this to avoid having auto generated path parameter names
        // for overlapping paths.
        PathParamName string
}

func (b0 JSONSchema_FieldConfiguration_builder) Build() *JSONSchema_FieldConfiguration <span class="cov0" title="0">{
        m0 := &amp;JSONSchema_FieldConfiguration{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.PathParamName = b.PathParamName
        return m0
}</span>

// If the security scheme is of type "oauth2", then the value is a list of
// scope names required for the execution. For other security scheme types,
// the array MUST be empty.
type SecurityRequirement_SecurityRequirementValue struct {
        state         protoimpl.MessageState `protogen:"hybrid.v1"`
        Scope         []string               `protobuf:"bytes,1,rep,name=scope,proto3" json:"scope,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SecurityRequirement_SecurityRequirementValue) Reset() <span class="cov0" title="0">{
        *x = SecurityRequirement_SecurityRequirementValue{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[32]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SecurityRequirement_SecurityRequirementValue) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SecurityRequirement_SecurityRequirementValue) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SecurityRequirement_SecurityRequirementValue) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[32]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *SecurityRequirement_SecurityRequirementValue) GetScope() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Scope
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SecurityRequirement_SecurityRequirementValue) SetScope(v []string) <span class="cov0" title="0">{
        x.Scope = v
}</span>

type SecurityRequirement_SecurityRequirementValue_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        Scope []string
}

func (b0 SecurityRequirement_SecurityRequirementValue_builder) Build() *SecurityRequirement_SecurityRequirementValue <span class="cov0" title="0">{
        m0 := &amp;SecurityRequirement_SecurityRequirementValue{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Scope = b.Scope
        return m0
}</span>

var File_protoc_gen_openapiv2_options_openapiv2_proto protoreflect.FileDescriptor

var file_protoc_gen_openapiv2_options_openapiv2_proto_rawDesc = []byte{
        0x0a, 0x2c, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e, 0x2d, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x29,
        0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x1c, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x73, 0x74, 0x72, 0x75, 0x63,
        0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xb3, 0x08, 0x0a, 0x07, 0x53, 0x77, 0x61, 0x67,
        0x67, 0x65, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x73, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x12, 0x43, 0x0a,
        0x04, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x67, 0x72,
        0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e,
        0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x04, 0x69, 0x6e,
        0x66, 0x6f, 0x12, 0x12, 0x0a, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x70,
        0x61, 0x74, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x62, 0x61, 0x73, 0x65, 0x50,
        0x61, 0x74, 0x68, 0x12, 0x4b, 0x0a, 0x07, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x73, 0x18, 0x05,
        0x20, 0x03, 0x28, 0x0e, 0x32, 0x31, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65,
        0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x52, 0x07, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x73,
        0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x73, 0x18, 0x06, 0x20, 0x03,
        0x28, 0x09, 0x52, 0x08, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x73, 0x12, 0x1a, 0x0a, 0x08,
        0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08,
        0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x73, 0x12, 0x5f, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x41, 0x2e, 0x67, 0x72,
        0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e,
        0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x2e,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x09,
        0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x12, 0x71, 0x0a, 0x14, 0x73, 0x65, 0x63,
        0x75, 0x72, 0x69, 0x74, 0x79, 0x5f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3e, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67,
        0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65,
        0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x44, 0x65, 0x66, 0x69,
        0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x13, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74,
        0x79, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x5a, 0x0a, 0x08,
        0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x18, 0x0c, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3e,
        0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69,
        0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72,
        0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x08,
        0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x12, 0x42, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73,
        0x18, 0x0d, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61,
        0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e,
        0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x2e, 0x54, 0x61, 0x67, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x12, 0x65, 0x0a, 0x0d,
        0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x64, 0x6f, 0x63, 0x73, 0x18, 0x0e, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x40, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77,
        0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70,
        0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,
        0x45, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44,
        0x6f, 0x63, 0x73, 0x12, 0x62, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e,
        0x73, 0x18, 0x0f, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x42, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67,
        0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65,
        0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x45, 0x78, 0x74, 0x65,
        0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x65, 0x78, 0x74,
        0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x71, 0x0a, 0x0e, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x49, 0x0a, 0x05, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x67, 0x72, 0x70,
        0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
        0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x52,
        0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78,
        0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a,
        0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12,
        0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38,
        0x01, 0x4a, 0x04, 0x08, 0x08, 0x10, 0x09, 0x4a, 0x04, 0x08, 0x09, 0x10, 0x0a, 0x22, 0xd6, 0x07,
        0x0a, 0x09, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x74,
        0x61, 0x67, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x12,
        0x18, 0x0a, 0x07, 0x73, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x07, 0x73, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73,
        0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b,
        0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x65, 0x0a, 0x0d, 0x65,
        0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x64, 0x6f, 0x63, 0x73, 0x18, 0x04, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x40, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61,
        0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x45,
        0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f,
        0x63, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
        0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65,
        0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65,
        0x73, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x73, 0x18, 0x07, 0x20,
        0x03, 0x28, 0x09, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x73, 0x12, 0x61, 0x0a,
        0x09, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b,
        0x32, 0x43, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61,
        0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4f, 0x70, 0x65,
        0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x09, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73,
        0x12, 0x4b, 0x0a, 0x07, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28,
        0x0e, 0x32, 0x31, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e,
        0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x63,
        0x68, 0x65, 0x6d, 0x65, 0x52, 0x07, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x73, 0x12, 0x1e, 0x0a,
        0x0a, 0x64, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x18, 0x0b, 0x20, 0x01, 0x28,
        0x08, 0x52, 0x0a, 0x64, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x12, 0x5a, 0x0a,
        0x08, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x18, 0x0c, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x3e, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70,
        0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75,
        0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x52,
        0x08, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x12, 0x64, 0x0a, 0x0a, 0x65, 0x78, 0x74,
        0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0d, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x44, 0x2e,
        0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e,
        0x74, 0x72, 0x79, 0x52, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x12,
        0x55, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x0e, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77,
        0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70,
        0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,
        0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x61,
        0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x1a, 0x71, 0x0a, 0x0e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x49, 0x0a, 0x05, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x67, 0x72, 0x70, 0x63,
        0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f,
        0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x52, 0x05,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78, 0x74,
        0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03,
        0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x2c,
        0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e,
        0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
        0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01,
        0x4a, 0x04, 0x08, 0x08, 0x10, 0x09, 0x22, 0x62, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65,
        0x74, 0x65, 0x72, 0x73, 0x12, 0x54, 0x0a, 0x07, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x18,
        0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74,
        0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f,
        0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x2e, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
        0x72, 0x52, 0x07, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x22, 0xa3, 0x02, 0x0a, 0x0f, 0x48,
        0x65, 0x61, 0x64, 0x65, 0x72, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x12, 0x12,
        0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61,
        0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x12, 0x53, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x0e, 0x32, 0x3f, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61,
        0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x48,
        0x65, 0x61, 0x64, 0x65, 0x72, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x2e, 0x54,
        0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x6f, 0x72,
        0x6d, 0x61, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61,
        0x74, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x18, 0x05, 0x20,
        0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x45, 0x0a,
        0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e,
        0x10, 0x00, 0x12, 0x0a, 0x0a, 0x06, 0x53, 0x54, 0x52, 0x49, 0x4e, 0x47, 0x10, 0x01, 0x12, 0x0a,
        0x0a, 0x06, 0x4e, 0x55, 0x4d, 0x42, 0x45, 0x52, 0x10, 0x02, 0x12, 0x0b, 0x0a, 0x07, 0x49, 0x4e,
        0x54, 0x45, 0x47, 0x45, 0x52, 0x10, 0x03, 0x12, 0x0b, 0x0a, 0x07, 0x42, 0x4f, 0x4f, 0x4c, 0x45,
        0x41, 0x4e, 0x10, 0x04, 0x4a, 0x04, 0x08, 0x06, 0x10, 0x07, 0x4a, 0x04, 0x08, 0x07, 0x10, 0x08,
        0x22, 0xd8, 0x01, 0x0a, 0x06, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x12, 0x20, 0x0a, 0x0b, 0x64,
        0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a,
        0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x79, 0x70,
        0x65, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x65, 0x66,
        0x61, 0x75, 0x6c, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x64, 0x65, 0x66, 0x61,
        0x75, 0x6c, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x18, 0x0d,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x4a, 0x04, 0x08,
        0x04, 0x10, 0x05, 0x4a, 0x04, 0x08, 0x05, 0x10, 0x06, 0x4a, 0x04, 0x08, 0x07, 0x10, 0x08, 0x4a,
        0x04, 0x08, 0x08, 0x10, 0x09, 0x4a, 0x04, 0x08, 0x09, 0x10, 0x0a, 0x4a, 0x04, 0x08, 0x0a, 0x10,
        0x0b, 0x4a, 0x04, 0x08, 0x0b, 0x10, 0x0c, 0x4a, 0x04, 0x08, 0x0c, 0x10, 0x0d, 0x4a, 0x04, 0x08,
        0x0e, 0x10, 0x0f, 0x4a, 0x04, 0x08, 0x0f, 0x10, 0x10, 0x4a, 0x04, 0x08, 0x10, 0x10, 0x11, 0x4a,
        0x04, 0x08, 0x11, 0x10, 0x12, 0x4a, 0x04, 0x08, 0x12, 0x10, 0x13, 0x22, 0x9a, 0x05, 0x0a, 0x08,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63,
        0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64,
        0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x49, 0x0a, 0x06, 0x73, 0x63,
        0x68, 0x65, 0x6d, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x67, 0x72, 0x70,
        0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
        0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x52, 0x06, 0x73,
        0x63, 0x68, 0x65, 0x6d, 0x61, 0x12, 0x5a, 0x0a, 0x07, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73,
        0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x40, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61,
        0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e,
        0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x48, 0x65, 0x61, 0x64,
        0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x07, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72,
        0x73, 0x12, 0x5d, 0x0a, 0x08, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x73, 0x18, 0x04, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x41, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77,
        0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70,
        0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x45, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
        0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x08, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x73,
        0x12, 0x63, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x05,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x43, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65,
        0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73,
        0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e,
        0x73, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x6d, 0x0a, 0x0c, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x47, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61,
        0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e,
        0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x2e, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x3a, 0x02, 0x38, 0x01, 0x1a, 0x3b, 0x0a, 0x0d, 0x45, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x73,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38,
        0x01, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45,
        0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xd6, 0x03, 0x0a, 0x04, 0x49, 0x6e, 0x66,
        0x6f, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x05, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72,
        0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65,
        0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x28, 0x0a, 0x10, 0x74, 0x65, 0x72,
        0x6d, 0x73, 0x5f, 0x6f, 0x66, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x65, 0x72, 0x6d, 0x73, 0x4f, 0x66, 0x53, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0x12, 0x4c, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x63, 0x74, 0x18, 0x04,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65,
        0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x63, 0x74, 0x52, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x63,
        0x74, 0x12, 0x4c, 0x0a, 0x07, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x18, 0x05, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x32, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61,
        0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4c,
        0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x52, 0x07, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x12,
        0x18, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x5f, 0x0a, 0x0a, 0x65, 0x78, 0x74,
        0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3f, 0x2e,
        0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x45,
        0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a,
        0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78,
        0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a,
        0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12,
        0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38,
        0x01, 0x22, 0x45, 0x0a, 0x07, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x63, 0x74, 0x12, 0x12, 0x0a, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65,
        0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75,
        0x72, 0x6c, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x22, 0x2f, 0x0a, 0x07, 0x4c, 0x69, 0x63, 0x65,
        0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x22, 0x4b, 0x0a, 0x15, 0x45, 0x78, 0x74,
        0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x22, 0xaa, 0x02, 0x0a, 0x06, 0x53, 0x63, 0x68, 0x65, 0x6d,
        0x61, 0x12, 0x56, 0x0a, 0x0b, 0x6a, 0x73, 0x6f, 0x6e, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61,
        0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e,
        0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x52, 0x0a, 0x6a,
        0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x12, 0x24, 0x0a, 0x0d, 0x64, 0x69, 0x73,
        0x63, 0x72, 0x69, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x0d, 0x64, 0x69, 0x73, 0x63, 0x72, 0x69, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x6f, 0x72, 0x12,
        0x1b, 0x0a, 0x09, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0x12, 0x65, 0x0a, 0x0d,
        0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x64, 0x6f, 0x63, 0x73, 0x18, 0x05, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x40, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77,
        0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70,
        0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,
        0x45, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44,
        0x6f, 0x63, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x18, 0x06,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x4a, 0x04, 0x08,
        0x04, 0x10, 0x05, 0x22, 0xe8, 0x03, 0x0a, 0x0a, 0x45, 0x6e, 0x75, 0x6d, 0x53, 0x63, 0x68, 0x65,
        0x6d, 0x61, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x12, 0x14,
        0x0a, 0x05, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74,
        0x69, 0x74, 0x6c, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64,
        0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64,
        0x12, 0x1b, 0x0a, 0x09, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x18, 0x05, 0x20,
        0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0x12, 0x65, 0x0a,
        0x0d, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x64, 0x6f, 0x63, 0x73, 0x18, 0x06,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x40, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65,
        0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x45, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e,
        0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c,
        0x44, 0x6f, 0x63, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x18,
        0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x12, 0x10,
        0x0a, 0x03, 0x72, 0x65, 0x66, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x72, 0x65, 0x66,
        0x12, 0x65, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x09,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x45, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65,
        0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x45, 0x6e, 0x75, 0x6d, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x45, 0x78, 0x74, 0x65,
        0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x65, 0x78, 0x74,
        0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78, 0x74, 0x65, 0x6e,
        0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65,
        0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x2c, 0x0a, 0x05,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f,
        0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x56, 0x61,
        0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xd7,
        0x0a, 0x0a, 0x0a, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x12, 0x10, 0x0a,
        0x03, 0x72, 0x65, 0x66, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x72, 0x65, 0x66, 0x12,
        0x14, 0x0a, 0x05, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
        0x74, 0x69, 0x74, 0x6c, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63,
        0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x65, 0x66, 0x61, 0x75,
        0x6c, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c,
        0x74, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x18, 0x08,
        0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0x12, 0x18,
        0x0a, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x6d, 0x75, 0x6c, 0x74,
        0x69, 0x70, 0x6c, 0x65, 0x5f, 0x6f, 0x66, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0a, 0x6d,
        0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x4f, 0x66, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x61, 0x78,
        0x69, 0x6d, 0x75, 0x6d, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x01, 0x52, 0x07, 0x6d, 0x61, 0x78, 0x69,
        0x6d, 0x75, 0x6d, 0x12, 0x2b, 0x0a, 0x11, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65,
        0x5f, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x52, 0x10,
        0x65, 0x78, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65, 0x4d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d,
        0x12, 0x18, 0x0a, 0x07, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x18, 0x0d, 0x20, 0x01, 0x28,
        0x01, 0x52, 0x07, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x12, 0x2b, 0x0a, 0x11, 0x65, 0x78,
        0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65, 0x5f, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x18,
        0x0e, 0x20, 0x01, 0x28, 0x08, 0x52, 0x10, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65,
        0x4d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x12, 0x1d, 0x0a, 0x0a, 0x6d, 0x61, 0x78, 0x5f, 0x6c,
        0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x6d, 0x61, 0x78,
        0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x12, 0x1d, 0x0a, 0x0a, 0x6d, 0x69, 0x6e, 0x5f, 0x6c, 0x65,
        0x6e, 0x67, 0x74, 0x68, 0x18, 0x10, 0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x6d, 0x69, 0x6e, 0x4c,
        0x65, 0x6e, 0x67, 0x74, 0x68, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e,
        0x18, 0x11, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x12,
        0x1b, 0x0a, 0x09, 0x6d, 0x61, 0x78, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x14, 0x20, 0x01,
        0x28, 0x04, 0x52, 0x08, 0x6d, 0x61, 0x78, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x12, 0x1b, 0x0a, 0x09,
        0x6d, 0x69, 0x6e, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x15, 0x20, 0x01, 0x28, 0x04, 0x52,
        0x08, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x75, 0x6e, 0x69,
        0x71, 0x75, 0x65, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x16, 0x20, 0x01, 0x28, 0x08, 0x52,
        0x0b, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x12, 0x25, 0x0a, 0x0e,
        0x6d, 0x61, 0x78, 0x5f, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x18, 0x18,
        0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x6d, 0x61, 0x78, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74,
        0x69, 0x65, 0x73, 0x12, 0x25, 0x0a, 0x0e, 0x6d, 0x69, 0x6e, 0x5f, 0x70, 0x72, 0x6f, 0x70, 0x65,
        0x72, 0x74, 0x69, 0x65, 0x73, 0x18, 0x19, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x6d, 0x69, 0x6e,
        0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65,
        0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x18, 0x1a, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08, 0x72, 0x65,
        0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x61, 0x72, 0x72, 0x61, 0x79, 0x18,
        0x22, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x61, 0x72, 0x72, 0x61, 0x79, 0x12, 0x5f, 0x0a, 0x04,
        0x74, 0x79, 0x70, 0x65, 0x18, 0x23, 0x20, 0x03, 0x28, 0x0e, 0x32, 0x4b, 0x2e, 0x67, 0x72, 0x70,
        0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
        0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d,
        0x61, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x53, 0x69, 0x6d, 0x70,
        0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x73, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x16, 0x0a,
        0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x24, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x66,
        0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x65, 0x6e, 0x75, 0x6d, 0x18, 0x2e, 0x20,
        0x03, 0x28, 0x09, 0x52, 0x04, 0x65, 0x6e, 0x75, 0x6d, 0x12, 0x7a, 0x0a, 0x13, 0x66, 0x69, 0x65,
        0x6c, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
        0x18, 0xe9, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x48, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67,
        0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65,
        0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x46,
        0x69, 0x65, 0x6c, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f,
        0x6e, 0x52, 0x12, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x65, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69,
        0x6f, 0x6e, 0x73, 0x18, 0x30, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x45, 0x2e, 0x67, 0x72, 0x70, 0x63,
        0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f,
        0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61,
        0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79,
        0x52, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x3c, 0x0a, 0x12,
        0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x12, 0x26, 0x0a, 0x0f, 0x70, 0x61, 0x74, 0x68, 0x5f, 0x70, 0x61, 0x72, 0x61, 0x6d,
        0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x2f, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x70, 0x61, 0x74,
        0x68, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x4e, 0x61, 0x6d, 0x65, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78,
        0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a,
        0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12,
        0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38,
        0x01, 0x22, 0x77, 0x0a, 0x15, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x53,
        0x69, 0x6d, 0x70, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x73, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e,
        0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x09, 0x0a, 0x05, 0x41, 0x52, 0x52, 0x41, 0x59,
        0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x42, 0x4f, 0x4f, 0x4c, 0x45, 0x41, 0x4e, 0x10, 0x02, 0x12,
        0x0b, 0x0a, 0x07, 0x49, 0x4e, 0x54, 0x45, 0x47, 0x45, 0x52, 0x10, 0x03, 0x12, 0x08, 0x0a, 0x04,
        0x4e, 0x55, 0x4c, 0x4c, 0x10, 0x04, 0x12, 0x0a, 0x0a, 0x06, 0x4e, 0x55, 0x4d, 0x42, 0x45, 0x52,
        0x10, 0x05, 0x12, 0x0a, 0x0a, 0x06, 0x4f, 0x42, 0x4a, 0x45, 0x43, 0x54, 0x10, 0x06, 0x12, 0x0a,
        0x0a, 0x06, 0x53, 0x54, 0x52, 0x49, 0x4e, 0x47, 0x10, 0x07, 0x4a, 0x04, 0x08, 0x01, 0x10, 0x02,
        0x4a, 0x04, 0x08, 0x02, 0x10, 0x03, 0x4a, 0x04, 0x08, 0x04, 0x10, 0x05, 0x4a, 0x04, 0x08, 0x12,
        0x10, 0x13, 0x4a, 0x04, 0x08, 0x13, 0x10, 0x14, 0x4a, 0x04, 0x08, 0x17, 0x10, 0x18, 0x4a, 0x04,
        0x08, 0x1b, 0x10, 0x1c, 0x4a, 0x04, 0x08, 0x1c, 0x10, 0x1d, 0x4a, 0x04, 0x08, 0x1d, 0x10, 0x1e,
        0x4a, 0x04, 0x08, 0x1e, 0x10, 0x22, 0x4a, 0x04, 0x08, 0x25, 0x10, 0x2a, 0x4a, 0x04, 0x08, 0x2a,
        0x10, 0x2b, 0x4a, 0x04, 0x08, 0x2b, 0x10, 0x2e, 0x22, 0xd9, 0x02, 0x0a, 0x03, 0x54, 0x61, 0x67,
        0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72,
        0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x65, 0x0a, 0x0d, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e,
        0x61, 0x6c, 0x5f, 0x64, 0x6f, 0x63, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x40, 0x2e,
        0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x72, 0x6e,
        0x61, 0x6c, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52,
        0x0c, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x63, 0x73, 0x12, 0x5e, 0x0a,
        0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28,
        0x0b, 0x32, 0x3e, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e,
        0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x54, 0x61,
        0x67, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x52, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x55, 0x0a,
        0x0f, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79,
        0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b,
        0x65, 0x79, 0x12, 0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x3a, 0x02, 0x38, 0x01, 0x22, 0xf7, 0x01, 0x0a, 0x13, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74,
        0x79, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x68, 0x0a, 0x08,
        0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x4c,
        0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69,
        0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72,
        0x69, 0x74, 0x79, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53,
        0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x08, 0x73, 0x65,
        0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x1a, 0x76, 0x0a, 0x0d, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69,
        0x74, 0x79, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x4f, 0x0a, 0x05, 0x76, 0x61, 0x6c,
        0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x39, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e,
        0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67,
        0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x53, 0x63, 0x68,
        0x65, 0x6d, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xff,
        0x06, 0x0a, 0x0e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x53, 0x63, 0x68, 0x65, 0x6d,
        0x65, 0x12, 0x52, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32,
        0x3e, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70,
        0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75,
        0x72, 0x69, 0x74, 0x79, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x52,
        0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63,
        0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18,
        0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x4c, 0x0a, 0x02, 0x69,
        0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x3c, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67,
        0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65,
        0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x53, 0x63, 0x68, 0x65,
        0x6d, 0x65, 0x2e, 0x49, 0x6e, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x52, 0x0a, 0x04, 0x66, 0x6c, 0x6f,
        0x77, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x3e, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67,
        0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65,
        0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x53, 0x63, 0x68, 0x65,
        0x6d, 0x65, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x52, 0x04, 0x66, 0x6c, 0x6f, 0x77, 0x12, 0x2b, 0x0a,
        0x11, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x75,
        0x72, 0x6c, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72,
        0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x55, 0x72, 0x6c, 0x12, 0x1b, 0x0a, 0x09, 0x74, 0x6f,
        0x6b, 0x65, 0x6e, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x74,
        0x6f, 0x6b, 0x65, 0x6e, 0x55, 0x72, 0x6c, 0x12, 0x49, 0x0a, 0x06, 0x73, 0x63, 0x6f, 0x70, 0x65,
        0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67,
        0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65,
        0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x73, 0x52, 0x06, 0x73, 0x63, 0x6f, 0x70,
        0x65, 0x73, 0x12, 0x69, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73,
        0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x49, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61,
        0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e,
        0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x53, 0x63, 0x68, 0x65, 0x6d,
        0x65, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x52, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x55, 0x0a,
        0x0f, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79,
        0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b,
        0x65, 0x79, 0x12, 0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x3a, 0x02, 0x38, 0x01, 0x22, 0x4b, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x10, 0x0a, 0x0c,
        0x54, 0x59, 0x50, 0x45, 0x5f, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x10, 0x00, 0x12, 0x0e,
        0x0a, 0x0a, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x42, 0x41, 0x53, 0x49, 0x43, 0x10, 0x01, 0x12, 0x10,
        0x0a, 0x0c, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x41, 0x50, 0x49, 0x5f, 0x4b, 0x45, 0x59, 0x10, 0x02,
        0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4f, 0x41, 0x55, 0x54, 0x48, 0x32, 0x10,
        0x03, 0x22, 0x31, 0x0a, 0x02, 0x49, 0x6e, 0x12, 0x0e, 0x0a, 0x0a, 0x49, 0x4e, 0x5f, 0x49, 0x4e,
        0x56, 0x41, 0x4c, 0x49, 0x44, 0x10, 0x00, 0x12, 0x0c, 0x0a, 0x08, 0x49, 0x4e, 0x5f, 0x51, 0x55,
        0x45, 0x52, 0x59, 0x10, 0x01, 0x12, 0x0d, 0x0a, 0x09, 0x49, 0x4e, 0x5f, 0x48, 0x45, 0x41, 0x44,
        0x45, 0x52, 0x10, 0x02, 0x22, 0x6a, 0x0a, 0x04, 0x46, 0x6c, 0x6f, 0x77, 0x12, 0x10, 0x0a, 0x0c,
        0x46, 0x4c, 0x4f, 0x57, 0x5f, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x10, 0x00, 0x12, 0x11,
        0x0a, 0x0d, 0x46, 0x4c, 0x4f, 0x57, 0x5f, 0x49, 0x4d, 0x50, 0x4c, 0x49, 0x43, 0x49, 0x54, 0x10,
        0x01, 0x12, 0x11, 0x0a, 0x0d, 0x46, 0x4c, 0x4f, 0x57, 0x5f, 0x50, 0x41, 0x53, 0x53, 0x57, 0x4f,
        0x52, 0x44, 0x10, 0x02, 0x12, 0x14, 0x0a, 0x10, 0x46, 0x4c, 0x4f, 0x57, 0x5f, 0x41, 0x50, 0x50,
        0x4c, 0x49, 0x43, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x03, 0x12, 0x14, 0x0a, 0x10, 0x46, 0x4c,
        0x4f, 0x57, 0x5f, 0x41, 0x43, 0x43, 0x45, 0x53, 0x53, 0x5f, 0x43, 0x4f, 0x44, 0x45, 0x10, 0x04,
        0x22, 0xf6, 0x02, 0x0a, 0x13, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71,
        0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x8a, 0x01, 0x0a, 0x14, 0x73, 0x65, 0x63,
        0x75, 0x72, 0x69, 0x74, 0x79, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e,
        0x74, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x57, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67,
        0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65,
        0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75,
        0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79,
        0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79,
        0x52, 0x13, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72,
        0x65, 0x6d, 0x65, 0x6e, 0x74, 0x1a, 0x30, 0x0a, 0x18, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74,
        0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x56, 0x61, 0x6c, 0x75,
        0x65, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09,
        0x52, 0x05, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x1a, 0x9f, 0x01, 0x0a, 0x18, 0x53, 0x65, 0x63, 0x75,
        0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x45,
        0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x6d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x57, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74,
        0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f,
        0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72,
        0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x65,
        0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x96, 0x01, 0x0a, 0x06, 0x53, 0x63,
        0x6f, 0x70, 0x65, 0x73, 0x12, 0x52, 0x0a, 0x05, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x18, 0x01, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x3c, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77,
        0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70,
        0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,
        0x53, 0x63, 0x6f, 0x70, 0x65, 0x73, 0x2e, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x52, 0x05, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x1a, 0x38, 0x0a, 0x0a, 0x53, 0x63, 0x6f, 0x70,
        0x65, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75,
        0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02,
        0x38, 0x01, 0x2a, 0x3b, 0x0a, 0x06, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x12, 0x0b, 0x0a, 0x07,
        0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x08, 0x0a, 0x04, 0x48, 0x54, 0x54,
        0x50, 0x10, 0x01, 0x12, 0x09, 0x0a, 0x05, 0x48, 0x54, 0x54, 0x50, 0x53, 0x10, 0x02, 0x12, 0x06,
        0x0a, 0x02, 0x57, 0x53, 0x10, 0x03, 0x12, 0x07, 0x0a, 0x03, 0x57, 0x53, 0x53, 0x10, 0x04, 0x42,
        0x48, 0x5a, 0x46, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x67, 0x72,
        0x70, 0x63, 0x2d, 0x65, 0x63, 0x6f, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x2f, 0x67, 0x72, 0x70,
        0x63, 0x2d, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2f, 0x76, 0x32, 0x2f, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e, 0x2d, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x2f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x33,
}

var file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes = make([]protoimpl.EnumInfo, 6)
var file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes = make([]protoimpl.MessageInfo, 35)
var file_protoc_gen_openapiv2_options_openapiv2_proto_goTypes = []any{
        (Scheme)(0),                           // 0: grpc.gateway.protoc_gen_openapiv2.options.Scheme
        (HeaderParameter_Type)(0),             // 1: grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter.Type
        (JSONSchema_JSONSchemaSimpleTypes)(0), // 2: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.JSONSchemaSimpleTypes
        (SecurityScheme_Type)(0),              // 3: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Type
        (SecurityScheme_In)(0),                // 4: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.In
        (SecurityScheme_Flow)(0),              // 5: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Flow
        (*Swagger)(nil),                       // 6: grpc.gateway.protoc_gen_openapiv2.options.Swagger
        (*Operation)(nil),                     // 7: grpc.gateway.protoc_gen_openapiv2.options.Operation
        (*Parameters)(nil),                    // 8: grpc.gateway.protoc_gen_openapiv2.options.Parameters
        (*HeaderParameter)(nil),               // 9: grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter
        (*Header)(nil),                        // 10: grpc.gateway.protoc_gen_openapiv2.options.Header
        (*Response)(nil),                      // 11: grpc.gateway.protoc_gen_openapiv2.options.Response
        (*Info)(nil),                          // 12: grpc.gateway.protoc_gen_openapiv2.options.Info
        (*Contact)(nil),                       // 13: grpc.gateway.protoc_gen_openapiv2.options.Contact
        (*License)(nil),                       // 14: grpc.gateway.protoc_gen_openapiv2.options.License
        (*ExternalDocumentation)(nil),         // 15: grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
        (*Schema)(nil),                        // 16: grpc.gateway.protoc_gen_openapiv2.options.Schema
        (*EnumSchema)(nil),                    // 17: grpc.gateway.protoc_gen_openapiv2.options.EnumSchema
        (*JSONSchema)(nil),                    // 18: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema
        (*Tag)(nil),                           // 19: grpc.gateway.protoc_gen_openapiv2.options.Tag
        (*SecurityDefinitions)(nil),           // 20: grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions
        (*SecurityScheme)(nil),                // 21: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme
        (*SecurityRequirement)(nil),           // 22: grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement
        (*Scopes)(nil),                        // 23: grpc.gateway.protoc_gen_openapiv2.options.Scopes
        nil,                                   // 24: grpc.gateway.protoc_gen_openapiv2.options.Swagger.ResponsesEntry
        nil,                                   // 25: grpc.gateway.protoc_gen_openapiv2.options.Swagger.ExtensionsEntry
        nil,                                   // 26: grpc.gateway.protoc_gen_openapiv2.options.Operation.ResponsesEntry
        nil,                                   // 27: grpc.gateway.protoc_gen_openapiv2.options.Operation.ExtensionsEntry
        nil,                                   // 28: grpc.gateway.protoc_gen_openapiv2.options.Response.HeadersEntry
        nil,                                   // 29: grpc.gateway.protoc_gen_openapiv2.options.Response.ExamplesEntry
        nil,                                   // 30: grpc.gateway.protoc_gen_openapiv2.options.Response.ExtensionsEntry
        nil,                                   // 31: grpc.gateway.protoc_gen_openapiv2.options.Info.ExtensionsEntry
        nil,                                   // 32: grpc.gateway.protoc_gen_openapiv2.options.EnumSchema.ExtensionsEntry
        (*JSONSchema_FieldConfiguration)(nil), // 33: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration
        nil,                                   // 34: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.ExtensionsEntry
        nil,                                   // 35: grpc.gateway.protoc_gen_openapiv2.options.Tag.ExtensionsEntry
        nil,                                   // 36: grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions.SecurityEntry
        nil,                                   // 37: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.ExtensionsEntry
        (*SecurityRequirement_SecurityRequirementValue)(nil), // 38: grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue
        nil,                    // 39: grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementEntry
        nil,                    // 40: grpc.gateway.protoc_gen_openapiv2.options.Scopes.ScopeEntry
        (*structpb.Value)(nil), // 41: google.protobuf.Value
}
var file_protoc_gen_openapiv2_options_openapiv2_proto_depIdxs = []int32{
        12, // 0: grpc.gateway.protoc_gen_openapiv2.options.Swagger.info:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Info
        0,  // 1: grpc.gateway.protoc_gen_openapiv2.options.Swagger.schemes:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Scheme
        24, // 2: grpc.gateway.protoc_gen_openapiv2.options.Swagger.responses:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Swagger.ResponsesEntry
        20, // 3: grpc.gateway.protoc_gen_openapiv2.options.Swagger.security_definitions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions
        22, // 4: grpc.gateway.protoc_gen_openapiv2.options.Swagger.security:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement
        19, // 5: grpc.gateway.protoc_gen_openapiv2.options.Swagger.tags:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Tag
        15, // 6: grpc.gateway.protoc_gen_openapiv2.options.Swagger.external_docs:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
        25, // 7: grpc.gateway.protoc_gen_openapiv2.options.Swagger.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Swagger.ExtensionsEntry
        15, // 8: grpc.gateway.protoc_gen_openapiv2.options.Operation.external_docs:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
        26, // 9: grpc.gateway.protoc_gen_openapiv2.options.Operation.responses:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Operation.ResponsesEntry
        0,  // 10: grpc.gateway.protoc_gen_openapiv2.options.Operation.schemes:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Scheme
        22, // 11: grpc.gateway.protoc_gen_openapiv2.options.Operation.security:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement
        27, // 12: grpc.gateway.protoc_gen_openapiv2.options.Operation.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Operation.ExtensionsEntry
        8,  // 13: grpc.gateway.protoc_gen_openapiv2.options.Operation.parameters:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Parameters
        9,  // 14: grpc.gateway.protoc_gen_openapiv2.options.Parameters.headers:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter
        1,  // 15: grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter.type:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter.Type
        16, // 16: grpc.gateway.protoc_gen_openapiv2.options.Response.schema:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Schema
        28, // 17: grpc.gateway.protoc_gen_openapiv2.options.Response.headers:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Response.HeadersEntry
        29, // 18: grpc.gateway.protoc_gen_openapiv2.options.Response.examples:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Response.ExamplesEntry
        30, // 19: grpc.gateway.protoc_gen_openapiv2.options.Response.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Response.ExtensionsEntry
        13, // 20: grpc.gateway.protoc_gen_openapiv2.options.Info.contact:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Contact
        14, // 21: grpc.gateway.protoc_gen_openapiv2.options.Info.license:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.License
        31, // 22: grpc.gateway.protoc_gen_openapiv2.options.Info.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Info.ExtensionsEntry
        18, // 23: grpc.gateway.protoc_gen_openapiv2.options.Schema.json_schema:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.JSONSchema
        15, // 24: grpc.gateway.protoc_gen_openapiv2.options.Schema.external_docs:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
        15, // 25: grpc.gateway.protoc_gen_openapiv2.options.EnumSchema.external_docs:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
        32, // 26: grpc.gateway.protoc_gen_openapiv2.options.EnumSchema.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.EnumSchema.ExtensionsEntry
        2,  // 27: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.type:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.JSONSchemaSimpleTypes
        33, // 28: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.field_configuration:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration
        34, // 29: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.ExtensionsEntry
        15, // 30: grpc.gateway.protoc_gen_openapiv2.options.Tag.external_docs:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
        35, // 31: grpc.gateway.protoc_gen_openapiv2.options.Tag.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Tag.ExtensionsEntry
        36, // 32: grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions.security:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions.SecurityEntry
        3,  // 33: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.type:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Type
        4,  // 34: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.in:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.In
        5,  // 35: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.flow:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Flow
        23, // 36: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.scopes:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Scopes
        37, // 37: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.ExtensionsEntry
        39, // 38: grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.security_requirement:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementEntry
        40, // 39: grpc.gateway.protoc_gen_openapiv2.options.Scopes.scope:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Scopes.ScopeEntry
        11, // 40: grpc.gateway.protoc_gen_openapiv2.options.Swagger.ResponsesEntry.value:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Response
        41, // 41: grpc.gateway.protoc_gen_openapiv2.options.Swagger.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        11, // 42: grpc.gateway.protoc_gen_openapiv2.options.Operation.ResponsesEntry.value:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Response
        41, // 43: grpc.gateway.protoc_gen_openapiv2.options.Operation.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        10, // 44: grpc.gateway.protoc_gen_openapiv2.options.Response.HeadersEntry.value:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Header
        41, // 45: grpc.gateway.protoc_gen_openapiv2.options.Response.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        41, // 46: grpc.gateway.protoc_gen_openapiv2.options.Info.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        41, // 47: grpc.gateway.protoc_gen_openapiv2.options.EnumSchema.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        41, // 48: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        41, // 49: grpc.gateway.protoc_gen_openapiv2.options.Tag.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        21, // 50: grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions.SecurityEntry.value:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme
        41, // 51: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        38, // 52: grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementEntry.value:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue
        53, // [53:53] is the sub-list for method output_type
        53, // [53:53] is the sub-list for method input_type
        53, // [53:53] is the sub-list for extension type_name
        53, // [53:53] is the sub-list for extension extendee
        0,  // [0:53] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_protoc_gen_openapiv2_options_openapiv2_proto_init() }</span>
func file_protoc_gen_openapiv2_options_openapiv2_proto_init() <span class="cov0" title="0">{
        if File_protoc_gen_openapiv2_options_openapiv2_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_protoc_gen_openapiv2_options_openapiv2_proto_rawDesc,
                        NumEnums:      6,
                        NumMessages:   35,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_protoc_gen_openapiv2_options_openapiv2_proto_goTypes,
                DependencyIndexes: file_protoc_gen_openapiv2_options_openapiv2_proto_depIdxs,
                EnumInfos:         file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes,
                MessageInfos:      file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes,
        }.Build()
        File_protoc_gen_openapiv2_options_openapiv2_proto = out.File
        file_protoc_gen_openapiv2_options_openapiv2_proto_rawDesc = nil
        file_protoc_gen_openapiv2_options_openapiv2_proto_goTypes = nil
        file_protoc_gen_openapiv2_options_openapiv2_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.26.0
//         protoc        v3.15.5
// source: validate/validate.proto

package validate

import (
        reflect "reflect"
        sync "sync"

        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        descriptorpb "google.golang.org/protobuf/types/descriptorpb"
        durationpb "google.golang.org/protobuf/types/known/durationpb"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// WellKnownRegex contain some well-known patterns.
type KnownRegex int32

const (
        KnownRegex_UNKNOWN KnownRegex = 0
        // HTTP header name as defined by RFC 7230.
        KnownRegex_HTTP_HEADER_NAME KnownRegex = 1
        // HTTP header value as defined by RFC 7230.
        KnownRegex_HTTP_HEADER_VALUE KnownRegex = 2
)

// Enum value maps for KnownRegex.
var (
        KnownRegex_name = map[int32]string{
                0: "UNKNOWN",
                1: "HTTP_HEADER_NAME",
                2: "HTTP_HEADER_VALUE",
        }
        KnownRegex_value = map[string]int32{
                "UNKNOWN":           0,
                "HTTP_HEADER_NAME":  1,
                "HTTP_HEADER_VALUE": 2,
        }
)

func (x KnownRegex) Enum() *KnownRegex <span class="cov0" title="0">{
        p := new(KnownRegex)
        *p = x
        return p
}</span>

func (x KnownRegex) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (KnownRegex) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_validate_validate_proto_enumTypes[0].Descriptor()
}</span>

func (KnownRegex) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_validate_validate_proto_enumTypes[0]
}</span>

func (x KnownRegex) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Do not use.
func (x *KnownRegex) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*x = KnownRegex(num)
        return nil</span>
}

// Deprecated: Use KnownRegex.Descriptor instead.
func (KnownRegex) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{0}
}</span>

// FieldRules encapsulates the rules for each type of field. Depending on the
// field, the correct set should be used to ensure proper validations.
type FieldRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Message *MessageRules `protobuf:"bytes,17,opt,name=message" json:"message,omitempty"`
        // Types that are assignable to Type:
        //        *FieldRules_Float
        //        *FieldRules_Double
        //        *FieldRules_Int32
        //        *FieldRules_Int64
        //        *FieldRules_Uint32
        //        *FieldRules_Uint64
        //        *FieldRules_Sint32
        //        *FieldRules_Sint64
        //        *FieldRules_Fixed32
        //        *FieldRules_Fixed64
        //        *FieldRules_Sfixed32
        //        *FieldRules_Sfixed64
        //        *FieldRules_Bool
        //        *FieldRules_String_
        //        *FieldRules_Bytes
        //        *FieldRules_Enum
        //        *FieldRules_Repeated
        //        *FieldRules_Map
        //        *FieldRules_Any
        //        *FieldRules_Duration
        //        *FieldRules_Timestamp
        Type isFieldRules_Type `protobuf_oneof:"type"`
}

func (x *FieldRules) Reset() <span class="cov0" title="0">{
        *x = FieldRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FieldRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FieldRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FieldRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FieldRules.ProtoReflect.Descriptor instead.
func (*FieldRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{0}
}</span>

func (x *FieldRules) GetMessage() *MessageRules <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *FieldRules) GetType() isFieldRules_Type <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Type
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetFloat() *FloatRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Float); ok </span><span class="cov0" title="0">{
                return x.Float
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetDouble() *DoubleRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Double); ok </span><span class="cov0" title="0">{
                return x.Double
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetInt32() *Int32Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Int32); ok </span><span class="cov0" title="0">{
                return x.Int32
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetInt64() *Int64Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Int64); ok </span><span class="cov0" title="0">{
                return x.Int64
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetUint32() *UInt32Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Uint32); ok </span><span class="cov0" title="0">{
                return x.Uint32
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetUint64() *UInt64Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Uint64); ok </span><span class="cov0" title="0">{
                return x.Uint64
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetSint32() *SInt32Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Sint32); ok </span><span class="cov0" title="0">{
                return x.Sint32
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetSint64() *SInt64Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Sint64); ok </span><span class="cov0" title="0">{
                return x.Sint64
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetFixed32() *Fixed32Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Fixed32); ok </span><span class="cov0" title="0">{
                return x.Fixed32
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetFixed64() *Fixed64Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Fixed64); ok </span><span class="cov0" title="0">{
                return x.Fixed64
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetSfixed32() *SFixed32Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Sfixed32); ok </span><span class="cov0" title="0">{
                return x.Sfixed32
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetSfixed64() *SFixed64Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Sfixed64); ok </span><span class="cov0" title="0">{
                return x.Sfixed64
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetBool() *BoolRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Bool); ok </span><span class="cov0" title="0">{
                return x.Bool
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetString_() *StringRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_String_); ok </span><span class="cov0" title="0">{
                return x.String_
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetBytes() *BytesRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Bytes); ok </span><span class="cov0" title="0">{
                return x.Bytes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetEnum() *EnumRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Enum); ok </span><span class="cov0" title="0">{
                return x.Enum
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetRepeated() *RepeatedRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Repeated); ok </span><span class="cov0" title="0">{
                return x.Repeated
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetMap() *MapRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Map); ok </span><span class="cov0" title="0">{
                return x.Map
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetAny() *AnyRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Any); ok </span><span class="cov0" title="0">{
                return x.Any
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetDuration() *DurationRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Duration); ok </span><span class="cov0" title="0">{
                return x.Duration
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetTimestamp() *TimestampRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Timestamp); ok </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isFieldRules_Type interface {
        isFieldRules_Type()
}

type FieldRules_Float struct {
        // Scalar Field Types
        Float *FloatRules `protobuf:"bytes,1,opt,name=float,oneof"`
}

type FieldRules_Double struct {
        Double *DoubleRules `protobuf:"bytes,2,opt,name=double,oneof"`
}

type FieldRules_Int32 struct {
        Int32 *Int32Rules `protobuf:"bytes,3,opt,name=int32,oneof"`
}

type FieldRules_Int64 struct {
        Int64 *Int64Rules `protobuf:"bytes,4,opt,name=int64,oneof"`
}

type FieldRules_Uint32 struct {
        Uint32 *UInt32Rules `protobuf:"bytes,5,opt,name=uint32,oneof"`
}

type FieldRules_Uint64 struct {
        Uint64 *UInt64Rules `protobuf:"bytes,6,opt,name=uint64,oneof"`
}

type FieldRules_Sint32 struct {
        Sint32 *SInt32Rules `protobuf:"bytes,7,opt,name=sint32,oneof"`
}

type FieldRules_Sint64 struct {
        Sint64 *SInt64Rules `protobuf:"bytes,8,opt,name=sint64,oneof"`
}

type FieldRules_Fixed32 struct {
        Fixed32 *Fixed32Rules `protobuf:"bytes,9,opt,name=fixed32,oneof"`
}

type FieldRules_Fixed64 struct {
        Fixed64 *Fixed64Rules `protobuf:"bytes,10,opt,name=fixed64,oneof"`
}

type FieldRules_Sfixed32 struct {
        Sfixed32 *SFixed32Rules `protobuf:"bytes,11,opt,name=sfixed32,oneof"`
}

type FieldRules_Sfixed64 struct {
        Sfixed64 *SFixed64Rules `protobuf:"bytes,12,opt,name=sfixed64,oneof"`
}

type FieldRules_Bool struct {
        Bool *BoolRules `protobuf:"bytes,13,opt,name=bool,oneof"`
}

type FieldRules_String_ struct {
        String_ *StringRules `protobuf:"bytes,14,opt,name=string,oneof"`
}

type FieldRules_Bytes struct {
        Bytes *BytesRules `protobuf:"bytes,15,opt,name=bytes,oneof"`
}

type FieldRules_Enum struct {
        // Complex Field Types
        Enum *EnumRules `protobuf:"bytes,16,opt,name=enum,oneof"`
}

type FieldRules_Repeated struct {
        Repeated *RepeatedRules `protobuf:"bytes,18,opt,name=repeated,oneof"`
}

type FieldRules_Map struct {
        Map *MapRules `protobuf:"bytes,19,opt,name=map,oneof"`
}

type FieldRules_Any struct {
        // Well-Known Field Types
        Any *AnyRules `protobuf:"bytes,20,opt,name=any,oneof"`
}

type FieldRules_Duration struct {
        Duration *DurationRules `protobuf:"bytes,21,opt,name=duration,oneof"`
}

type FieldRules_Timestamp struct {
        Timestamp *TimestampRules `protobuf:"bytes,22,opt,name=timestamp,oneof"`
}

func (*FieldRules_Float) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Double) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Int32) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Int64) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Uint32) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Uint64) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Sint32) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Sint64) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Fixed32) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Fixed64) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Sfixed32) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Sfixed64) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Bool) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_String_) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Bytes) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Enum) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Repeated) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Map) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Any) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Duration) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Timestamp) isFieldRules_Type() {<span class="cov0" title="0">}</span>

// FloatRules describes the constraints applied to `float` values
type FloatRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *float32 `protobuf:"fixed32,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *float32 `protobuf:"fixed32,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *float32 `protobuf:"fixed32,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *float32 `protobuf:"fixed32,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *float32 `protobuf:"fixed32,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []float32 `protobuf:"fixed32,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []float32 `protobuf:"fixed32,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *FloatRules) Reset() <span class="cov0" title="0">{
        *x = FloatRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FloatRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FloatRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FloatRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FloatRules.ProtoReflect.Descriptor instead.
func (*FloatRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{1}
}</span>

func (x *FloatRules) GetConst() float32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FloatRules) GetLt() float32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FloatRules) GetLte() float32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FloatRules) GetGt() float32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FloatRules) GetGte() float32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FloatRules) GetIn() []float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FloatRules) GetNotIn() []float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FloatRules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// DoubleRules describes the constraints applied to `double` values
type DoubleRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *float64 `protobuf:"fixed64,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *float64 `protobuf:"fixed64,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *float64 `protobuf:"fixed64,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *float64 `protobuf:"fixed64,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *float64 `protobuf:"fixed64,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []float64 `protobuf:"fixed64,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []float64 `protobuf:"fixed64,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *DoubleRules) Reset() <span class="cov0" title="0">{
        *x = DoubleRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DoubleRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DoubleRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DoubleRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DoubleRules.ProtoReflect.Descriptor instead.
func (*DoubleRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{2}
}</span>

func (x *DoubleRules) GetConst() float64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DoubleRules) GetLt() float64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DoubleRules) GetLte() float64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DoubleRules) GetGt() float64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DoubleRules) GetGte() float64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DoubleRules) GetIn() []float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DoubleRules) GetNotIn() []float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DoubleRules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Int32Rules describes the constraints applied to `int32` values
type Int32Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *int32 `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *int32 `protobuf:"varint,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *int32 `protobuf:"varint,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *int32 `protobuf:"varint,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *int32 `protobuf:"varint,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []int32 `protobuf:"varint,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []int32 `protobuf:"varint,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *Int32Rules) Reset() <span class="cov0" title="0">{
        *x = Int32Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Int32Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Int32Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Int32Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Int32Rules.ProtoReflect.Descriptor instead.
func (*Int32Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{3}
}</span>

func (x *Int32Rules) GetConst() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int32Rules) GetLt() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int32Rules) GetLte() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int32Rules) GetGt() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int32Rules) GetGte() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int32Rules) GetIn() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Int32Rules) GetNotIn() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Int32Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Int64Rules describes the constraints applied to `int64` values
type Int64Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *int64 `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *int64 `protobuf:"varint,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *int64 `protobuf:"varint,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *int64 `protobuf:"varint,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *int64 `protobuf:"varint,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []int64 `protobuf:"varint,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []int64 `protobuf:"varint,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *Int64Rules) Reset() <span class="cov0" title="0">{
        *x = Int64Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Int64Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Int64Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Int64Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Int64Rules.ProtoReflect.Descriptor instead.
func (*Int64Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{4}
}</span>

func (x *Int64Rules) GetConst() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int64Rules) GetLt() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int64Rules) GetLte() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int64Rules) GetGt() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int64Rules) GetGte() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int64Rules) GetIn() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Int64Rules) GetNotIn() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Int64Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// UInt32Rules describes the constraints applied to `uint32` values
type UInt32Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *uint32 `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *uint32 `protobuf:"varint,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *uint32 `protobuf:"varint,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *uint32 `protobuf:"varint,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *uint32 `protobuf:"varint,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []uint32 `protobuf:"varint,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []uint32 `protobuf:"varint,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *UInt32Rules) Reset() <span class="cov0" title="0">{
        *x = UInt32Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UInt32Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UInt32Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UInt32Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UInt32Rules.ProtoReflect.Descriptor instead.
func (*UInt32Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{5}
}</span>

func (x *UInt32Rules) GetConst() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt32Rules) GetLt() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt32Rules) GetLte() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt32Rules) GetGt() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt32Rules) GetGte() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt32Rules) GetIn() []uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UInt32Rules) GetNotIn() []uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UInt32Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// UInt64Rules describes the constraints applied to `uint64` values
type UInt64Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *uint64 `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *uint64 `protobuf:"varint,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *uint64 `protobuf:"varint,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *uint64 `protobuf:"varint,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *uint64 `protobuf:"varint,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []uint64 `protobuf:"varint,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []uint64 `protobuf:"varint,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *UInt64Rules) Reset() <span class="cov0" title="0">{
        *x = UInt64Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UInt64Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UInt64Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UInt64Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UInt64Rules.ProtoReflect.Descriptor instead.
func (*UInt64Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{6}
}</span>

func (x *UInt64Rules) GetConst() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt64Rules) GetLt() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt64Rules) GetLte() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt64Rules) GetGt() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt64Rules) GetGte() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt64Rules) GetIn() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UInt64Rules) GetNotIn() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UInt64Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// SInt32Rules describes the constraints applied to `sint32` values
type SInt32Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *int32 `protobuf:"zigzag32,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *int32 `protobuf:"zigzag32,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *int32 `protobuf:"zigzag32,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *int32 `protobuf:"zigzag32,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *int32 `protobuf:"zigzag32,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []int32 `protobuf:"zigzag32,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []int32 `protobuf:"zigzag32,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *SInt32Rules) Reset() <span class="cov0" title="0">{
        *x = SInt32Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SInt32Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SInt32Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SInt32Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SInt32Rules.ProtoReflect.Descriptor instead.
func (*SInt32Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{7}
}</span>

func (x *SInt32Rules) GetConst() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt32Rules) GetLt() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt32Rules) GetLte() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt32Rules) GetGt() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt32Rules) GetGte() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt32Rules) GetIn() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SInt32Rules) GetNotIn() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SInt32Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// SInt64Rules describes the constraints applied to `sint64` values
type SInt64Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *int64 `protobuf:"zigzag64,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *int64 `protobuf:"zigzag64,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *int64 `protobuf:"zigzag64,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *int64 `protobuf:"zigzag64,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *int64 `protobuf:"zigzag64,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []int64 `protobuf:"zigzag64,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []int64 `protobuf:"zigzag64,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *SInt64Rules) Reset() <span class="cov0" title="0">{
        *x = SInt64Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SInt64Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SInt64Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SInt64Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SInt64Rules.ProtoReflect.Descriptor instead.
func (*SInt64Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{8}
}</span>

func (x *SInt64Rules) GetConst() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt64Rules) GetLt() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt64Rules) GetLte() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt64Rules) GetGt() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt64Rules) GetGte() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt64Rules) GetIn() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SInt64Rules) GetNotIn() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SInt64Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Fixed32Rules describes the constraints applied to `fixed32` values
type Fixed32Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *uint32 `protobuf:"fixed32,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *uint32 `protobuf:"fixed32,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *uint32 `protobuf:"fixed32,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *uint32 `protobuf:"fixed32,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *uint32 `protobuf:"fixed32,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []uint32 `protobuf:"fixed32,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []uint32 `protobuf:"fixed32,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *Fixed32Rules) Reset() <span class="cov0" title="0">{
        *x = Fixed32Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Fixed32Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Fixed32Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Fixed32Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Fixed32Rules.ProtoReflect.Descriptor instead.
func (*Fixed32Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{9}
}</span>

func (x *Fixed32Rules) GetConst() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed32Rules) GetLt() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed32Rules) GetLte() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed32Rules) GetGt() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed32Rules) GetGte() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed32Rules) GetIn() []uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Fixed32Rules) GetNotIn() []uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Fixed32Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Fixed64Rules describes the constraints applied to `fixed64` values
type Fixed64Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *uint64 `protobuf:"fixed64,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *uint64 `protobuf:"fixed64,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *uint64 `protobuf:"fixed64,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *uint64 `protobuf:"fixed64,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *uint64 `protobuf:"fixed64,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []uint64 `protobuf:"fixed64,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []uint64 `protobuf:"fixed64,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *Fixed64Rules) Reset() <span class="cov0" title="0">{
        *x = Fixed64Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Fixed64Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Fixed64Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Fixed64Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Fixed64Rules.ProtoReflect.Descriptor instead.
func (*Fixed64Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{10}
}</span>

func (x *Fixed64Rules) GetConst() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed64Rules) GetLt() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed64Rules) GetLte() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed64Rules) GetGt() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed64Rules) GetGte() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed64Rules) GetIn() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Fixed64Rules) GetNotIn() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Fixed64Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// SFixed32Rules describes the constraints applied to `sfixed32` values
type SFixed32Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *int32 `protobuf:"fixed32,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *int32 `protobuf:"fixed32,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *int32 `protobuf:"fixed32,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *int32 `protobuf:"fixed32,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *int32 `protobuf:"fixed32,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []int32 `protobuf:"fixed32,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []int32 `protobuf:"fixed32,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *SFixed32Rules) Reset() <span class="cov0" title="0">{
        *x = SFixed32Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[11]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SFixed32Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SFixed32Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SFixed32Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[11]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SFixed32Rules.ProtoReflect.Descriptor instead.
func (*SFixed32Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{11}
}</span>

func (x *SFixed32Rules) GetConst() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed32Rules) GetLt() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed32Rules) GetLte() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed32Rules) GetGt() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed32Rules) GetGte() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed32Rules) GetIn() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SFixed32Rules) GetNotIn() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SFixed32Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// SFixed64Rules describes the constraints applied to `sfixed64` values
type SFixed64Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *int64 `protobuf:"fixed64,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *int64 `protobuf:"fixed64,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *int64 `protobuf:"fixed64,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *int64 `protobuf:"fixed64,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *int64 `protobuf:"fixed64,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []int64 `protobuf:"fixed64,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []int64 `protobuf:"fixed64,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *SFixed64Rules) Reset() <span class="cov0" title="0">{
        *x = SFixed64Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[12]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SFixed64Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SFixed64Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SFixed64Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[12]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SFixed64Rules.ProtoReflect.Descriptor instead.
func (*SFixed64Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{12}
}</span>

func (x *SFixed64Rules) GetConst() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed64Rules) GetLt() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed64Rules) GetLte() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed64Rules) GetGt() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed64Rules) GetGte() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed64Rules) GetIn() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SFixed64Rules) GetNotIn() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SFixed64Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// BoolRules describes the constraints applied to `bool` values
type BoolRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *bool `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
}

func (x *BoolRules) Reset() <span class="cov0" title="0">{
        *x = BoolRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[13]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *BoolRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BoolRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BoolRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[13]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BoolRules.ProtoReflect.Descriptor instead.
func (*BoolRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{13}
}</span>

func (x *BoolRules) GetConst() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return false</span>
}

// StringRules describe the constraints applied to `string` values
type StringRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *string `protobuf:"bytes,1,opt,name=const" json:"const,omitempty"`
        // Len specifies that this field must be the specified number of
        // characters (Unicode code points). Note that the number of
        // characters may differ from the number of bytes in the string.
        Len *uint64 `protobuf:"varint,19,opt,name=len" json:"len,omitempty"`
        // MinLen specifies that this field must be the specified number of
        // characters (Unicode code points) at a minimum. Note that the number of
        // characters may differ from the number of bytes in the string.
        MinLen *uint64 `protobuf:"varint,2,opt,name=min_len,json=minLen" json:"min_len,omitempty"`
        // MaxLen specifies that this field must be the specified number of
        // characters (Unicode code points) at a maximum. Note that the number of
        // characters may differ from the number of bytes in the string.
        MaxLen *uint64 `protobuf:"varint,3,opt,name=max_len,json=maxLen" json:"max_len,omitempty"`
        // LenBytes specifies that this field must be the specified number of bytes
        // at a minimum
        LenBytes *uint64 `protobuf:"varint,20,opt,name=len_bytes,json=lenBytes" json:"len_bytes,omitempty"`
        // MinBytes specifies that this field must be the specified number of bytes
        // at a minimum
        MinBytes *uint64 `protobuf:"varint,4,opt,name=min_bytes,json=minBytes" json:"min_bytes,omitempty"`
        // MaxBytes specifies that this field must be the specified number of bytes
        // at a maximum
        MaxBytes *uint64 `protobuf:"varint,5,opt,name=max_bytes,json=maxBytes" json:"max_bytes,omitempty"`
        // Pattern specifes that this field must match against the specified
        // regular expression (RE2 syntax). The included expression should elide
        // any delimiters.
        Pattern *string `protobuf:"bytes,6,opt,name=pattern" json:"pattern,omitempty"`
        // Prefix specifies that this field must have the specified substring at
        // the beginning of the string.
        Prefix *string `protobuf:"bytes,7,opt,name=prefix" json:"prefix,omitempty"`
        // Suffix specifies that this field must have the specified substring at
        // the end of the string.
        Suffix *string `protobuf:"bytes,8,opt,name=suffix" json:"suffix,omitempty"`
        // Contains specifies that this field must have the specified substring
        // anywhere in the string.
        Contains *string `protobuf:"bytes,9,opt,name=contains" json:"contains,omitempty"`
        // NotContains specifies that this field cannot have the specified substring
        // anywhere in the string.
        NotContains *string `protobuf:"bytes,23,opt,name=not_contains,json=notContains" json:"not_contains,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []string `protobuf:"bytes,10,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []string `protobuf:"bytes,11,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // WellKnown rules provide advanced constraints against common string
        // patterns
        //
        // Types that are assignable to WellKnown:
        //        *StringRules_Email
        //        *StringRules_Hostname
        //        *StringRules_Ip
        //        *StringRules_Ipv4
        //        *StringRules_Ipv6
        //        *StringRules_Uri
        //        *StringRules_UriRef
        //        *StringRules_Address
        //        *StringRules_Uuid
        //        *StringRules_WellKnownRegex
        WellKnown isStringRules_WellKnown `protobuf_oneof:"well_known"`
        // This applies to regexes HTTP_HEADER_NAME and HTTP_HEADER_VALUE to enable
        // strict header validation.
        // By default, this is true, and HTTP header validations are RFC-compliant.
        // Setting to false will enable a looser validations that only disallows
        // \r\n\0 characters, which can be used to bypass header matching rules.
        Strict *bool `protobuf:"varint,25,opt,name=strict,def=1" json:"strict,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,26,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

// Default values for StringRules fields.
const (
        Default_StringRules_Strict = bool(true)
)

func (x *StringRules) Reset() <span class="cov0" title="0">{
        *x = StringRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[14]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *StringRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StringRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StringRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[14]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StringRules.ProtoReflect.Descriptor instead.
func (*StringRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{14}
}</span>

func (x *StringRules) GetConst() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StringRules) GetLen() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Len != nil </span><span class="cov0" title="0">{
                return *x.Len
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StringRules) GetMinLen() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MinLen != nil </span><span class="cov0" title="0">{
                return *x.MinLen
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StringRules) GetMaxLen() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MaxLen != nil </span><span class="cov0" title="0">{
                return *x.MaxLen
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StringRules) GetLenBytes() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.LenBytes != nil </span><span class="cov0" title="0">{
                return *x.LenBytes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StringRules) GetMinBytes() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MinBytes != nil </span><span class="cov0" title="0">{
                return *x.MinBytes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StringRules) GetMaxBytes() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MaxBytes != nil </span><span class="cov0" title="0">{
                return *x.MaxBytes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StringRules) GetPattern() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Pattern != nil </span><span class="cov0" title="0">{
                return *x.Pattern
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StringRules) GetPrefix() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Prefix != nil </span><span class="cov0" title="0">{
                return *x.Prefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StringRules) GetSuffix() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Suffix != nil </span><span class="cov0" title="0">{
                return *x.Suffix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StringRules) GetContains() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Contains != nil </span><span class="cov0" title="0">{
                return *x.Contains
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StringRules) GetNotContains() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.NotContains != nil </span><span class="cov0" title="0">{
                return *x.NotContains
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StringRules) GetIn() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StringRules) GetNotIn() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *StringRules) GetWellKnown() isStringRules_WellKnown <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WellKnown
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StringRules) GetEmail() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_Email); ok </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetHostname() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_Hostname); ok </span><span class="cov0" title="0">{
                return x.Hostname
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetIp() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_Ip); ok </span><span class="cov0" title="0">{
                return x.Ip
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetIpv4() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_Ipv4); ok </span><span class="cov0" title="0">{
                return x.Ipv4
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetIpv6() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_Ipv6); ok </span><span class="cov0" title="0">{
                return x.Ipv6
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetUri() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_Uri); ok </span><span class="cov0" title="0">{
                return x.Uri
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetUriRef() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_UriRef); ok </span><span class="cov0" title="0">{
                return x.UriRef
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetAddress() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_Address); ok </span><span class="cov0" title="0">{
                return x.Address
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetUuid() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_Uuid); ok </span><span class="cov0" title="0">{
                return x.Uuid
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetWellKnownRegex() KnownRegex <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_WellKnownRegex); ok </span><span class="cov0" title="0">{
                return x.WellKnownRegex
        }</span>
        <span class="cov0" title="0">return KnownRegex_UNKNOWN</span>
}

func (x *StringRules) GetStrict() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Strict != nil </span><span class="cov0" title="0">{
                return *x.Strict
        }</span>
        <span class="cov0" title="0">return Default_StringRules_Strict</span>
}

func (x *StringRules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

type isStringRules_WellKnown interface {
        isStringRules_WellKnown()
}

type StringRules_Email struct {
        // Email specifies that the field must be a valid email address as
        // defined by RFC 5322
        Email bool `protobuf:"varint,12,opt,name=email,oneof"`
}

type StringRules_Hostname struct {
        // Hostname specifies that the field must be a valid hostname as
        // defined by RFC 1034. This constraint does not support
        // internationalized domain names (IDNs).
        Hostname bool `protobuf:"varint,13,opt,name=hostname,oneof"`
}

type StringRules_Ip struct {
        // Ip specifies that the field must be a valid IP (v4 or v6) address.
        // Valid IPv6 addresses should not include surrounding square brackets.
        Ip bool `protobuf:"varint,14,opt,name=ip,oneof"`
}

type StringRules_Ipv4 struct {
        // Ipv4 specifies that the field must be a valid IPv4 address.
        Ipv4 bool `protobuf:"varint,15,opt,name=ipv4,oneof"`
}

type StringRules_Ipv6 struct {
        // Ipv6 specifies that the field must be a valid IPv6 address. Valid
        // IPv6 addresses should not include surrounding square brackets.
        Ipv6 bool `protobuf:"varint,16,opt,name=ipv6,oneof"`
}

type StringRules_Uri struct {
        // Uri specifies that the field must be a valid, absolute URI as defined
        // by RFC 3986
        Uri bool `protobuf:"varint,17,opt,name=uri,oneof"`
}

type StringRules_UriRef struct {
        // UriRef specifies that the field must be a valid URI as defined by RFC
        // 3986 and may be relative or absolute.
        UriRef bool `protobuf:"varint,18,opt,name=uri_ref,json=uriRef,oneof"`
}

type StringRules_Address struct {
        // Address specifies that the field must be either a valid hostname as
        // defined by RFC 1034 (which does not support internationalized domain
        // names or IDNs), or it can be a valid IP (v4 or v6).
        Address bool `protobuf:"varint,21,opt,name=address,oneof"`
}

type StringRules_Uuid struct {
        // Uuid specifies that the field must be a valid UUID as defined by
        // RFC 4122
        Uuid bool `protobuf:"varint,22,opt,name=uuid,oneof"`
}

type StringRules_WellKnownRegex struct {
        // WellKnownRegex specifies a common well known pattern defined as a regex.
        WellKnownRegex KnownRegex `protobuf:"varint,24,opt,name=well_known_regex,json=wellKnownRegex,enum=validate.KnownRegex,oneof"`
}

func (*StringRules_Email) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_Hostname) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_Ip) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_Ipv4) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_Ipv6) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_Uri) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_UriRef) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_Address) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_Uuid) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_WellKnownRegex) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

// BytesRules describe the constraints applied to `bytes` values
type BytesRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const []byte `protobuf:"bytes,1,opt,name=const" json:"const,omitempty"`
        // Len specifies that this field must be the specified number of bytes
        Len *uint64 `protobuf:"varint,13,opt,name=len" json:"len,omitempty"`
        // MinLen specifies that this field must be the specified number of bytes
        // at a minimum
        MinLen *uint64 `protobuf:"varint,2,opt,name=min_len,json=minLen" json:"min_len,omitempty"`
        // MaxLen specifies that this field must be the specified number of bytes
        // at a maximum
        MaxLen *uint64 `protobuf:"varint,3,opt,name=max_len,json=maxLen" json:"max_len,omitempty"`
        // Pattern specifes that this field must match against the specified
        // regular expression (RE2 syntax). The included expression should elide
        // any delimiters.
        Pattern *string `protobuf:"bytes,4,opt,name=pattern" json:"pattern,omitempty"`
        // Prefix specifies that this field must have the specified bytes at the
        // beginning of the string.
        Prefix []byte `protobuf:"bytes,5,opt,name=prefix" json:"prefix,omitempty"`
        // Suffix specifies that this field must have the specified bytes at the
        // end of the string.
        Suffix []byte `protobuf:"bytes,6,opt,name=suffix" json:"suffix,omitempty"`
        // Contains specifies that this field must have the specified bytes
        // anywhere in the string.
        Contains []byte `protobuf:"bytes,7,opt,name=contains" json:"contains,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In [][]byte `protobuf:"bytes,8,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn [][]byte `protobuf:"bytes,9,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // WellKnown rules provide advanced constraints against common byte
        // patterns
        //
        // Types that are assignable to WellKnown:
        //        *BytesRules_Ip
        //        *BytesRules_Ipv4
        //        *BytesRules_Ipv6
        WellKnown isBytesRules_WellKnown `protobuf_oneof:"well_known"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,14,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *BytesRules) Reset() <span class="cov0" title="0">{
        *x = BytesRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[15]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *BytesRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BytesRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BytesRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[15]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BytesRules.ProtoReflect.Descriptor instead.
func (*BytesRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{15}
}</span>

func (x *BytesRules) GetConst() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Const
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BytesRules) GetLen() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Len != nil </span><span class="cov0" title="0">{
                return *x.Len
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *BytesRules) GetMinLen() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MinLen != nil </span><span class="cov0" title="0">{
                return *x.MinLen
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *BytesRules) GetMaxLen() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MaxLen != nil </span><span class="cov0" title="0">{
                return *x.MaxLen
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *BytesRules) GetPattern() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Pattern != nil </span><span class="cov0" title="0">{
                return *x.Pattern
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *BytesRules) GetPrefix() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Prefix
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BytesRules) GetSuffix() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Suffix
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BytesRules) GetContains() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Contains
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BytesRules) GetIn() [][]byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BytesRules) GetNotIn() [][]byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *BytesRules) GetWellKnown() isBytesRules_WellKnown <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WellKnown
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BytesRules) GetIp() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*BytesRules_Ip); ok </span><span class="cov0" title="0">{
                return x.Ip
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *BytesRules) GetIpv4() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*BytesRules_Ipv4); ok </span><span class="cov0" title="0">{
                return x.Ipv4
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *BytesRules) GetIpv6() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*BytesRules_Ipv6); ok </span><span class="cov0" title="0">{
                return x.Ipv6
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *BytesRules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

type isBytesRules_WellKnown interface {
        isBytesRules_WellKnown()
}

type BytesRules_Ip struct {
        // Ip specifies that the field must be a valid IP (v4 or v6) address in
        // byte format
        Ip bool `protobuf:"varint,10,opt,name=ip,oneof"`
}

type BytesRules_Ipv4 struct {
        // Ipv4 specifies that the field must be a valid IPv4 address in byte
        // format
        Ipv4 bool `protobuf:"varint,11,opt,name=ipv4,oneof"`
}

type BytesRules_Ipv6 struct {
        // Ipv6 specifies that the field must be a valid IPv6 address in byte
        // format
        Ipv6 bool `protobuf:"varint,12,opt,name=ipv6,oneof"`
}

func (*BytesRules_Ip) isBytesRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*BytesRules_Ipv4) isBytesRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*BytesRules_Ipv6) isBytesRules_WellKnown() {<span class="cov0" title="0">}</span>

// EnumRules describe the constraints applied to enum values
type EnumRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *int32 `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
        // DefinedOnly specifies that this field must be only one of the defined
        // values for this enum, failing on any undefined value.
        DefinedOnly *bool `protobuf:"varint,2,opt,name=defined_only,json=definedOnly" json:"defined_only,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []int32 `protobuf:"varint,3,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []int32 `protobuf:"varint,4,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
}

func (x *EnumRules) Reset() <span class="cov0" title="0">{
        *x = EnumRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[16]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *EnumRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EnumRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EnumRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[16]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use EnumRules.ProtoReflect.Descriptor instead.
func (*EnumRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{16}
}</span>

func (x *EnumRules) GetConst() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *EnumRules) GetDefinedOnly() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.DefinedOnly != nil </span><span class="cov0" title="0">{
                return *x.DefinedOnly
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *EnumRules) GetIn() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *EnumRules) GetNotIn() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// MessageRules describe the constraints applied to embedded message values.
// For message-type fields, validation is performed recursively.
type MessageRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Skip specifies that the validation rules of this field should not be
        // evaluated
        Skip *bool `protobuf:"varint,1,opt,name=skip" json:"skip,omitempty"`
        // Required specifies that this field must be set
        Required *bool `protobuf:"varint,2,opt,name=required" json:"required,omitempty"`
}

func (x *MessageRules) Reset() <span class="cov0" title="0">{
        *x = MessageRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[17]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *MessageRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MessageRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MessageRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[17]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MessageRules.ProtoReflect.Descriptor instead.
func (*MessageRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{17}
}</span>

func (x *MessageRules) GetSkip() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Skip != nil </span><span class="cov0" title="0">{
                return *x.Skip
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *MessageRules) GetRequired() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Required != nil </span><span class="cov0" title="0">{
                return *x.Required
        }</span>
        <span class="cov0" title="0">return false</span>
}

// RepeatedRules describe the constraints applied to `repeated` values
type RepeatedRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // MinItems specifies that this field must have the specified number of
        // items at a minimum
        MinItems *uint64 `protobuf:"varint,1,opt,name=min_items,json=minItems" json:"min_items,omitempty"`
        // MaxItems specifies that this field must have the specified number of
        // items at a maximum
        MaxItems *uint64 `protobuf:"varint,2,opt,name=max_items,json=maxItems" json:"max_items,omitempty"`
        // Unique specifies that all elements in this field must be unique. This
        // contraint is only applicable to scalar and enum types (messages are not
        // supported).
        Unique *bool `protobuf:"varint,3,opt,name=unique" json:"unique,omitempty"`
        // Items specifies the contraints to be applied to each item in the field.
        // Repeated message fields will still execute validation against each item
        // unless skip is specified here.
        Items *FieldRules `protobuf:"bytes,4,opt,name=items" json:"items,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,5,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *RepeatedRules) Reset() <span class="cov0" title="0">{
        *x = RepeatedRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[18]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RepeatedRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RepeatedRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RepeatedRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[18]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RepeatedRules.ProtoReflect.Descriptor instead.
func (*RepeatedRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{18}
}</span>

func (x *RepeatedRules) GetMinItems() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MinItems != nil </span><span class="cov0" title="0">{
                return *x.MinItems
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *RepeatedRules) GetMaxItems() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MaxItems != nil </span><span class="cov0" title="0">{
                return *x.MaxItems
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *RepeatedRules) GetUnique() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Unique != nil </span><span class="cov0" title="0">{
                return *x.Unique
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *RepeatedRules) GetItems() *FieldRules <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedRules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// MapRules describe the constraints applied to `map` values
type MapRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // MinPairs specifies that this field must have the specified number of
        // KVs at a minimum
        MinPairs *uint64 `protobuf:"varint,1,opt,name=min_pairs,json=minPairs" json:"min_pairs,omitempty"`
        // MaxPairs specifies that this field must have the specified number of
        // KVs at a maximum
        MaxPairs *uint64 `protobuf:"varint,2,opt,name=max_pairs,json=maxPairs" json:"max_pairs,omitempty"`
        // NoSparse specifies values in this field cannot be unset. This only
        // applies to map's with message value types.
        NoSparse *bool `protobuf:"varint,3,opt,name=no_sparse,json=noSparse" json:"no_sparse,omitempty"`
        // Keys specifies the constraints to be applied to each key in the field.
        Keys *FieldRules `protobuf:"bytes,4,opt,name=keys" json:"keys,omitempty"`
        // Values specifies the constraints to be applied to the value of each key
        // in the field. Message values will still have their validations evaluated
        // unless skip is specified here.
        Values *FieldRules `protobuf:"bytes,5,opt,name=values" json:"values,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,6,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *MapRules) Reset() <span class="cov0" title="0">{
        *x = MapRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[19]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *MapRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MapRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MapRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[19]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MapRules.ProtoReflect.Descriptor instead.
func (*MapRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{19}
}</span>

func (x *MapRules) GetMinPairs() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MinPairs != nil </span><span class="cov0" title="0">{
                return *x.MinPairs
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MapRules) GetMaxPairs() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MaxPairs != nil </span><span class="cov0" title="0">{
                return *x.MaxPairs
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MapRules) GetNoSparse() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.NoSparse != nil </span><span class="cov0" title="0">{
                return *x.NoSparse
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *MapRules) GetKeys() *FieldRules <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Keys
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *MapRules) GetValues() *FieldRules <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Values
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *MapRules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// AnyRules describe constraints applied exclusively to the
// `google.protobuf.Any` well-known type
type AnyRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Required specifies that this field must be set
        Required *bool `protobuf:"varint,1,opt,name=required" json:"required,omitempty"`
        // In specifies that this field's `type_url` must be equal to one of the
        // specified values.
        In []string `protobuf:"bytes,2,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field's `type_url` must not be equal to any of
        // the specified values.
        NotIn []string `protobuf:"bytes,3,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
}

func (x *AnyRules) Reset() <span class="cov0" title="0">{
        *x = AnyRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[20]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *AnyRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AnyRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AnyRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[20]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AnyRules.ProtoReflect.Descriptor instead.
func (*AnyRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{20}
}</span>

func (x *AnyRules) GetRequired() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Required != nil </span><span class="cov0" title="0">{
                return *x.Required
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *AnyRules) GetIn() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *AnyRules) GetNotIn() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DurationRules describe the constraints applied exclusively to the
// `google.protobuf.Duration` well-known type
type DurationRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Required specifies that this field must be set
        Required *bool `protobuf:"varint,1,opt,name=required" json:"required,omitempty"`
        // Const specifies that this field must be exactly the specified value
        Const *durationpb.Duration `protobuf:"bytes,2,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *durationpb.Duration `protobuf:"bytes,3,opt,name=lt" json:"lt,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // inclusive
        Lte *durationpb.Duration `protobuf:"bytes,4,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive
        Gt *durationpb.Duration `protobuf:"bytes,5,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than the specified value,
        // inclusive
        Gte *durationpb.Duration `protobuf:"bytes,6,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []*durationpb.Duration `protobuf:"bytes,7,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []*durationpb.Duration `protobuf:"bytes,8,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
}

func (x *DurationRules) Reset() <span class="cov0" title="0">{
        *x = DurationRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[21]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DurationRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DurationRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DurationRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[21]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DurationRules.ProtoReflect.Descriptor instead.
func (*DurationRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{21}
}</span>

func (x *DurationRules) GetRequired() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Required != nil </span><span class="cov0" title="0">{
                return *x.Required
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *DurationRules) GetConst() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Const
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DurationRules) GetLt() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Lt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DurationRules) GetLte() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Lte
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DurationRules) GetGt() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Gt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DurationRules) GetGte() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Gte
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DurationRules) GetIn() []*durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DurationRules) GetNotIn() []*durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// TimestampRules describe the constraints applied exclusively to the
// `google.protobuf.Timestamp` well-known type
type TimestampRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Required specifies that this field must be set
        Required *bool `protobuf:"varint,1,opt,name=required" json:"required,omitempty"`
        // Const specifies that this field must be exactly the specified value
        Const *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than the specified value,
        // inclusive
        Lte *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive
        Gt *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than the specified value,
        // inclusive
        Gte *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=gte" json:"gte,omitempty"`
        // LtNow specifies that this must be less than the current time. LtNow
        // can only be used with the Within rule.
        LtNow *bool `protobuf:"varint,7,opt,name=lt_now,json=ltNow" json:"lt_now,omitempty"`
        // GtNow specifies that this must be greater than the current time. GtNow
        // can only be used with the Within rule.
        GtNow *bool `protobuf:"varint,8,opt,name=gt_now,json=gtNow" json:"gt_now,omitempty"`
        // Within specifies that this field must be within this duration of the
        // current time. This constraint can be used alone or with the LtNow and
        // GtNow rules.
        Within *durationpb.Duration `protobuf:"bytes,9,opt,name=within" json:"within,omitempty"`
}

func (x *TimestampRules) Reset() <span class="cov0" title="0">{
        *x = TimestampRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[22]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *TimestampRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TimestampRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TimestampRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[22]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TimestampRules.ProtoReflect.Descriptor instead.
func (*TimestampRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{22}
}</span>

func (x *TimestampRules) GetRequired() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Required != nil </span><span class="cov0" title="0">{
                return *x.Required
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TimestampRules) GetConst() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Const
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TimestampRules) GetLt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Lt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TimestampRules) GetLte() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Lte
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TimestampRules) GetGt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Gt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TimestampRules) GetGte() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Gte
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TimestampRules) GetLtNow() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.LtNow != nil </span><span class="cov0" title="0">{
                return *x.LtNow
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TimestampRules) GetGtNow() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.GtNow != nil </span><span class="cov0" title="0">{
                return *x.GtNow
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TimestampRules) GetWithin() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Within
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var file_validate_validate_proto_extTypes = []protoimpl.ExtensionInfo{
        {
                ExtendedType:  (*descriptorpb.MessageOptions)(nil),
                ExtensionType: (*bool)(nil),
                Field:         1071,
                Name:          "validate.disabled",
                Tag:           "varint,1071,opt,name=disabled",
                Filename:      "validate/validate.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MessageOptions)(nil),
                ExtensionType: (*bool)(nil),
                Field:         1072,
                Name:          "validate.ignored",
                Tag:           "varint,1072,opt,name=ignored",
                Filename:      "validate/validate.proto",
        },
        {
                ExtendedType:  (*descriptorpb.OneofOptions)(nil),
                ExtensionType: (*bool)(nil),
                Field:         1071,
                Name:          "validate.required",
                Tag:           "varint,1071,opt,name=required",
                Filename:      "validate/validate.proto",
        },
        {
                ExtendedType:  (*descriptorpb.FieldOptions)(nil),
                ExtensionType: (*FieldRules)(nil),
                Field:         1071,
                Name:          "validate.rules",
                Tag:           "bytes,1071,opt,name=rules",
                Filename:      "validate/validate.proto",
        },
}

// Extension fields to descriptorpb.MessageOptions.
var (
        // Disabled nullifies any validation rules for this message, including any
        // message fields associated with it that do support validation.
        //
        // optional bool disabled = 1071;
        E_Disabled = &amp;file_validate_validate_proto_extTypes[0]
        // Ignore skips generation of validation methods for this message.
        //
        // optional bool ignored = 1072;
        E_Ignored = &amp;file_validate_validate_proto_extTypes[1]
)

// Extension fields to descriptorpb.OneofOptions.
var (
        // Required ensures that exactly one the field options in a oneof is set;
        // validation fails if no fields in the oneof are set.
        //
        // optional bool required = 1071;
        E_Required = &amp;file_validate_validate_proto_extTypes[2]
)

// Extension fields to descriptorpb.FieldOptions.
var (
        // Rules specify the validations to be performed on this field. By default,
        // no validation is performed against a field.
        //
        // optional validate.FieldRules rules = 1071;
        E_Rules = &amp;file_validate_validate_proto_extTypes[3]
)

var File_validate_validate_proto protoreflect.FileDescriptor

var file_validate_validate_proto_rawDesc = []byte{
        0x0a, 0x17, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2f, 0x76, 0x61, 0x6c, 0x69, 0x64,
        0x61, 0x74, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x08, 0x76, 0x61, 0x6c, 0x69, 0x64,
        0x61, 0x74, 0x65, 0x1a, 0x20, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xc8, 0x08, 0x0a, 0x0a, 0x46, 0x69, 0x65, 0x6c, 0x64,
        0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x30, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
        0x18, 0x11, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74,
        0x65, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x52, 0x07,
        0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x2c, 0x0a, 0x05, 0x66, 0x6c, 0x6f, 0x61, 0x74,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74,
        0x65, 0x2e, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x05,
        0x66, 0x6c, 0x6f, 0x61, 0x74, 0x12, 0x2f, 0x0a, 0x06, 0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65,
        0x2e, 0x44, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x06,
        0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x12, 0x2c, 0x0a, 0x05, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x18,
        0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65,
        0x2e, 0x49, 0x6e, 0x74, 0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x05, 0x69,
        0x6e, 0x74, 0x33, 0x32, 0x12, 0x2c, 0x0a, 0x05, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x18, 0x04, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x49,
        0x6e, 0x74, 0x36, 0x34, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x05, 0x69, 0x6e, 0x74,
        0x36, 0x34, 0x12, 0x2f, 0x0a, 0x06, 0x75, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x18, 0x05, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x15, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x55, 0x49,
        0x6e, 0x74, 0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x06, 0x75, 0x69, 0x6e,
        0x74, 0x33, 0x32, 0x12, 0x2f, 0x0a, 0x06, 0x75, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x18, 0x06, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x55,
        0x49, 0x6e, 0x74, 0x36, 0x34, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x06, 0x75, 0x69,
        0x6e, 0x74, 0x36, 0x34, 0x12, 0x2f, 0x0a, 0x06, 0x73, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x18, 0x07,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e,
        0x53, 0x49, 0x6e, 0x74, 0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x06, 0x73,
        0x69, 0x6e, 0x74, 0x33, 0x32, 0x12, 0x2f, 0x0a, 0x06, 0x73, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x18,
        0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65,
        0x2e, 0x53, 0x49, 0x6e, 0x74, 0x36, 0x34, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x06,
        0x73, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x12, 0x32, 0x0a, 0x07, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33,
        0x32, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61,
        0x74, 0x65, 0x2e, 0x46, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48,
        0x00, 0x52, 0x07, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x12, 0x32, 0x0a, 0x07, 0x66, 0x69,
        0x78, 0x65, 0x64, 0x36, 0x34, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x76, 0x61,
        0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x46, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x52, 0x75,
        0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x07, 0x66, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x12, 0x35,
        0x0a, 0x08, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x17, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x53, 0x46, 0x69, 0x78,
        0x65, 0x64, 0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x08, 0x73, 0x66, 0x69,
        0x78, 0x65, 0x64, 0x33, 0x32, 0x12, 0x35, 0x0a, 0x08, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x36,
        0x34, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61,
        0x74, 0x65, 0x2e, 0x53, 0x46, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x52, 0x75, 0x6c, 0x65, 0x73,
        0x48, 0x00, 0x52, 0x08, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x12, 0x29, 0x0a, 0x04,
        0x62, 0x6f, 0x6f, 0x6c, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x76, 0x61, 0x6c,
        0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x42, 0x6f, 0x6f, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48,
        0x00, 0x52, 0x04, 0x62, 0x6f, 0x6f, 0x6c, 0x12, 0x2f, 0x0a, 0x06, 0x73, 0x74, 0x72, 0x69, 0x6e,
        0x67, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61,
        0x74, 0x65, 0x2e, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00,
        0x52, 0x06, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x12, 0x2c, 0x0a, 0x05, 0x62, 0x79, 0x74, 0x65,
        0x73, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61,
        0x74, 0x65, 0x2e, 0x42, 0x79, 0x74, 0x65, 0x73, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52,
        0x05, 0x62, 0x79, 0x74, 0x65, 0x73, 0x12, 0x29, 0x0a, 0x04, 0x65, 0x6e, 0x75, 0x6d, 0x18, 0x10,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e,
        0x45, 0x6e, 0x75, 0x6d, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x04, 0x65, 0x6e, 0x75,
        0x6d, 0x12, 0x35, 0x0a, 0x08, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 0x18, 0x12, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x52,
        0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x08,
        0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 0x12, 0x26, 0x0a, 0x03, 0x6d, 0x61, 0x70, 0x18,
        0x13, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65,
        0x2e, 0x4d, 0x61, 0x70, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x03, 0x6d, 0x61, 0x70,
        0x12, 0x26, 0x0a, 0x03, 0x61, 0x6e, 0x79, 0x18, 0x14, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e,
        0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x41, 0x6e, 0x79, 0x52, 0x75, 0x6c, 0x65,
        0x73, 0x48, 0x00, 0x52, 0x03, 0x61, 0x6e, 0x79, 0x12, 0x35, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x18, 0x15, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x76, 0x61, 0x6c,
        0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x75,
        0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12,
        0x38, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x16, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x18, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x54, 0x69,
        0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x09,
        0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x06, 0x0a, 0x04, 0x74, 0x79, 0x70,
        0x65, 0x22, 0xb0, 0x01, 0x0a, 0x0a, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x52, 0x75, 0x6c, 0x65, 0x73,
        0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x02, 0x52,
        0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x02, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74, 0x65, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x02, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x04,
        0x20, 0x01, 0x28, 0x02, 0x52, 0x02, 0x67, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18,
        0x05, 0x20, 0x01, 0x28, 0x02, 0x52, 0x03, 0x67, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e,
        0x18, 0x06, 0x20, 0x03, 0x28, 0x02, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f,
        0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x02, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49,
        0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74,
        0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45,
        0x6d, 0x70, 0x74, 0x79, 0x22, 0xb1, 0x01, 0x0a, 0x0b, 0x44, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x52,
        0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x01, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74,
        0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x01, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02,
        0x67, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x52, 0x02, 0x67, 0x74, 0x12, 0x10, 0x0a, 0x03,
        0x67, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x01, 0x52, 0x03, 0x67, 0x74, 0x65, 0x12, 0x0e,
        0x0a, 0x02, 0x69, 0x6e, 0x18, 0x06, 0x20, 0x03, 0x28, 0x01, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15,
        0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x01, 0x52, 0x05,
        0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f,
        0x65, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e,
        0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xb0, 0x01, 0x0a, 0x0a, 0x49, 0x6e, 0x74,
        0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a,
        0x02, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a,
        0x03, 0x6c, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12,
        0x0e, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x67, 0x74, 0x12,
        0x10, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x67, 0x74,
        0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18, 0x06, 0x20, 0x03, 0x28, 0x05, 0x52, 0x02, 0x69,
        0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28,
        0x05, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f,
        0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b,
        0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xb0, 0x01, 0x0a, 0x0a,
        0x49, 0x6e, 0x74, 0x36, 0x34, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f,
        0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74,
        0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x6c, 0x74,
        0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x03, 0x6c,
        0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02,
        0x67, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52,
        0x03, 0x67, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18, 0x06, 0x20, 0x03, 0x28, 0x03,
        0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07,
        0x20, 0x03, 0x28, 0x03, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69,
        0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28,
        0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xb1,
        0x01, 0x0a, 0x0b, 0x55, 0x49, 0x6e, 0x74, 0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x14,
        0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x63,
        0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
        0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x0d, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x04, 0x20, 0x01,
        0x28, 0x0d, 0x52, 0x02, 0x67, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x05, 0x20,
        0x01, 0x28, 0x0d, 0x52, 0x03, 0x67, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18, 0x06,
        0x20, 0x03, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f,
        0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0d, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12,
        0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x18,
        0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70,
        0x74, 0x79, 0x22, 0xb1, 0x01, 0x0a, 0x0b, 0x55, 0x49, 0x6e, 0x74, 0x36, 0x34, 0x52, 0x75, 0x6c,
        0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x04, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x04, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74, 0x65, 0x18,
        0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x67, 0x74,
        0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x02, 0x67, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x67, 0x74,
        0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x52, 0x03, 0x67, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02,
        0x69, 0x6e, 0x18, 0x06, 0x20, 0x03, 0x28, 0x04, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06,
        0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x04, 0x52, 0x05, 0x6e, 0x6f,
        0x74, 0x49, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d,
        0x70, 0x74, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72,
        0x65, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xb1, 0x01, 0x0a, 0x0b, 0x53, 0x49, 0x6e, 0x74, 0x33,
        0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x11, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02,
        0x6c, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x11, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03,
        0x6c, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x11, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x0e,
        0x0a, 0x02, 0x67, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x11, 0x52, 0x02, 0x67, 0x74, 0x12, 0x10,
        0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x11, 0x52, 0x03, 0x67, 0x74, 0x65,
        0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18, 0x06, 0x20, 0x03, 0x28, 0x11, 0x52, 0x02, 0x69, 0x6e,
        0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x11,
        0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72,
        0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69,
        0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xb1, 0x01, 0x0a, 0x0b, 0x53,
        0x49, 0x6e, 0x74, 0x36, 0x34, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f,
        0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x12, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74,
        0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x12, 0x52, 0x02, 0x6c, 0x74,
        0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x12, 0x52, 0x03, 0x6c,
        0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x12, 0x52, 0x02,
        0x67, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x12, 0x52,
        0x03, 0x67, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18, 0x06, 0x20, 0x03, 0x28, 0x12,
        0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07,
        0x20, 0x03, 0x28, 0x12, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69,
        0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28,
        0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xb2,
        0x01, 0x0a, 0x0c, 0x46, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12,
        0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x07, 0x52, 0x05,
        0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x07, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x07, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x04, 0x20,
        0x01, 0x28, 0x07, 0x52, 0x02, 0x67, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x05,
        0x20, 0x01, 0x28, 0x07, 0x52, 0x03, 0x67, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18,
        0x06, 0x20, 0x03, 0x28, 0x07, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74,
        0x5f, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x07, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e,
        0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79,
        0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d,
        0x70, 0x74, 0x79, 0x22, 0xb2, 0x01, 0x0a, 0x0c, 0x46, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x52,
        0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x06, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74,
        0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x06, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02,
        0x67, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x06, 0x52, 0x02, 0x67, 0x74, 0x12, 0x10, 0x0a, 0x03,
        0x67, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x06, 0x52, 0x03, 0x67, 0x74, 0x65, 0x12, 0x0e,
        0x0a, 0x02, 0x69, 0x6e, 0x18, 0x06, 0x20, 0x03, 0x28, 0x06, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15,
        0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x06, 0x52, 0x05,
        0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f,
        0x65, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e,
        0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xb3, 0x01, 0x0a, 0x0d, 0x53, 0x46, 0x69,
        0x78, 0x65, 0x64, 0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f,
        0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0f, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74,
        0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0f, 0x52, 0x02, 0x6c, 0x74,
        0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0f, 0x52, 0x03, 0x6c,
        0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0f, 0x52, 0x02,
        0x67, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0f, 0x52,
        0x03, 0x67, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0f,
        0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07,
        0x20, 0x03, 0x28, 0x0f, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69,
        0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28,
        0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xb3,
        0x01, 0x0a, 0x0d, 0x53, 0x46, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x52, 0x75, 0x6c, 0x65, 0x73,
        0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x10, 0x52,
        0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x10, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74, 0x65, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x10, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x04,
        0x20, 0x01, 0x28, 0x10, 0x52, 0x02, 0x67, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18,
        0x05, 0x20, 0x01, 0x28, 0x10, 0x52, 0x03, 0x67, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e,
        0x18, 0x06, 0x20, 0x03, 0x28, 0x10, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f,
        0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x10, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49,
        0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74,
        0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45,
        0x6d, 0x70, 0x74, 0x79, 0x22, 0x21, 0x0a, 0x09, 0x42, 0x6f, 0x6f, 0x6c, 0x52, 0x75, 0x6c, 0x65,
        0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08,
        0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x22, 0xd4, 0x05, 0x0a, 0x0b, 0x53, 0x74, 0x72, 0x69,
        0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x10, 0x0a,
        0x03, 0x6c, 0x65, 0x6e, 0x18, 0x13, 0x20, 0x01, 0x28, 0x04, 0x52, 0x03, 0x6c, 0x65, 0x6e, 0x12,
        0x17, 0x0a, 0x07, 0x6d, 0x69, 0x6e, 0x5f, 0x6c, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04,
        0x52, 0x06, 0x6d, 0x69, 0x6e, 0x4c, 0x65, 0x6e, 0x12, 0x17, 0x0a, 0x07, 0x6d, 0x61, 0x78, 0x5f,
        0x6c, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x6d, 0x61, 0x78, 0x4c, 0x65,
        0x6e, 0x12, 0x1b, 0x0a, 0x09, 0x6c, 0x65, 0x6e, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x14,
        0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x6c, 0x65, 0x6e, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x1b,
        0x0a, 0x09, 0x6d, 0x69, 0x6e, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28,
        0x04, 0x52, 0x08, 0x6d, 0x69, 0x6e, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x6d,
        0x61, 0x78, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08,
        0x6d, 0x61, 0x78, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x74, 0x74,
        0x65, 0x72, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65,
        0x72, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x07, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x75,
        0x66, 0x66, 0x69, 0x78, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x75, 0x66, 0x66,
        0x69, 0x78, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x09,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x21,
        0x0a, 0x0c, 0x6e, 0x6f, 0x74, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x17,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6e, 0x6f, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e,
        0x73, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x09, 0x52, 0x02, 0x69,
        0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x0b, 0x20, 0x03, 0x28,
        0x09, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12, 0x16, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69,
        0x6c, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c,
        0x12, 0x1c, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x0d, 0x20, 0x01,
        0x28, 0x08, 0x48, 0x00, 0x52, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x10,
        0x0a, 0x02, 0x69, 0x70, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x02, 0x69, 0x70,
        0x12, 0x14, 0x0a, 0x04, 0x69, 0x70, 0x76, 0x34, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00,
        0x52, 0x04, 0x69, 0x70, 0x76, 0x34, 0x12, 0x14, 0x0a, 0x04, 0x69, 0x70, 0x76, 0x36, 0x18, 0x10,
        0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x04, 0x69, 0x70, 0x76, 0x36, 0x12, 0x12, 0x0a, 0x03,
        0x75, 0x72, 0x69, 0x18, 0x11, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x03, 0x75, 0x72, 0x69,
        0x12, 0x19, 0x0a, 0x07, 0x75, 0x72, 0x69, 0x5f, 0x72, 0x65, 0x66, 0x18, 0x12, 0x20, 0x01, 0x28,
        0x08, 0x48, 0x00, 0x52, 0x06, 0x75, 0x72, 0x69, 0x52, 0x65, 0x66, 0x12, 0x1a, 0x0a, 0x07, 0x61,
        0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x15, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x07,
        0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x14, 0x0a, 0x04, 0x75, 0x75, 0x69, 0x64, 0x18,
        0x16, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x04, 0x75, 0x75, 0x69, 0x64, 0x12, 0x40, 0x0a,
        0x10, 0x77, 0x65, 0x6c, 0x6c, 0x5f, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x5f, 0x72, 0x65, 0x67, 0x65,
        0x78, 0x18, 0x18, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61,
        0x74, 0x65, 0x2e, 0x4b, 0x6e, 0x6f, 0x77, 0x6e, 0x52, 0x65, 0x67, 0x65, 0x78, 0x48, 0x00, 0x52,
        0x0e, 0x77, 0x65, 0x6c, 0x6c, 0x4b, 0x6e, 0x6f, 0x77, 0x6e, 0x52, 0x65, 0x67, 0x65, 0x78, 0x12,
        0x1c, 0x0a, 0x06, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x18, 0x19, 0x20, 0x01, 0x28, 0x08, 0x3a,
        0x04, 0x74, 0x72, 0x75, 0x65, 0x52, 0x06, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x12, 0x21, 0x0a,
        0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x1a, 0x20,
        0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x79,
        0x42, 0x0c, 0x0a, 0x0a, 0x77, 0x65, 0x6c, 0x6c, 0x5f, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x22, 0xe2,
        0x02, 0x0a, 0x0a, 0x42, 0x79, 0x74, 0x65, 0x73, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a,
        0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x63, 0x6f,
        0x6e, 0x73, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x65, 0x6e, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x04,
        0x52, 0x03, 0x6c, 0x65, 0x6e, 0x12, 0x17, 0x0a, 0x07, 0x6d, 0x69, 0x6e, 0x5f, 0x6c, 0x65, 0x6e,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x6d, 0x69, 0x6e, 0x4c, 0x65, 0x6e, 0x12, 0x17,
        0x0a, 0x07, 0x6d, 0x61, 0x78, 0x5f, 0x6c, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52,
        0x06, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65,
        0x72, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72,
        0x6e, 0x12, 0x16, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x05, 0x20, 0x01, 0x28,
        0x0c, 0x52, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x75, 0x66,
        0x66, 0x69, 0x78, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x06, 0x73, 0x75, 0x66, 0x66, 0x69,
        0x78, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x07, 0x20,
        0x01, 0x28, 0x0c, 0x52, 0x08, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x0e, 0x0a,
        0x02, 0x69, 0x6e, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a,
        0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x05, 0x6e,
        0x6f, 0x74, 0x49, 0x6e, 0x12, 0x10, 0x0a, 0x02, 0x69, 0x70, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08,
        0x48, 0x00, 0x52, 0x02, 0x69, 0x70, 0x12, 0x14, 0x0a, 0x04, 0x69, 0x70, 0x76, 0x34, 0x18, 0x0b,
        0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x04, 0x69, 0x70, 0x76, 0x34, 0x12, 0x14, 0x0a, 0x04,
        0x69, 0x70, 0x76, 0x36, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x04, 0x69, 0x70,
        0x76, 0x36, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70,
        0x74, 0x79, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65,
        0x45, 0x6d, 0x70, 0x74, 0x79, 0x42, 0x0c, 0x0a, 0x0a, 0x77, 0x65, 0x6c, 0x6c, 0x5f, 0x6b, 0x6e,
        0x6f, 0x77, 0x6e, 0x22, 0x6b, 0x0a, 0x09, 0x45, 0x6e, 0x75, 0x6d, 0x52, 0x75, 0x6c, 0x65, 0x73,
        0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x21, 0x0a, 0x0c, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65,
        0x64, 0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x64, 0x65,
        0x66, 0x69, 0x6e, 0x65, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18,
        0x03, 0x20, 0x03, 0x28, 0x05, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74,
        0x5f, 0x69, 0x6e, 0x18, 0x04, 0x20, 0x03, 0x28, 0x05, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e,
        0x22, 0x3e, 0x0a, 0x0c, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x75, 0x6c, 0x65, 0x73,
        0x12, 0x12, 0x0a, 0x04, 0x73, 0x6b, 0x69, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x04,
        0x73, 0x6b, 0x69, 0x70, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64,
        0x22, 0xb0, 0x01, 0x0a, 0x0d, 0x52, 0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 0x52, 0x75, 0x6c,
        0x65, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x69, 0x6e, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x12,
        0x1b, 0x0a, 0x09, 0x6d, 0x61, 0x78, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x04, 0x52, 0x08, 0x6d, 0x61, 0x78, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x12, 0x16, 0x0a, 0x06,
        0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x75, 0x6e,
        0x69, 0x71, 0x75, 0x65, 0x12, 0x2a, 0x0a, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x04, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x46,
        0x69, 0x65, 0x6c, 0x64, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x52, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73,
        0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79,
        0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d,
        0x70, 0x74, 0x79, 0x22, 0xdc, 0x01, 0x0a, 0x08, 0x4d, 0x61, 0x70, 0x52, 0x75, 0x6c, 0x65, 0x73,
        0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x69, 0x6e, 0x5f, 0x70, 0x61, 0x69, 0x72, 0x73, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x04, 0x52, 0x08, 0x6d, 0x69, 0x6e, 0x50, 0x61, 0x69, 0x72, 0x73, 0x12, 0x1b, 0x0a,
        0x09, 0x6d, 0x61, 0x78, 0x5f, 0x70, 0x61, 0x69, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04,
        0x52, 0x08, 0x6d, 0x61, 0x78, 0x50, 0x61, 0x69, 0x72, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x6e, 0x6f,
        0x5f, 0x73, 0x70, 0x61, 0x72, 0x73, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x6e,
        0x6f, 0x53, 0x70, 0x61, 0x72, 0x73, 0x65, 0x12, 0x28, 0x0a, 0x04, 0x6b, 0x65, 0x79, 0x73, 0x18,
        0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65,
        0x2e, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x52, 0x04, 0x6b, 0x65, 0x79,
        0x73, 0x12, 0x2c, 0x0a, 0x06, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x46, 0x69, 0x65,
        0x6c, 0x64, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x52, 0x06, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12,
        0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x18,
        0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70,
        0x74, 0x79, 0x22, 0x4d, 0x0a, 0x08, 0x41, 0x6e, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x1a,
        0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08,
        0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e,
        0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f,
        0x74, 0x5f, 0x69, 0x6e, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49,
        0x6e, 0x22, 0xe9, 0x02, 0x0a, 0x0d, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x75,
        0x6c, 0x65, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x12,
        0x2f, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74,
        0x12, 0x29, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44,
        0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x2b, 0x0a, 0x03, 0x6c,
        0x74, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x29, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x05,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52,
        0x02, 0x67, 0x74, 0x12, 0x2b, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
        0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x03, 0x67, 0x74, 0x65,
        0x12, 0x29, 0x0a, 0x02, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44,
        0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x30, 0x0a, 0x06, 0x6e,
        0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f,
        0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75,
        0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x22, 0xf3, 0x02,
        0x0a, 0x0e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x75, 0x6c, 0x65, 0x73,
        0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x12, 0x30, 0x0a, 0x05,
        0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f,
        0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69,
        0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x2a,
        0x0a, 0x02, 0x6c, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d,
        0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x2c, 0x0a, 0x03, 0x6c, 0x74,
        0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
        0x61, 0x6d, 0x70, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x2a, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x05,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
        0x52, 0x02, 0x67, 0x74, 0x12, 0x2c, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x03, 0x67,
        0x74, 0x65, 0x12, 0x15, 0x0a, 0x06, 0x6c, 0x74, 0x5f, 0x6e, 0x6f, 0x77, 0x18, 0x07, 0x20, 0x01,
        0x28, 0x08, 0x52, 0x05, 0x6c, 0x74, 0x4e, 0x6f, 0x77, 0x12, 0x15, 0x0a, 0x06, 0x67, 0x74, 0x5f,
        0x6e, 0x6f, 0x77, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05, 0x67, 0x74, 0x4e, 0x6f, 0x77,
        0x12, 0x31, 0x0a, 0x06, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6e, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
        0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x06, 0x77, 0x69, 0x74,
        0x68, 0x69, 0x6e, 0x2a, 0x46, 0x0a, 0x0a, 0x4b, 0x6e, 0x6f, 0x77, 0x6e, 0x52, 0x65, 0x67, 0x65,
        0x78, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x14,
        0x0a, 0x10, 0x48, 0x54, 0x54, 0x50, 0x5f, 0x48, 0x45, 0x41, 0x44, 0x45, 0x52, 0x5f, 0x4e, 0x41,
        0x4d, 0x45, 0x10, 0x01, 0x12, 0x15, 0x0a, 0x11, 0x48, 0x54, 0x54, 0x50, 0x5f, 0x48, 0x45, 0x41,
        0x44, 0x45, 0x52, 0x5f, 0x56, 0x41, 0x4c, 0x55, 0x45, 0x10, 0x02, 0x3a, 0x3c, 0x0a, 0x08, 0x64,
        0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67,
        0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xaf, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52,
        0x08, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x3a, 0x3a, 0x0a, 0x07, 0x69, 0x67, 0x6e,
        0x6f, 0x72, 0x65, 0x64, 0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x4f, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xb0, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x69, 0x67,
        0x6e, 0x6f, 0x72, 0x65, 0x64, 0x3a, 0x3a, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65,
        0x64, 0x12, 0x1d, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x4f, 0x6e, 0x65, 0x6f, 0x66, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x18, 0xaf, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65,
        0x64, 0x3a, 0x4a, 0x0a, 0x05, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x1d, 0x2e, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x46, 0x69, 0x65,
        0x6c, 0x64, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xaf, 0x08, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x46, 0x69, 0x65, 0x6c,
        0x64, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x52, 0x05, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x42, 0x50, 0x0a,
        0x1a, 0x69, 0x6f, 0x2e, 0x65, 0x6e, 0x76, 0x6f, 0x79, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x70,
        0x67, 0x76, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x5a, 0x32, 0x67, 0x69, 0x74,
        0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x65, 0x6e, 0x76, 0x6f, 0x79, 0x70, 0x72, 0x6f,
        0x78, 0x79, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e, 0x2d, 0x76, 0x61,
        0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2f, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65,
}

var (
        file_validate_validate_proto_rawDescOnce sync.Once
        file_validate_validate_proto_rawDescData = file_validate_validate_proto_rawDesc
)

func file_validate_validate_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_validate_validate_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_validate_validate_proto_rawDescData = protoimpl.X.CompressGZIP(file_validate_validate_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_validate_validate_proto_rawDescData</span>
}

var file_validate_validate_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_validate_validate_proto_msgTypes = make([]protoimpl.MessageInfo, 23)
var file_validate_validate_proto_goTypes = []interface{}{
        (KnownRegex)(0),                     // 0: validate.KnownRegex
        (*FieldRules)(nil),                  // 1: validate.FieldRules
        (*FloatRules)(nil),                  // 2: validate.FloatRules
        (*DoubleRules)(nil),                 // 3: validate.DoubleRules
        (*Int32Rules)(nil),                  // 4: validate.Int32Rules
        (*Int64Rules)(nil),                  // 5: validate.Int64Rules
        (*UInt32Rules)(nil),                 // 6: validate.UInt32Rules
        (*UInt64Rules)(nil),                 // 7: validate.UInt64Rules
        (*SInt32Rules)(nil),                 // 8: validate.SInt32Rules
        (*SInt64Rules)(nil),                 // 9: validate.SInt64Rules
        (*Fixed32Rules)(nil),                // 10: validate.Fixed32Rules
        (*Fixed64Rules)(nil),                // 11: validate.Fixed64Rules
        (*SFixed32Rules)(nil),               // 12: validate.SFixed32Rules
        (*SFixed64Rules)(nil),               // 13: validate.SFixed64Rules
        (*BoolRules)(nil),                   // 14: validate.BoolRules
        (*StringRules)(nil),                 // 15: validate.StringRules
        (*BytesRules)(nil),                  // 16: validate.BytesRules
        (*EnumRules)(nil),                   // 17: validate.EnumRules
        (*MessageRules)(nil),                // 18: validate.MessageRules
        (*RepeatedRules)(nil),               // 19: validate.RepeatedRules
        (*MapRules)(nil),                    // 20: validate.MapRules
        (*AnyRules)(nil),                    // 21: validate.AnyRules
        (*DurationRules)(nil),               // 22: validate.DurationRules
        (*TimestampRules)(nil),              // 23: validate.TimestampRules
        (*durationpb.Duration)(nil),         // 24: google.protobuf.Duration
        (*timestamppb.Timestamp)(nil),       // 25: google.protobuf.Timestamp
        (*descriptorpb.MessageOptions)(nil), // 26: google.protobuf.MessageOptions
        (*descriptorpb.OneofOptions)(nil),   // 27: google.protobuf.OneofOptions
        (*descriptorpb.FieldOptions)(nil),   // 28: google.protobuf.FieldOptions
}
var file_validate_validate_proto_depIdxs = []int32{
        18, // 0: validate.FieldRules.message:type_name -&gt; validate.MessageRules
        2,  // 1: validate.FieldRules.float:type_name -&gt; validate.FloatRules
        3,  // 2: validate.FieldRules.double:type_name -&gt; validate.DoubleRules
        4,  // 3: validate.FieldRules.int32:type_name -&gt; validate.Int32Rules
        5,  // 4: validate.FieldRules.int64:type_name -&gt; validate.Int64Rules
        6,  // 5: validate.FieldRules.uint32:type_name -&gt; validate.UInt32Rules
        7,  // 6: validate.FieldRules.uint64:type_name -&gt; validate.UInt64Rules
        8,  // 7: validate.FieldRules.sint32:type_name -&gt; validate.SInt32Rules
        9,  // 8: validate.FieldRules.sint64:type_name -&gt; validate.SInt64Rules
        10, // 9: validate.FieldRules.fixed32:type_name -&gt; validate.Fixed32Rules
        11, // 10: validate.FieldRules.fixed64:type_name -&gt; validate.Fixed64Rules
        12, // 11: validate.FieldRules.sfixed32:type_name -&gt; validate.SFixed32Rules
        13, // 12: validate.FieldRules.sfixed64:type_name -&gt; validate.SFixed64Rules
        14, // 13: validate.FieldRules.bool:type_name -&gt; validate.BoolRules
        15, // 14: validate.FieldRules.string:type_name -&gt; validate.StringRules
        16, // 15: validate.FieldRules.bytes:type_name -&gt; validate.BytesRules
        17, // 16: validate.FieldRules.enum:type_name -&gt; validate.EnumRules
        19, // 17: validate.FieldRules.repeated:type_name -&gt; validate.RepeatedRules
        20, // 18: validate.FieldRules.map:type_name -&gt; validate.MapRules
        21, // 19: validate.FieldRules.any:type_name -&gt; validate.AnyRules
        22, // 20: validate.FieldRules.duration:type_name -&gt; validate.DurationRules
        23, // 21: validate.FieldRules.timestamp:type_name -&gt; validate.TimestampRules
        0,  // 22: validate.StringRules.well_known_regex:type_name -&gt; validate.KnownRegex
        1,  // 23: validate.RepeatedRules.items:type_name -&gt; validate.FieldRules
        1,  // 24: validate.MapRules.keys:type_name -&gt; validate.FieldRules
        1,  // 25: validate.MapRules.values:type_name -&gt; validate.FieldRules
        24, // 26: validate.DurationRules.const:type_name -&gt; google.protobuf.Duration
        24, // 27: validate.DurationRules.lt:type_name -&gt; google.protobuf.Duration
        24, // 28: validate.DurationRules.lte:type_name -&gt; google.protobuf.Duration
        24, // 29: validate.DurationRules.gt:type_name -&gt; google.protobuf.Duration
        24, // 30: validate.DurationRules.gte:type_name -&gt; google.protobuf.Duration
        24, // 31: validate.DurationRules.in:type_name -&gt; google.protobuf.Duration
        24, // 32: validate.DurationRules.not_in:type_name -&gt; google.protobuf.Duration
        25, // 33: validate.TimestampRules.const:type_name -&gt; google.protobuf.Timestamp
        25, // 34: validate.TimestampRules.lt:type_name -&gt; google.protobuf.Timestamp
        25, // 35: validate.TimestampRules.lte:type_name -&gt; google.protobuf.Timestamp
        25, // 36: validate.TimestampRules.gt:type_name -&gt; google.protobuf.Timestamp
        25, // 37: validate.TimestampRules.gte:type_name -&gt; google.protobuf.Timestamp
        24, // 38: validate.TimestampRules.within:type_name -&gt; google.protobuf.Duration
        26, // 39: validate.disabled:extendee -&gt; google.protobuf.MessageOptions
        26, // 40: validate.ignored:extendee -&gt; google.protobuf.MessageOptions
        27, // 41: validate.required:extendee -&gt; google.protobuf.OneofOptions
        28, // 42: validate.rules:extendee -&gt; google.protobuf.FieldOptions
        1,  // 43: validate.rules:type_name -&gt; validate.FieldRules
        44, // [44:44] is the sub-list for method output_type
        44, // [44:44] is the sub-list for method input_type
        43, // [43:44] is the sub-list for extension type_name
        39, // [39:43] is the sub-list for extension extendee
        0,  // [0:39] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_validate_validate_proto_init() }</span>
func file_validate_validate_proto_init() <span class="cov0" title="0">{
        if File_validate_validate_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_validate_validate_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FieldRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FloatRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DoubleRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Int32Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Int64Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UInt32Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UInt64Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SInt32Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SInt64Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Fixed32Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Fixed64Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SFixed32Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SFixed64Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*BoolRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*StringRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*BytesRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*EnumRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*MessageRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RepeatedRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*MapRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*AnyRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DurationRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*TimestampRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">file_validate_validate_proto_msgTypes[0].OneofWrappers = []interface{}{
                (*FieldRules_Float)(nil),
                (*FieldRules_Double)(nil),
                (*FieldRules_Int32)(nil),
                (*FieldRules_Int64)(nil),
                (*FieldRules_Uint32)(nil),
                (*FieldRules_Uint64)(nil),
                (*FieldRules_Sint32)(nil),
                (*FieldRules_Sint64)(nil),
                (*FieldRules_Fixed32)(nil),
                (*FieldRules_Fixed64)(nil),
                (*FieldRules_Sfixed32)(nil),
                (*FieldRules_Sfixed64)(nil),
                (*FieldRules_Bool)(nil),
                (*FieldRules_String_)(nil),
                (*FieldRules_Bytes)(nil),
                (*FieldRules_Enum)(nil),
                (*FieldRules_Repeated)(nil),
                (*FieldRules_Map)(nil),
                (*FieldRules_Any)(nil),
                (*FieldRules_Duration)(nil),
                (*FieldRules_Timestamp)(nil),
        }
        file_validate_validate_proto_msgTypes[14].OneofWrappers = []interface{}{
                (*StringRules_Email)(nil),
                (*StringRules_Hostname)(nil),
                (*StringRules_Ip)(nil),
                (*StringRules_Ipv4)(nil),
                (*StringRules_Ipv6)(nil),
                (*StringRules_Uri)(nil),
                (*StringRules_UriRef)(nil),
                (*StringRules_Address)(nil),
                (*StringRules_Uuid)(nil),
                (*StringRules_WellKnownRegex)(nil),
        }
        file_validate_validate_proto_msgTypes[15].OneofWrappers = []interface{}{
                (*BytesRules_Ip)(nil),
                (*BytesRules_Ipv4)(nil),
                (*BytesRules_Ipv6)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_validate_validate_proto_rawDesc,
                        NumEnums:      1,
                        NumMessages:   23,
                        NumExtensions: 4,
                        NumServices:   0,
                },
                GoTypes:           file_validate_validate_proto_goTypes,
                DependencyIndexes: file_validate_validate_proto_depIdxs,
                EnumInfos:         file_validate_validate_proto_enumTypes,
                MessageInfos:      file_validate_validate_proto_msgTypes,
                ExtensionInfos:    file_validate_validate_proto_extTypes,
        }.Build()
        File_validate_validate_proto = out.File
        file_validate_validate_proto_rawDesc = nil
        file_validate_validate_proto_goTypes = nil
        file_validate_validate_proto_depIdxs = nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
